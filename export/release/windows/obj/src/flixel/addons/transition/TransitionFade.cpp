// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_TransitionData
#include <flixel/addons/transition/TransitionData.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_TransitionEffect
#include <flixel/addons/transition/TransitionEffect.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_TransitionFade
#include <flixel/addons/transition/TransitionFade.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_BitmapFrontEnd
#include <flixel/system/frontEnds/BitmapFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_FlxGradient
#include <flixel/util/FlxGradient.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_85f0573c4a29b283_51_new,"flixel.addons.transition.TransitionFade","new",0x4927e913,"flixel.addons.transition.TransitionFade.new","flixel/addons/transition/TransitionFade.hx",51,0x307a6abc)
HX_LOCAL_STACK_FRAME(_hx_pos_85f0573c4a29b283_60_destroy,"flixel.addons.transition.TransitionFade","destroy",0x16001b2d,"flixel.addons.transition.TransitionFade.destroy","flixel/addons/transition/TransitionFade.hx",60,0x307a6abc)
HX_LOCAL_STACK_FRAME(_hx_pos_85f0573c4a29b283_66_start,"flixel.addons.transition.TransitionFade","start",0xbc9d5fd5,"flixel.addons.transition.TransitionFade.start","flixel/addons/transition/TransitionFade.hx",66,0x307a6abc)
HX_LOCAL_STACK_FRAME(_hx_pos_85f0573c4a29b283_77_setTweenValues,"flixel.addons.transition.TransitionFade","setTweenValues",0x069b0e58,"flixel.addons.transition.TransitionFade.setTweenValues","flixel/addons/transition/TransitionFade.hx",77,0x307a6abc)
HX_LOCAL_STACK_FRAME(_hx_pos_85f0573c4a29b283_133_getBitmapKey,"flixel.addons.transition.TransitionFade","getBitmapKey",0x422be667,"flixel.addons.transition.TransitionFade.getBitmapKey","flixel/addons/transition/TransitionFade.hx",133,0x307a6abc)
HX_LOCAL_STACK_FRAME(_hx_pos_85f0573c4a29b283_137_makeSprite,"flixel.addons.transition.TransitionFade","makeSprite",0x080a6440,"flixel.addons.transition.TransitionFade.makeSprite","flixel/addons/transition/TransitionFade.hx",137,0x307a6abc)
HX_LOCAL_STACK_FRAME(_hx_pos_85f0573c4a29b283_185_getGradient,"flixel.addons.transition.TransitionFade","getGradient",0xadab8059,"flixel.addons.transition.TransitionFade.getGradient","flixel/addons/transition/TransitionFade.hx",185,0x307a6abc)
HX_LOCAL_STACK_FRAME(_hx_pos_85f0573c4a29b283_213_finishTween,"flixel.addons.transition.TransitionFade","finishTween",0x9dee50cb,"flixel.addons.transition.TransitionFade.finishTween","flixel/addons/transition/TransitionFade.hx",213,0x307a6abc)
HX_LOCAL_STACK_FRAME(_hx_pos_85f0573c4a29b283_46_boot,"flixel.addons.transition.TransitionFade","boot",0xb1dd081f,"flixel.addons.transition.TransitionFade.boot","flixel/addons/transition/TransitionFade.hx",46,0x307a6abc)
namespace flixel{
namespace addons{
namespace transition{

void TransitionFade_obj::__construct( ::flixel::addons::transition::TransitionData data){
            	HX_STACKFRAME(&_hx_pos_85f0573c4a29b283_51_new)
HXLINE(  52)		super::__construct(data);
HXLINE(  54)		this->back = this->makeSprite(data->direction->x,data->direction->y,data->region);
HXLINE(  55)		{
HXLINE(  55)			 ::flixel::math::FlxBasePoint this1 = this->back->scrollFactor;
HXDLIN(  55)			this1->set_x(( (Float)(0) ));
HXDLIN(  55)			this1->set_y(( (Float)(0) ));
            		}
HXLINE(  56)		this->add(this->back);
            	}

Dynamic TransitionFade_obj::__CreateEmpty() { return new TransitionFade_obj; }

void *TransitionFade_obj::_hx_vtable = 0;

Dynamic TransitionFade_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< TransitionFade_obj > _hx_result = new TransitionFade_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool TransitionFade_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x5b6c5e35) {
		if (inClassId<=(int)0x2c01639b) {
			if (inClassId<=(int)0x288ce903) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x288ce903;
			} else {
				return inClassId==(int)0x2c01639b;
			}
		} else {
			return inClassId==(int)0x5b6c5e35;
		}
	} else {
		if (inClassId<=(int)0x7dab0655) {
			return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
		} else {
			return inClassId==(int)0x7fcf2fe2;
		}
	}
}

void TransitionFade_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_85f0573c4a29b283_60_destroy)
HXLINE(  61)		this->super::destroy();
HXLINE(  62)		this->back = null();
            	}


void TransitionFade_obj::start(int newStatus){
            	HX_STACKFRAME(&_hx_pos_85f0573c4a29b283_66_start)
HXLINE(  67)		this->super::start(newStatus);
HXLINE(  69)		 ::Dynamic endValues =  ::Dynamic(::hx::Anon_obj::Create(0));
HXLINE(  70)		this->setTweenValues((newStatus == 0),this->_data->direction->x,this->_data->direction->y,this->back,endValues);
HXLINE(  72)		this->_data->tweenOptions->__SetField(HX_("onComplete",f8,d4,7e,5d),this->finishTween_dyn(),::hx::paccDynamic);
HXLINE(  73)		::flixel::tweens::FlxTween_obj::tween(this->back,endValues,this->_data->duration,this->_data->tweenOptions);
            	}


void TransitionFade_obj::setTweenValues(bool isIn,Float dirX,Float dirY, ::flixel::FlxSprite sprite, ::Dynamic values){
            	HX_STACKFRAME(&_hx_pos_85f0573c4a29b283_77_setTweenValues)
HXLINE(  78)		bool isOut = !(isIn);
HXLINE(  79)		bool _hx_tmp;
HXDLIN(  79)		if ((dirX == 0)) {
HXLINE(  79)			_hx_tmp = (dirY == 0);
            		}
            		else {
HXLINE(  79)			_hx_tmp = false;
            		}
HXDLIN(  79)		if (_hx_tmp) {
HXLINE(  82)			Float _hx_tmp1;
HXDLIN(  82)			if (isIn) {
HXLINE(  82)				_hx_tmp1 = ( (Float)(0) );
            			}
            			else {
HXLINE(  82)				_hx_tmp1 = ( (Float)(1) );
            			}
HXDLIN(  82)			sprite->set_alpha(_hx_tmp1);
HXLINE(  83)			 ::Dynamic _hx_tmp2;
HXDLIN(  83)			if (isOut) {
HXLINE(  83)				_hx_tmp2 = 0;
            			}
            			else {
HXLINE(  83)				_hx_tmp2 = 1;
            			}
HXDLIN(  83)			values->__SetField(HX_("alpha",5e,a7,96,21),_hx_tmp2,::hx::paccDynamic);
            		}
            		else {
HXLINE(  85)			bool _hx_tmp3;
HXDLIN(  85)			if ((dirX != 0)) {
HXLINE(  85)				_hx_tmp3 = (dirY != 0);
            			}
            			else {
HXLINE(  85)				_hx_tmp3 = false;
            			}
HXDLIN(  85)			if (_hx_tmp3) {
HXLINE(  88)				if ((dirX > 0)) {
HXLINE(  90)					Float _hx_tmp4;
HXDLIN(  90)					if (isIn) {
HXLINE(  90)						_hx_tmp4 = -(this->back->get_width());
            					}
            					else {
HXLINE(  90)						_hx_tmp4 = ( (Float)(0) );
            					}
HXDLIN(  90)					sprite->set_x(_hx_tmp4);
HXLINE(  91)					 ::Dynamic _hx_tmp5;
HXDLIN(  91)					if (isOut) {
HXLINE(  91)						_hx_tmp5 = -(this->back->get_width());
            					}
            					else {
HXLINE(  91)						_hx_tmp5 = 0;
            					}
HXDLIN(  91)					values->__SetField(HX_("x",78,00,00,00),_hx_tmp5,::hx::paccDynamic);
            				}
            				else {
HXLINE(  95)					Float _hx_tmp6;
HXDLIN(  95)					if (isIn) {
HXLINE(  95)						_hx_tmp6 = ( (Float)(::flixel::FlxG_obj::width) );
            					}
            					else {
HXLINE(  95)						int _hx_tmp7 = ::flixel::FlxG_obj::width;
HXDLIN(  95)						_hx_tmp6 = (( (Float)(_hx_tmp7) ) - this->back->get_width());
            					}
HXDLIN(  95)					sprite->set_x(_hx_tmp6);
HXLINE(  96)					 ::Dynamic _hx_tmp8;
HXDLIN(  96)					if (isOut) {
HXLINE(  96)						_hx_tmp8 = ::flixel::FlxG_obj::width;
            					}
            					else {
HXLINE(  96)						int _hx_tmp9 = ::flixel::FlxG_obj::width;
HXDLIN(  96)						_hx_tmp8 = (( (Float)(_hx_tmp9) ) - this->back->get_width());
            					}
HXDLIN(  96)					values->__SetField(HX_("x",78,00,00,00),_hx_tmp8,::hx::paccDynamic);
            				}
HXLINE(  99)				return;
            			}
            			else {
HXLINE( 101)				if ((dirX != 0)) {
HXLINE( 104)					if ((dirX > 0)) {
HXLINE( 106)						Float _hx_tmp10;
HXDLIN( 106)						if (isIn) {
HXLINE( 106)							_hx_tmp10 = -(this->back->get_width());
            						}
            						else {
HXLINE( 106)							_hx_tmp10 = ( (Float)(0) );
            						}
HXDLIN( 106)						sprite->set_x(_hx_tmp10);
HXLINE( 107)						 ::Dynamic _hx_tmp11;
HXDLIN( 107)						if (isOut) {
HXLINE( 107)							_hx_tmp11 = -(this->back->get_width());
            						}
            						else {
HXLINE( 107)							_hx_tmp11 = 0;
            						}
HXDLIN( 107)						values->__SetField(HX_("x",78,00,00,00),_hx_tmp11,::hx::paccDynamic);
            					}
            					else {
HXLINE( 111)						Float _hx_tmp12;
HXDLIN( 111)						if (isIn) {
HXLINE( 111)							_hx_tmp12 = ( (Float)(::flixel::FlxG_obj::width) );
            						}
            						else {
HXLINE( 111)							_hx_tmp12 = (-(this->back->get_width()) / ( (Float)(2) ));
            						}
HXDLIN( 111)						sprite->set_x(_hx_tmp12);
HXLINE( 112)						 ::Dynamic _hx_tmp13;
HXDLIN( 112)						if (isOut) {
HXLINE( 112)							_hx_tmp13 = ::flixel::FlxG_obj::width;
            						}
            						else {
HXLINE( 112)							_hx_tmp13 = (-(this->back->get_width()) / ( (Float)(2) ));
            						}
HXDLIN( 112)						values->__SetField(HX_("x",78,00,00,00),_hx_tmp13,::hx::paccDynamic);
            					}
            				}
            				else {
HXLINE( 118)					if ((dirY > 0)) {
HXLINE( 120)						Float _hx_tmp14;
HXDLIN( 120)						if (isIn) {
HXLINE( 120)							_hx_tmp14 = -(this->back->get_height());
            						}
            						else {
HXLINE( 120)							_hx_tmp14 = ( (Float)(0) );
            						}
HXDLIN( 120)						sprite->set_y(_hx_tmp14);
HXLINE( 121)						 ::Dynamic _hx_tmp15;
HXDLIN( 121)						if (isOut) {
HXLINE( 121)							_hx_tmp15 = -(this->back->get_height());
            						}
            						else {
HXLINE( 121)							_hx_tmp15 = 0;
            						}
HXDLIN( 121)						values->__SetField(HX_("y",79,00,00,00),_hx_tmp15,::hx::paccDynamic);
            					}
            					else {
HXLINE( 125)						Float _hx_tmp16;
HXDLIN( 125)						if (isIn) {
HXLINE( 125)							_hx_tmp16 = ( (Float)(::flixel::FlxG_obj::height) );
            						}
            						else {
HXLINE( 125)							_hx_tmp16 = (-(this->back->get_height()) / ( (Float)(2) ));
            						}
HXDLIN( 125)						sprite->set_y(_hx_tmp16);
HXLINE( 126)						 ::Dynamic _hx_tmp17;
HXDLIN( 126)						if (isOut) {
HXLINE( 126)							_hx_tmp17 = ::flixel::FlxG_obj::height;
            						}
            						else {
HXLINE( 126)							_hx_tmp17 = (-(this->back->get_height()) / ( (Float)(2) ));
            						}
HXDLIN( 126)						values->__SetField(HX_("y",79,00,00,00),_hx_tmp17,::hx::paccDynamic);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(TransitionFade_obj,setTweenValues,(void))

::String TransitionFade_obj::getBitmapKey(Float dirX,Float dirY,int color){
            	HX_STACKFRAME(&_hx_pos_85f0573c4a29b283_133_getBitmapKey)
HXDLIN( 133)		return (((((HX_("transition",95,8d,af,58) + color) + HX_("x",78,00,00,00)) + dirX) + HX_("y",79,00,00,00)) + dirY);
            	}


HX_DEFINE_DYNAMIC_FUNC3(TransitionFade_obj,getBitmapKey,return )

 ::flixel::FlxSprite TransitionFade_obj::makeSprite(Float dirX,Float dirY, ::flixel::math::FlxRect region){
            	HX_GC_STACKFRAME(&_hx_pos_85f0573c4a29b283_137_makeSprite)
HXLINE( 138)		 ::flixel::FlxSprite sprite =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,region->x,region->y,null());
HXLINE( 139)		::String bitmapKey = (((((HX_("transition",95,8d,af,58) + this->_data->color) + HX_("x",78,00,00,00)) + dirX) + HX_("y",79,00,00,00)) + dirY);
HXLINE( 141)		sprite->set_antialiasing(false);
HXLINE( 143)		bool _hx_tmp;
HXDLIN( 143)		if ((dirX == 0)) {
HXLINE( 143)			_hx_tmp = (dirY == 0);
            		}
            		else {
HXLINE( 143)			_hx_tmp = false;
            		}
HXDLIN( 143)		if (_hx_tmp) {
HXLINE( 146)			sprite->makeGraphic(1,1,this->_data->color,false,bitmapKey);
HXLINE( 147)			{
HXLINE( 147)				 ::flixel::math::FlxBasePoint this1 = sprite->scale;
HXDLIN( 147)				Float x = ( (Float)(::Std_obj::_hx_int(region->width)) );
HXDLIN( 147)				Float y = ( (Float)(::Std_obj::_hx_int(region->height)) );
HXDLIN( 147)				this1->set_x(x);
HXDLIN( 147)				this1->set_y(y);
            			}
HXLINE( 148)			sprite->updateHitbox();
            		}
            		else {
HXLINE( 150)			bool _hx_tmp1;
HXDLIN( 150)			if ((dirX == 0)) {
HXLINE( 150)				_hx_tmp1 = (dirY != 0);
            			}
            			else {
HXLINE( 150)				_hx_tmp1 = false;
            			}
HXDLIN( 150)			if (_hx_tmp1) {
HXLINE( 153)				int _hx_tmp2 = ::Std_obj::_hx_int((region->height * ( (Float)(2) )));
HXDLIN( 153)				sprite->makeGraphic(1,_hx_tmp2,this->_data->color,false,bitmapKey);
HXLINE( 154)				int angle;
HXDLIN( 154)				if ((dirY > 0)) {
HXLINE( 154)					angle = 90;
            				}
            				else {
HXLINE( 154)					angle = 270;
            				}
HXLINE( 155)				int gradient = ::Std_obj::_hx_int(region->height);
HXDLIN( 155)				 ::openfl::display::BitmapData gradient1 = ::flixel::util::FlxGradient_obj::createGradientBitmapData(1,gradient,::Array_obj< int >::__new(2)->init(0,this->_data->color)->init(1,0),1,angle,null());
HXLINE( 156)				Float destY;
HXDLIN( 156)				if ((dirY > 0)) {
HXLINE( 156)					destY = region->height;
            				}
            				else {
HXLINE( 156)					destY = ( (Float)(0) );
            				}
HXLINE( 157)				 ::openfl::display::BitmapData _hx_tmp3 = sprite->get_pixels();
HXDLIN( 157)				 ::openfl::geom::Rectangle gradient2 = gradient1->rect;
HXDLIN( 157)				_hx_tmp3->copyPixels(gradient1,gradient2, ::openfl::geom::Point_obj::__alloc( HX_CTX ,0,destY),null(),null(),null());
HXLINE( 158)				{
HXLINE( 158)					 ::flixel::math::FlxBasePoint this2 = sprite->scale;
HXDLIN( 158)					this2->set_x(region->width);
HXDLIN( 158)					this2->set_y(((Float)1.0));
            				}
HXLINE( 159)				sprite->updateHitbox();
            			}
            			else {
HXLINE( 161)				bool _hx_tmp4;
HXDLIN( 161)				if ((dirX != 0)) {
HXLINE( 161)					_hx_tmp4 = (dirY == 0);
            				}
            				else {
HXLINE( 161)					_hx_tmp4 = false;
            				}
HXDLIN( 161)				if (_hx_tmp4) {
HXLINE( 164)					Float destX;
HXDLIN( 164)					if ((dirX > 0)) {
HXLINE( 164)						destX = region->width;
            					}
            					else {
HXLINE( 164)						destX = ( (Float)(0) );
            					}
HXLINE( 165)					int angle1;
HXDLIN( 165)					if ((dirX > 0)) {
HXLINE( 165)						angle1 = 0;
            					}
            					else {
HXLINE( 165)						angle1 = 180;
            					}
HXLINE( 166)					int _hx_tmp5 = ::Std_obj::_hx_int((region->width * ( (Float)(2) )));
HXDLIN( 166)					sprite->makeGraphic(_hx_tmp5,1,this->_data->color,false,bitmapKey);
HXLINE( 167)					int gradient3 = ::Std_obj::_hx_int(region->width);
HXDLIN( 167)					 ::openfl::display::BitmapData gradient4 = ::flixel::util::FlxGradient_obj::createGradientBitmapData(gradient3,1,::Array_obj< int >::__new(2)->init(0,this->_data->color)->init(1,0),1,angle1,null());
HXLINE( 168)					 ::openfl::display::BitmapData _hx_tmp6 = sprite->get_pixels();
HXDLIN( 168)					 ::openfl::geom::Rectangle gradient5 = gradient4->rect;
HXDLIN( 168)					_hx_tmp6->copyPixels(gradient4,gradient5, ::openfl::geom::Point_obj::__alloc( HX_CTX ,destX,0),null(),null(),null());
HXLINE( 169)					{
HXLINE( 169)						 ::flixel::math::FlxBasePoint this3 = sprite->scale;
HXDLIN( 169)						Float y1 = region->height;
HXDLIN( 169)						this3->set_x(((Float)1.0));
HXDLIN( 169)						this3->set_y(y1);
            					}
HXLINE( 170)					sprite->updateHitbox();
            				}
            				else {
HXLINE( 172)					bool _hx_tmp7;
HXDLIN( 172)					if ((dirX != 0)) {
HXLINE( 172)						_hx_tmp7 = (dirY != 0);
            					}
            					else {
HXLINE( 172)						_hx_tmp7 = false;
            					}
HXDLIN( 172)					if (_hx_tmp7) {
HXLINE( 175)						sprite->loadGraphic(this->getGradient(),null(),null(),null(),null(),null());
HXLINE( 176)						sprite->set_color(this->_data->color);
HXLINE( 177)						sprite->set_flipX((dirX < 0));
HXLINE( 178)						sprite->set_flipY((dirY < 0));
            					}
            				}
            			}
            		}
HXLINE( 181)		return sprite;
            	}


HX_DEFINE_DYNAMIC_FUNC3(TransitionFade_obj,makeSprite,return )

 ::flixel::graphics::FlxGraphic TransitionFade_obj::getGradient(){
            	HX_GC_STACKFRAME(&_hx_pos_85f0573c4a29b283_185_getGradient)
HXLINE( 187)		int gameWidth = ::flixel::FlxG_obj::width;
HXLINE( 188)		int gameHeight = ::flixel::FlxG_obj::height;
HXLINE( 189)		 ::openfl::display::BitmapData source = ::flixel::FlxG_obj::bitmap->add(HX_("flixel/images/transitions/diagonal_gradient.png",20,34,41,22),null(),null())->bitmap;
HXLINE( 190)		::String key = ((((HX_("flixel/images/transitions/diagonal_gradient.png",20,34,41,22) + HX_(":",3a,00,00,00)) + gameWidth) + HX_("x",78,00,00,00)) + gameHeight);
HXLINE( 192)		 ::flixel::graphics::FlxGraphic graphic = ( ( ::flixel::graphics::FlxGraphic)(::flixel::FlxG_obj::bitmap->_cache->get(key)) );
HXLINE( 193)		if (::hx::IsNull( graphic )) {
HXLINE( 195)			 ::openfl::display::BitmapData gradient =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,::Math_obj::floor((( (Float)(gameWidth) ) * ((Float)2.5))),gameHeight,true,0);
HXLINE( 198)			 ::openfl::geom::Matrix matrix =  ::openfl::geom::Matrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 199)			matrix->scale((( (Float)(gradient->width) ) / ( (Float)(source->width) )),(( (Float)(gradient->height) ) / ( (Float)(source->height) )));
HXLINE( 200)			gradient->draw(source,matrix,null(),null(),null(),true);
HXLINE( 203)			graphic = ::flixel::FlxG_obj::bitmap->add(gradient,false,key);
HXLINE( 204)			graphic->persist = true;
HXLINE( 205)			graphic->set_destroyOnNoUse(false);
            		}
HXLINE( 208)		return graphic;
            	}


HX_DEFINE_DYNAMIC_FUNC0(TransitionFade_obj,getGradient,return )

void TransitionFade_obj::finishTween( ::flixel::tweens::FlxTween f){
            	HX_STACKFRAME(&_hx_pos_85f0573c4a29b283_213_finishTween)
HXDLIN( 213)		this->delayThenFinish();
            	}


HX_DEFINE_DYNAMIC_FUNC1(TransitionFade_obj,finishTween,(void))

::String TransitionFade_obj::GRADIENT_PATH;


::hx::ObjectPtr< TransitionFade_obj > TransitionFade_obj::__new( ::flixel::addons::transition::TransitionData data) {
	::hx::ObjectPtr< TransitionFade_obj > __this = new TransitionFade_obj();
	__this->__construct(data);
	return __this;
}

::hx::ObjectPtr< TransitionFade_obj > TransitionFade_obj::__alloc(::hx::Ctx *_hx_ctx, ::flixel::addons::transition::TransitionData data) {
	TransitionFade_obj *__this = (TransitionFade_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(TransitionFade_obj), true, "flixel.addons.transition.TransitionFade"));
	*(void **)__this = TransitionFade_obj::_hx_vtable;
	__this->__construct(data);
	return __this;
}

TransitionFade_obj::TransitionFade_obj()
{
}

void TransitionFade_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TransitionFade);
	HX_MARK_MEMBER_NAME(back,"back");
	 ::flixel::addons::transition::TransitionEffect_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void TransitionFade_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(back,"back");
	 ::flixel::addons::transition::TransitionEffect_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val TransitionFade_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"back") ) { return ::hx::Val( back ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"start") ) { return ::hx::Val( start_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"makeSprite") ) { return ::hx::Val( makeSprite_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"getGradient") ) { return ::hx::Val( getGradient_dyn() ); }
		if (HX_FIELD_EQ(inName,"finishTween") ) { return ::hx::Val( finishTween_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"getBitmapKey") ) { return ::hx::Val( getBitmapKey_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"setTweenValues") ) { return ::hx::Val( setTweenValues_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val TransitionFade_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"back") ) { back=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TransitionFade_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("back",27,da,10,41));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo TransitionFade_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(TransitionFade_obj,back),HX_("back",27,da,10,41)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo TransitionFade_obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &TransitionFade_obj::GRADIENT_PATH,HX_("GRADIENT_PATH",94,f9,0c,ef)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String TransitionFade_obj_sMemberFields[] = {
	HX_("back",27,da,10,41),
	HX_("destroy",fa,2c,86,24),
	HX_("start",62,74,0b,84),
	HX_("setTweenValues",2b,80,ce,9b),
	HX_("getBitmapKey",7a,2d,31,d6),
	HX_("makeSprite",93,b0,65,15),
	HX_("getGradient",a6,fc,32,50),
	HX_("finishTween",18,cd,75,40),
	::String(null()) };

static void TransitionFade_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(TransitionFade_obj::GRADIENT_PATH,"GRADIENT_PATH");
};

#ifdef HXCPP_VISIT_ALLOCS
static void TransitionFade_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(TransitionFade_obj::GRADIENT_PATH,"GRADIENT_PATH");
};

#endif

::hx::Class TransitionFade_obj::__mClass;

static ::String TransitionFade_obj_sStaticFields[] = {
	HX_("GRADIENT_PATH",94,f9,0c,ef),
	::String(null())
};

void TransitionFade_obj::__register()
{
	TransitionFade_obj _hx_dummy;
	TransitionFade_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.addons.transition.TransitionFade",a1,63,fb,b1);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = TransitionFade_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(TransitionFade_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(TransitionFade_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< TransitionFade_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = TransitionFade_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TransitionFade_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TransitionFade_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void TransitionFade_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_85f0573c4a29b283_46_boot)
HXDLIN(  46)		GRADIENT_PATH = HX_("flixel/images/transitions/diagonal_gradient.png",20,34,41,22);
            	}
}

} // end namespace flixel
} // end namespace addons
} // end namespace transition
