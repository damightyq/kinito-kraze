// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxPieDial
#include <flixel/addons/display/FlxPieDial.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxPieDialShape
#include <flixel/addons/display/FlxPieDialShape.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_BitmapFrontEnd
#include <flixel/system/frontEnds/BitmapFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSpriteUtil
#include <flixel/util/FlxSpriteUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_f826267fb5a80b8c_17_new,"flixel.addons.display.FlxPieDial","new",0x33b66f11,"flixel.addons.display.FlxPieDial.new","flixel/addons/display/FlxPieDial.hx",17,0x0d52cabe)
HX_LOCAL_STACK_FRAME(_hx_pos_f826267fb5a80b8c_37_draw,"flixel.addons.display.FlxPieDial","draw",0x05586833,"flixel.addons.display.FlxPieDial.draw","flixel/addons/display/FlxPieDial.hx",37,0x0d52cabe)
HX_LOCAL_STACK_FRAME(_hx_pos_f826267fb5a80b8c_44_makePieDialGraphic,"flixel.addons.display.FlxPieDial","makePieDialGraphic",0xa43eeee9,"flixel.addons.display.FlxPieDial.makePieDialGraphic","flixel/addons/display/FlxPieDial.hx",44,0x0d52cabe)
HX_LOCAL_STACK_FRAME(_hx_pos_f826267fb5a80b8c_59_makePieDialGraphicSub,"flixel.addons.display.FlxPieDial","makePieDialGraphicSub",0x018bea17,"flixel.addons.display.FlxPieDial.makePieDialGraphicSub","flixel/addons/display/FlxPieDial.hx",59,0x0d52cabe)
HX_LOCAL_STACK_FRAME(_hx_pos_f826267fb5a80b8c_142_makeFullFrame,"flixel.addons.display.FlxPieDial","makeFullFrame",0xde0d3641,"flixel.addons.display.FlxPieDial.makeFullFrame","flixel/addons/display/FlxPieDial.hx",142,0x0d52cabe)
HX_LOCAL_STACK_FRAME(_hx_pos_f826267fb5a80b8c_188_drawSweep,"flixel.addons.display.FlxPieDial","drawSweep",0x369984b9,"flixel.addons.display.FlxPieDial.drawSweep","flixel/addons/display/FlxPieDial.hx",188,0x0d52cabe)
HX_LOCAL_STACK_FRAME(_hx_pos_f826267fb5a80b8c_272_set_amount,"flixel.addons.display.FlxPieDial","set_amount",0x54362984,"flixel.addons.display.FlxPieDial.set_amount","flixel/addons/display/FlxPieDial.hx",272,0x0d52cabe)
namespace flixel{
namespace addons{
namespace display{

void FlxPieDial_obj::__construct(Float X,Float Y,int Radius,::hx::Null< int >  __o_Color,::hx::Null< int >  __o_Frames, ::flixel::addons::display::FlxPieDialShape Shape,::hx::Null< bool >  __o_Clockwise,::hx::Null< int >  __o_InnerRadius){
            		int Color = __o_Color.Default(-1);
            		int Frames = __o_Frames.Default(36);
            		bool Clockwise = __o_Clockwise.Default(true);
            		int InnerRadius = __o_InnerRadius.Default(0);
            	HX_STACKFRAME(&_hx_pos_f826267fb5a80b8c_17_new)
HXLINE(  24)		this->pieFrames = 0;
HXLINE(  29)		if (::hx::IsNull( Shape )) {
HXLINE(  30)			Shape = ::flixel::addons::display::FlxPieDialShape_obj::CIRCLE_dyn();
            		}
HXLINE(  31)		super::__construct(X,Y,null());
HXLINE(  32)		this->makePieDialGraphic(Radius,Color,Frames,Shape,Clockwise,InnerRadius);
HXLINE(  33)		this->set_amount(((Float)1.0));
            	}

Dynamic FlxPieDial_obj::__CreateEmpty() { return new FlxPieDial_obj; }

void *FlxPieDial_obj::_hx_vtable = 0;

Dynamic FlxPieDial_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxPieDial_obj > _hx_result = new FlxPieDial_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7]);
	return _hx_result;
}

bool FlxPieDial_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x3b1105fd) {
		if (inClassId<=(int)0x2c01639b) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2c01639b;
		} else {
			return inClassId==(int)0x3b1105fd;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void FlxPieDial_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_f826267fb5a80b8c_37_draw)
HXLINE(  38)		if ((this->amount == 0)) {
HXLINE(  39)			return;
            		}
HXLINE(  40)		this->super::draw();
            	}


void FlxPieDial_obj::makePieDialGraphic(int Radius,int Color,int Frames, ::flixel::addons::display::FlxPieDialShape Shape,bool Clockwise,int InnerRadius){
            	HX_STACKFRAME(&_hx_pos_f826267fb5a80b8c_44_makePieDialGraphic)
HXLINE(  45)		this->pieFrames = Frames;
HXLINE(  46)		::String key = HX_("0x",48,2a,00,00);
HXDLIN(  46)		::String key1 = ::StringTools_obj::hex(((Color >> 24) & 255),2);
HXDLIN(  46)		::String key2 = ((key + key1) + ::StringTools_obj::hex(((Color >> 16) & 255),2));
HXDLIN(  46)		::String key3 = (key2 + ::StringTools_obj::hex(((Color >> 8) & 255),2));
HXDLIN(  46)		::String key4 = ((((((HX_("pie_dial_",3c,43,f1,fc) + (key3 + ::StringTools_obj::hex((Color & 255),2))) + HX_("_",5f,00,00,00)) + Radius) + HX_("_",5f,00,00,00)) + Frames) + HX_("_",5f,00,00,00));
HXDLIN(  46)		::String key5 = ((key4 + ::Std_obj::string(Shape)) + HX_("_",5f,00,00,00));
HXDLIN(  46)		::String key6 = (((key5 + ::Std_obj::string(Clockwise)) + HX_("_",5f,00,00,00)) + InnerRadius);
HXLINE(  47)		int W = (Radius * 2);
HXLINE(  48)		int H = (Radius * 2);
HXLINE(  49)		if (::hx::IsNull( ( ( ::flixel::graphics::FlxGraphic)(::flixel::FlxG_obj::bitmap->_cache->get(key6)) ) )) {
HXLINE(  51)			 ::openfl::display::BitmapData bmp = this->makePieDialGraphicSub(Radius,Color,Frames,Shape,Clockwise,InnerRadius);
HXLINE(  52)			::flixel::FlxG_obj::bitmap->add(bmp,true,key6);
            		}
HXLINE(  55)		this->loadGraphic(key6,true,W,H,null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC6(FlxPieDial_obj,makePieDialGraphic,(void))

 ::openfl::display::BitmapData FlxPieDial_obj::makePieDialGraphicSub(int Radius,int Color,int Frames, ::flixel::addons::display::FlxPieDialShape Shape,bool Clockwise,int InnerRadius){
            	HX_GC_STACKFRAME(&_hx_pos_f826267fb5a80b8c_59_makePieDialGraphicSub)
HXLINE(  60)		int W = (Radius * 2);
HXLINE(  61)		int H = (Radius * 2);
HXLINE(  63)		int rows = ::Math_obj::ceil(::Math_obj::sqrt(( (Float)(Frames) )));
HXLINE(  64)		int cols = ::Math_obj::ceil((( (Float)(Frames) ) / ( (Float)(rows) )));
HXLINE(  66)		int back;
HXDLIN(  66)		if (Clockwise) {
HXLINE(  66)			back = -16777216;
            		}
            		else {
HXLINE(  66)			back = -1;
            		}
HXLINE(  67)		int fore;
HXDLIN(  67)		if (Clockwise) {
HXLINE(  67)			fore = -1;
            		}
            		else {
HXLINE(  67)			fore = -16777216;
            		}
HXLINE(  69)		 ::flixel::FlxSprite fullFrame = this->makeFullFrame(Radius,Color,Frames,Shape,Clockwise,InnerRadius);
HXLINE(  70)		 ::flixel::FlxSprite nextFrame =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(W,H,back,false,null());
HXLINE(  72)		 ::openfl::display::BitmapData bmp =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,(W * cols),(H * rows),false,back);
HXLINE(  73)		int i = 0;
HXLINE(  74)		this->_flashPoint->setTo(( (Float)(0) ),( (Float)(0) ));
HXLINE(  75)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(0,-1);
HXDLIN(  75)		point->_inPool = false;
HXDLIN(  75)		 ::flixel::math::FlxBasePoint p = point;
HXLINE(  76)		Float degrees = (( (Float)(360) ) / ( (Float)(Frames) ));
HXLINE(  77)		if (!(Clockwise)) {
HXLINE(  79)			degrees = (degrees * ( (Float)(-1) ));
            		}
HXLINE(  82)		Float sweep;
HXDLIN(  82)		if (Clockwise) {
HXLINE(  82)			sweep = ( (Float)(0) );
            		}
            		else {
HXLINE(  82)			sweep = ( (Float)(360) );
            		}
HXLINE(  83)		 ::openfl::display::BitmapData bmp2 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,bmp->width,bmp->height,true,0);
HXLINE(  84)		 ::openfl::display::BitmapData fullBmp = fullFrame->get_pixels()->clone();
HXLINE(  86)		 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(  86)		point1->_inPool = false;
HXDLIN(  86)		 ::flixel::math::FlxBasePoint point2 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(  86)		point2->_inPool = false;
HXDLIN(  86)		 ::flixel::math::FlxBasePoint point3 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(  86)		point3->_inPool = false;
HXDLIN(  86)		 ::flixel::math::FlxBasePoint point4 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(  86)		point4->_inPool = false;
HXDLIN(  86)		 ::flixel::math::FlxBasePoint point5 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(  86)		point5->_inPool = false;
HXDLIN(  86)		::Array< ::Dynamic> polygon = ::Array_obj< ::Dynamic>::__new(5)->init(0,point1)->init(1,point2)->init(2,point3)->init(3,point4)->init(4,point5);
HXLINE(  87)		{
HXLINE(  87)			int _g = 0;
HXDLIN(  87)			int _g1 = rows;
HXDLIN(  87)			while((_g < _g1)){
HXLINE(  87)				_g = (_g + 1);
HXDLIN(  87)				int r = (_g - 1);
HXLINE(  89)				{
HXLINE(  89)					int _g2 = 0;
HXDLIN(  89)					int _g3 = cols;
HXDLIN(  89)					while((_g2 < _g3)){
HXLINE(  89)						_g2 = (_g2 + 1);
HXDLIN(  89)						int c = (_g2 - 1);
HXLINE(  91)						if ((i >= Frames)) {
HXLINE(  93)							goto _hx_goto_4;
            						}
HXLINE(  96)						this->_flashPoint->setTo(( (Float)((c * W)) ),( (Float)((r * H)) ));
HXLINE(  97)						bmp2->copyPixels(fullBmp,fullBmp->rect,this->_flashPoint,null(),null(),null());
HXLINE(  99)						if ((i <= 0)) {
HXLINE( 101)							bmp->fillRect(fullBmp->rect,-1);
            						}
            						else {
HXLINE( 105)							 ::openfl::display::BitmapData _hx_tmp = nextFrame->get_pixels();
HXDLIN( 105)							 ::openfl::display::BitmapData _hx_tmp1 = fullFrame->get_pixels();
HXDLIN( 105)							_hx_tmp->copyPixels(_hx_tmp1,fullFrame->get_pixels()->rect,this->_flashPointZero,null(),null(),null());
HXLINE( 106)							this->_flashPoint->setTo(( (Float)((c * W)) ),( (Float)((r * H)) ));
HXLINE( 107)							this->drawSweep(sweep,p,nextFrame,polygon,W,H,back,fore);
HXLINE( 108)							 ::openfl::display::BitmapData _hx_tmp2 = nextFrame->get_pixels();
HXDLIN( 108)							bmp->copyPixels(_hx_tmp2,nextFrame->get_pixels()->rect,this->_flashPoint,null(),null(),null());
            						}
HXLINE( 111)						sweep = (sweep + degrees);
HXLINE( 112)						{
HXLINE( 112)							Float rads = (degrees * (::Math_obj::PI / ( (Float)(180) )));
HXDLIN( 112)							Float s = ::Math_obj::sin(rads);
HXDLIN( 112)							Float c1 = ::Math_obj::cos(rads);
HXDLIN( 112)							Float tempX = p->x;
HXDLIN( 112)							p->set_x(((tempX * c1) - (p->y * s)));
HXDLIN( 112)							p->set_y(((tempX * s) + (p->y * c1)));
            						}
HXLINE( 114)						i = (i + 1);
            					}
            					_hx_goto_4:;
            				}
HXLINE( 117)				if ((i >= Frames)) {
HXLINE( 119)					goto _hx_goto_3;
            				}
            			}
            			_hx_goto_3:;
            		}
HXLINE( 123)		fullBmp->dispose();
HXLINE( 124)		fullFrame->destroy();
HXLINE( 125)		nextFrame->destroy();
HXLINE( 127)		 ::openfl::display::BitmapData shapeChannel =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,bmp->width,bmp->height,false,null());
HXLINE( 128)		shapeChannel->copyChannel(bmp2,bmp2->rect,this->_flashPointZero,8,1);
HXLINE( 129)		shapeChannel->copyChannel(bmp2,bmp2->rect,this->_flashPointZero,8,2);
HXLINE( 130)		shapeChannel->copyChannel(bmp2,bmp2->rect,this->_flashPointZero,8,4);
HXLINE( 132)		shapeChannel->draw(bmp,null(),null(),9,null(),true);
HXLINE( 133)		bmp2->copyChannel(shapeChannel,shapeChannel->rect,this->_flashPointZero,1,8);
HXLINE( 135)		shapeChannel->dispose();
HXLINE( 136)		bmp->dispose();
HXLINE( 138)		return bmp2;
            	}


HX_DEFINE_DYNAMIC_FUNC6(FlxPieDial_obj,makePieDialGraphicSub,return )

 ::flixel::FlxSprite FlxPieDial_obj::makeFullFrame(int Radius,int Color,int Frames, ::flixel::addons::display::FlxPieDialShape Shape,bool Clockwise,int InnerRadius){
            	HX_GC_STACKFRAME(&_hx_pos_f826267fb5a80b8c_142_makeFullFrame)
HXLINE( 143)		int W = (Radius * 2);
HXLINE( 144)		int H = (Radius * 2);
HXLINE( 146)		 ::flixel::FlxSprite fullFrame =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(W,H,0,true,null());
HXLINE( 147)		if ((InnerRadius > Radius)) {
HXLINE( 149)			InnerRadius = 0;
            		}
HXLINE( 152)		int dR = (Radius - InnerRadius);
HXLINE( 154)		if (::hx::IsPointerEq( Shape,::flixel::addons::display::FlxPieDialShape_obj::SQUARE_dyn() )) {
HXLINE( 156)			 ::openfl::display::BitmapData _hx_tmp = fullFrame->get_pixels();
HXDLIN( 156)			_hx_tmp->fillRect(fullFrame->get_pixels()->rect,Color);
HXLINE( 157)			if ((InnerRadius > 0)) {
HXLINE( 159)				this->_flashRect->setTo(( (Float)(dR) ),( (Float)(dR) ),( (Float)((InnerRadius * 2)) ),( (Float)((InnerRadius * 2)) ));
HXLINE( 160)				fullFrame->get_pixels()->fillRect(this->_flashRect,0);
            			}
            		}
            		else {
HXLINE( 163)			if (::hx::IsPointerEq( Shape,::flixel::addons::display::FlxPieDialShape_obj::CIRCLE_dyn() )) {
HXLINE( 165)				if ((InnerRadius > 0)) {
HXLINE( 167)					int alpha = fullFrame->get_pixels()->width;
HXDLIN( 167)					 ::openfl::display::BitmapData alpha1 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,alpha,fullFrame->get_pixels()->height,false,-16777216);
HXLINE( 168)					fullFrame->get_pixels()->fillRect(this->_flashRect,-16777216);
HXLINE( 169)					::flixel::util::FlxSpriteUtil_obj::drawCircle(fullFrame,-1,-1,Radius,-1,null(), ::Dynamic(::hx::Anon_obj::Create(1)
            						->setFixed(0,HX_("smoothing",74,d5,e1,95),true)));
HXLINE( 170)					::flixel::util::FlxSpriteUtil_obj::drawCircle(fullFrame,-1,-1,InnerRadius,-16777216,null(), ::Dynamic(::hx::Anon_obj::Create(1)
            						->setFixed(0,HX_("smoothing",74,d5,e1,95),true)));
HXLINE( 172)					 ::openfl::display::BitmapData _hx_tmp1 = fullFrame->get_pixels();
HXDLIN( 172)					alpha1->copyPixels(_hx_tmp1,fullFrame->get_pixels()->rect,this->_flashPointZero,null(),null(),true);
HXLINE( 174)					 ::openfl::display::BitmapData _hx_tmp2 = fullFrame->get_pixels();
HXDLIN( 174)					_hx_tmp2->fillRect(fullFrame->get_pixels()->rect,Color);
HXLINE( 175)					fullFrame->get_pixels()->copyChannel(alpha1,alpha1->rect,this->_flashPointZero,1,8);
HXLINE( 177)					alpha1->dispose();
            				}
            				else {
HXLINE( 181)					::flixel::util::FlxSpriteUtil_obj::drawCircle(fullFrame,-1,-1,Radius,Color,null(),null());
            				}
            			}
            		}
HXLINE( 184)		return fullFrame;
            	}


HX_DEFINE_DYNAMIC_FUNC6(FlxPieDial_obj,makeFullFrame,return )

void FlxPieDial_obj::drawSweep(Float sweep, ::flixel::math::FlxBasePoint p, ::flixel::FlxSprite nextFrame,::Array< ::Dynamic> polygon,int W,int H,int back,int fore){
            	HX_STACKFRAME(&_hx_pos_f826267fb5a80b8c_188_drawSweep)
HXLINE( 189)		Float halfW = (( (Float)(W) ) / ( (Float)(2) ));
HXLINE( 190)		Float halfH = (( (Float)(H) ) / ( (Float)(2) ));
HXLINE( 192)		 ::openfl::display::BitmapData _hx_tmp = nextFrame->get_pixels();
HXDLIN( 192)		_hx_tmp->fillRect(nextFrame->get_pixels()->rect,back);
HXLINE( 193)		{
HXLINE( 193)			 ::flixel::math::FlxBasePoint this1 = polygon->__get(0).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 193)			this1->set_x(halfW);
HXDLIN( 193)			this1->set_y(halfH);
            		}
HXLINE( 195)		if ((sweep < 45)) {
HXLINE( 197)			{
HXLINE( 197)				 ::flixel::math::FlxBasePoint this2 = polygon->__get(1).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 197)				this2->set_x(halfW);
HXDLIN( 197)				this2->set_y(( (Float)(0) ));
            			}
HXLINE( 198)			{
HXLINE( 198)				 ::flixel::math::FlxBasePoint this3 = polygon->__get(2).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 198)				Float y = (halfH + (( (Float)(H) ) * p->y));
HXDLIN( 198)				this3->set_x((halfW + (( (Float)(W) ) * p->x)));
HXDLIN( 198)				this3->set_y(y);
            			}
HXLINE( 199)			{
HXLINE( 199)				 ::flixel::math::FlxBasePoint this4 = polygon->__get(3).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 199)				this4->set_x(halfW);
HXDLIN( 199)				this4->set_y(halfH);
            			}
            		}
            		else {
HXLINE( 201)			if ((sweep < 90)) {
HXLINE( 203)				{
HXLINE( 203)					 ::flixel::math::FlxBasePoint this5 = polygon->__get(1).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 203)					this5->set_x(halfW);
HXDLIN( 203)					this5->set_y(( (Float)(0) ));
            				}
HXLINE( 204)				{
HXLINE( 204)					 ::flixel::math::FlxBasePoint this6 = polygon->__get(2).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 204)					this6->set_x(( (Float)(W) ));
HXDLIN( 204)					this6->set_y(( (Float)(0) ));
            				}
HXLINE( 205)				{
HXLINE( 205)					 ::flixel::math::FlxBasePoint this7 = polygon->__get(3).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 205)					Float y1 = (halfH + (( (Float)(H) ) * p->y));
HXDLIN( 205)					this7->set_x((halfW + (( (Float)(W) ) * p->x)));
HXDLIN( 205)					this7->set_y(y1);
            				}
            			}
            			else {
HXLINE( 207)				if ((sweep < 135)) {
HXLINE( 209)					this->_flashRect->setTo(halfW,( (Float)(0) ),halfW,halfH);
HXLINE( 210)					nextFrame->get_pixels()->fillRect(this->_flashRect,fore);
HXLINE( 212)					{
HXLINE( 212)						 ::flixel::math::FlxBasePoint this8 = polygon->__get(1).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 212)						this8->set_x(( (Float)(W) ));
HXDLIN( 212)						this8->set_y(halfH);
            					}
HXLINE( 213)					{
HXLINE( 213)						 ::flixel::math::FlxBasePoint this9 = polygon->__get(2).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 213)						Float y2 = (halfH + (( (Float)(H) ) * p->y));
HXDLIN( 213)						this9->set_x((halfW + (( (Float)(W) ) * p->x)));
HXDLIN( 213)						this9->set_y(y2);
            					}
HXLINE( 214)					{
HXLINE( 214)						 ::flixel::math::FlxBasePoint this10 = polygon->__get(3).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 214)						this10->set_x(halfW);
HXDLIN( 214)						this10->set_y(halfH);
            					}
            				}
            				else {
HXLINE( 216)					if ((sweep < 180)) {
HXLINE( 218)						this->_flashRect->setTo(halfW,( (Float)(0) ),halfW,halfH);
HXLINE( 219)						nextFrame->get_pixels()->fillRect(this->_flashRect,fore);
HXLINE( 221)						{
HXLINE( 221)							 ::flixel::math::FlxBasePoint this11 = polygon->__get(1).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 221)							this11->set_x(( (Float)(W) ));
HXDLIN( 221)							this11->set_y(halfH);
            						}
HXLINE( 222)						{
HXLINE( 222)							 ::flixel::math::FlxBasePoint this12 = polygon->__get(2).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 222)							this12->set_x(( (Float)(W) ));
HXDLIN( 222)							this12->set_y(( (Float)(H) ));
            						}
HXLINE( 223)						{
HXLINE( 223)							 ::flixel::math::FlxBasePoint this13 = polygon->__get(3).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 223)							Float y3 = (halfH + (( (Float)(H) ) * p->y));
HXDLIN( 223)							this13->set_x((halfW + (( (Float)(W) ) * p->x)));
HXDLIN( 223)							this13->set_y(y3);
            						}
            					}
            					else {
HXLINE( 225)						if ((sweep < 225)) {
HXLINE( 227)							this->_flashRect->setTo(halfW,( (Float)(0) ),halfW,( (Float)(H) ));
HXLINE( 228)							nextFrame->get_pixels()->fillRect(this->_flashRect,fore);
HXLINE( 230)							{
HXLINE( 230)								 ::flixel::math::FlxBasePoint this14 = polygon->__get(1).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 230)								this14->set_x(halfW);
HXDLIN( 230)								this14->set_y(( (Float)(H) ));
            							}
HXLINE( 231)							{
HXLINE( 231)								 ::flixel::math::FlxBasePoint this15 = polygon->__get(2).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 231)								Float y4 = (halfH + (( (Float)(H) ) * p->y));
HXDLIN( 231)								this15->set_x((halfW + (( (Float)(W) ) * p->x)));
HXDLIN( 231)								this15->set_y(y4);
            							}
HXLINE( 232)							{
HXLINE( 232)								 ::flixel::math::FlxBasePoint this16 = polygon->__get(3).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 232)								this16->set_x(halfW);
HXDLIN( 232)								this16->set_y(halfH);
            							}
            						}
            						else {
HXLINE( 234)							if ((sweep < 270)) {
HXLINE( 236)								this->_flashRect->setTo(halfW,( (Float)(0) ),halfW,( (Float)(H) ));
HXLINE( 237)								nextFrame->get_pixels()->fillRect(this->_flashRect,fore);
HXLINE( 239)								{
HXLINE( 239)									 ::flixel::math::FlxBasePoint this17 = polygon->__get(1).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 239)									this17->set_x(halfW);
HXDLIN( 239)									this17->set_y(( (Float)(H) ));
            								}
HXLINE( 240)								{
HXLINE( 240)									 ::flixel::math::FlxBasePoint this18 = polygon->__get(2).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 240)									this18->set_x(( (Float)(0) ));
HXDLIN( 240)									this18->set_y(( (Float)(H) ));
            								}
HXLINE( 241)								{
HXLINE( 241)									 ::flixel::math::FlxBasePoint this19 = polygon->__get(3).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 241)									Float y5 = (halfH + (( (Float)(H) ) * p->y));
HXDLIN( 241)									this19->set_x((halfW + (( (Float)(W) ) * p->x)));
HXDLIN( 241)									this19->set_y(y5);
            								}
            							}
            							else {
HXLINE( 243)								if ((sweep < 315)) {
HXLINE( 245)									this->_flashRect->setTo(halfW,( (Float)(0) ),halfW,( (Float)(H) ));
HXLINE( 246)									nextFrame->get_pixels()->fillRect(this->_flashRect,fore);
HXLINE( 247)									this->_flashRect->setTo(( (Float)(0) ),halfH,halfW,halfH);
HXLINE( 248)									nextFrame->get_pixels()->fillRect(this->_flashRect,fore);
HXLINE( 250)									{
HXLINE( 250)										 ::flixel::math::FlxBasePoint this20 = polygon->__get(1).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 250)										this20->set_x(( (Float)(0) ));
HXDLIN( 250)										this20->set_y(halfH);
            									}
HXLINE( 251)									{
HXLINE( 251)										 ::flixel::math::FlxBasePoint this21 = polygon->__get(2).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 251)										Float y6 = (halfH + (( (Float)(H) ) * p->y));
HXDLIN( 251)										this21->set_x((halfW + (( (Float)(W) ) * p->x)));
HXDLIN( 251)										this21->set_y(y6);
            									}
HXLINE( 252)									{
HXLINE( 252)										 ::flixel::math::FlxBasePoint this22 = polygon->__get(3).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 252)										this22->set_x(halfW);
HXDLIN( 252)										this22->set_y(halfH);
            									}
            								}
            								else {
HXLINE( 254)									if ((sweep < 360)) {
HXLINE( 256)										this->_flashRect->setTo(halfW,( (Float)(0) ),halfW,( (Float)(H) ));
HXLINE( 257)										nextFrame->get_pixels()->fillRect(this->_flashRect,fore);
HXLINE( 258)										this->_flashRect->setTo(( (Float)(0) ),halfH,halfW,halfH);
HXLINE( 259)										nextFrame->get_pixels()->fillRect(this->_flashRect,fore);
HXLINE( 261)										{
HXLINE( 261)											 ::flixel::math::FlxBasePoint this23 = polygon->__get(1).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 261)											this23->set_x(( (Float)(0) ));
HXDLIN( 261)											this23->set_y(halfH);
            										}
HXLINE( 262)										{
HXLINE( 262)											 ::flixel::math::FlxBasePoint this24 = polygon->__get(2).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 262)											this24->set_x(( (Float)(0) ));
HXDLIN( 262)											this24->set_y(( (Float)(0) ));
            										}
HXLINE( 263)										{
HXLINE( 263)											 ::flixel::math::FlxBasePoint this25 = polygon->__get(3).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 263)											Float y7 = (halfH + (( (Float)(H) ) * p->y));
HXDLIN( 263)											this25->set_x((halfW + (( (Float)(W) ) * p->x)));
HXDLIN( 263)											this25->set_y(y7);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 266)		{
HXLINE( 266)			 ::flixel::math::FlxBasePoint this26 = polygon->__get(4).StaticCast<  ::flixel::math::FlxBasePoint >();
HXDLIN( 266)			this26->set_x(halfW);
HXDLIN( 266)			this26->set_y(halfH);
            		}
HXLINE( 268)		::flixel::util::FlxSpriteUtil_obj::drawPolygon(nextFrame,polygon,fore,null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC8(FlxPieDial_obj,drawSweep,(void))

Float FlxPieDial_obj::set_amount(Float f){
            	HX_STACKFRAME(&_hx_pos_f826267fb5a80b8c_272_set_amount)
HXLINE( 273)		Float lowerBound;
HXDLIN( 273)		if ((f < ((Float)0.0))) {
HXLINE( 273)			lowerBound = ((Float)0.0);
            		}
            		else {
HXLINE( 273)			lowerBound = f;
            		}
HXDLIN( 273)		Float _hx_tmp;
HXDLIN( 273)		if ((lowerBound > ((Float)1.0))) {
HXLINE( 273)			_hx_tmp = ((Float)1.0);
            		}
            		else {
HXLINE( 273)			_hx_tmp = lowerBound;
            		}
HXDLIN( 273)		this->amount = _hx_tmp;
HXLINE( 274)		int frame = ::Std_obj::_hx_int((f * ( (Float)(this->pieFrames) )));
HXLINE( 275)		this->animation->set_frameIndex(frame);
HXLINE( 276)		if ((this->amount == ((Float)1.0))) {
HXLINE( 278)			this->animation->set_frameIndex(0);
            		}
HXLINE( 280)		return this->amount;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxPieDial_obj,set_amount,return )


::hx::ObjectPtr< FlxPieDial_obj > FlxPieDial_obj::__new(Float X,Float Y,int Radius,::hx::Null< int >  __o_Color,::hx::Null< int >  __o_Frames, ::flixel::addons::display::FlxPieDialShape Shape,::hx::Null< bool >  __o_Clockwise,::hx::Null< int >  __o_InnerRadius) {
	::hx::ObjectPtr< FlxPieDial_obj > __this = new FlxPieDial_obj();
	__this->__construct(X,Y,Radius,__o_Color,__o_Frames,Shape,__o_Clockwise,__o_InnerRadius);
	return __this;
}

::hx::ObjectPtr< FlxPieDial_obj > FlxPieDial_obj::__alloc(::hx::Ctx *_hx_ctx,Float X,Float Y,int Radius,::hx::Null< int >  __o_Color,::hx::Null< int >  __o_Frames, ::flixel::addons::display::FlxPieDialShape Shape,::hx::Null< bool >  __o_Clockwise,::hx::Null< int >  __o_InnerRadius) {
	FlxPieDial_obj *__this = (FlxPieDial_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxPieDial_obj), true, "flixel.addons.display.FlxPieDial"));
	*(void **)__this = FlxPieDial_obj::_hx_vtable;
	__this->__construct(X,Y,Radius,__o_Color,__o_Frames,Shape,__o_Clockwise,__o_InnerRadius);
	return __this;
}

FlxPieDial_obj::FlxPieDial_obj()
{
}

::hx::Val FlxPieDial_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"amount") ) { return ::hx::Val( amount ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"pieFrames") ) { return ::hx::Val( pieFrames ); }
		if (HX_FIELD_EQ(inName,"drawSweep") ) { return ::hx::Val( drawSweep_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"set_amount") ) { return ::hx::Val( set_amount_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"makeFullFrame") ) { return ::hx::Val( makeFullFrame_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"makePieDialGraphic") ) { return ::hx::Val( makePieDialGraphic_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"makePieDialGraphicSub") ) { return ::hx::Val( makePieDialGraphicSub_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val FlxPieDial_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"amount") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_amount(inValue.Cast< Float >()) );amount=inValue.Cast< Float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"pieFrames") ) { pieFrames=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxPieDial_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("amount",d8,11,03,d5));
	outFields->push(HX_("pieFrames",12,bd,60,08));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxPieDial_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(FlxPieDial_obj,amount),HX_("amount",d8,11,03,d5)},
	{::hx::fsInt,(int)offsetof(FlxPieDial_obj,pieFrames),HX_("pieFrames",12,bd,60,08)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *FlxPieDial_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxPieDial_obj_sMemberFields[] = {
	HX_("amount",d8,11,03,d5),
	HX_("pieFrames",12,bd,60,08),
	HX_("draw",04,2c,70,42),
	HX_("makePieDialGraphic",7a,5e,b3,47),
	HX_("makePieDialGraphicSub",26,cb,1e,bd),
	HX_("makeFullFrame",50,f0,30,7c),
	HX_("drawSweep",48,4b,15,4e),
	HX_("set_amount",15,20,08,c9),
	::String(null()) };

::hx::Class FlxPieDial_obj::__mClass;

void FlxPieDial_obj::__register()
{
	FlxPieDial_obj _hx_dummy;
	FlxPieDial_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.addons.display.FlxPieDial",9f,92,13,02);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxPieDial_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxPieDial_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxPieDial_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxPieDial_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace addons
} // end namespace display
