// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_ClientPrefs
#include <backend/ClientPrefs.h>
#endif
#ifndef INCLUDED_backend_Controls
#include <backend/Controls.h>
#endif
#ifndef INCLUDED_backend_Language
#include <backend/Language.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_SaveVariables
#include <backend/SaveVariables.h>
#endif
#ifndef INCLUDED_cutscenes_DialogueBoxPsych
#include <cutscenes/DialogueBoxPsych.h>
#endif
#ifndef INCLUDED_cutscenes_DialogueCharacter
#include <cutscenes/DialogueCharacter.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSoundGroup
#include <flixel/sound/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_NumTween
#include <flixel/tweens/misc/NumTween.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif
#ifndef INCLUDED_objects_Alphabet
#include <objects/Alphabet.h>
#endif
#ifndef INCLUDED_objects_TypedAlphabet
#include <objects/TypedAlphabet.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_media_Sound
#include <openfl/media/Sound.h>
#endif
#ifndef INCLUDED_openfl_media_SoundChannel
#include <openfl/media/SoundChannel.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_abed4712cfea8e8f_23_new,"cutscenes.DialogueBoxPsych","new",0xe85fdd5f,"cutscenes.DialogueBoxPsych.new","cutscenes/DialogueBoxPsych.hx",23,0xd915d790)
static const ::String _hx_array_data_ebf841ed_2[] = {
	HX_("normal",27,72,69,30),HX_("angry",21,49,e2,22),
};
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_110_spawnCharacters,"cutscenes.DialogueBoxPsych","spawnCharacters",0x0d854244,"cutscenes.DialogueBoxPsych.spawnCharacters","cutscenes/DialogueBoxPsych.hx",110,0xd915d790)
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_158_update,"cutscenes.DialogueBoxPsych","update",0xc596626a,"cutscenes.DialogueBoxPsych.update","cutscenes/DialogueBoxPsych.hx",158,0xd915d790)
static const ::String _hx_array_data_ebf841ed_18[] = {
	HX_("",00,00,00,00),HX_("center-",b8,f4,e5,19),
};
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_201_update,"cutscenes.DialogueBoxPsych","update",0xc596626a,"cutscenes.DialogueBoxPsych.update","cutscenes/DialogueBoxPsych.hx",201,0xd915d790)
static const ::String _hx_array_data_ebf841ed_20[] = {
	HX_("",00,00,00,00),HX_("center-",b8,f4,e5,19),
};
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_320_startNextDialog,"cutscenes.DialogueBoxPsych","startNextDialog",0xe54a4c9c,"cutscenes.DialogueBoxPsych.startNextDialog","cutscenes/DialogueBoxPsych.hx",320,0xd915d790)
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_388_parseDialogue,"cutscenes.DialogueBoxPsych","parseDialogue",0xa663462a,"cutscenes.DialogueBoxPsych.parseDialogue","cutscenes/DialogueBoxPsych.hx",388,0xd915d790)
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_396_dummy,"cutscenes.DialogueBoxPsych","dummy",0xeea398e7,"cutscenes.DialogueBoxPsych.dummy","cutscenes/DialogueBoxPsych.hx",396,0xd915d790)
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_407_updateBoxOffsets,"cutscenes.DialogueBoxPsych","updateBoxOffsets",0xdc7869bf,"cutscenes.DialogueBoxPsych.updateBoxOffsets","cutscenes/DialogueBoxPsych.hx",407,0xd915d790)
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_25_boot,"cutscenes.DialogueBoxPsych","boot",0x639ad653,"cutscenes.DialogueBoxPsych.boot","cutscenes/DialogueBoxPsych.hx",25,0xd915d790)
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_26_boot,"cutscenes.DialogueBoxPsych","boot",0x639ad653,"cutscenes.DialogueBoxPsych.boot","cutscenes/DialogueBoxPsych.hx",26,0xd915d790)
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_27_boot,"cutscenes.DialogueBoxPsych","boot",0x639ad653,"cutscenes.DialogueBoxPsych.boot","cutscenes/DialogueBoxPsych.hx",27,0xd915d790)
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_106_boot,"cutscenes.DialogueBoxPsych","boot",0x639ad653,"cutscenes.DialogueBoxPsych.boot","cutscenes/DialogueBoxPsych.hx",106,0xd915d790)
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_107_boot,"cutscenes.DialogueBoxPsych","boot",0x639ad653,"cutscenes.DialogueBoxPsych.boot","cutscenes/DialogueBoxPsych.hx",107,0xd915d790)
HX_LOCAL_STACK_FRAME(_hx_pos_abed4712cfea8e8f_108_boot,"cutscenes.DialogueBoxPsych","boot",0x639ad653,"cutscenes.DialogueBoxPsych.boot","cutscenes/DialogueBoxPsych.hx",108,0xd915d790)
namespace cutscenes{

void DialogueBoxPsych_obj::__construct( ::Dynamic dialogueList,::String song){
            	HX_GC_STACKFRAME(&_hx_pos_abed4712cfea8e8f_23_new)
HXLINE( 318)		this->lastBoxType = HX_("",00,00,00,00);
HXLINE( 317)		this->lastCharacter = -1;
HXLINE( 156)		this->closeVolume = ((Float)1);
HXLINE( 155)		this->closeSound = HX_("dialogueClose",80,e3,49,e3);
HXLINE( 153)		this->ignoreThisFrame = true;
HXLINE( 152)		this->daText = null();
HXLINE( 104)		this->dialogueEnded = false;
HXLINE( 103)		this->dialogueStarted = false;
HXLINE(  48)		this->curCharacter = HX_("",00,00,00,00);
HXLINE(  46)		this->textBoxTypes = ::Array_obj< ::String >::fromData( _hx_array_data_ebf841ed_2,2);
HXLINE(  43)		this->offsetPos = ((Float)-600);
HXLINE(  42)		this->currentText = 0;
HXLINE(  40)		this->arrayCharacters = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  38)		this->textToType = HX_("",00,00,00,00);
HXLINE(  36)		this->bgFade = null();
HXLINE(  35)		this->skipDialogueThing = null();
HXLINE(  34)		this->nextDialogueThing = null();
HXLINE(  31)		this->dialogueList = null();
HXLINE(  28)		this->scrollSpeed = 4000;
HXLINE(  53)		super::__construct(null(),null(),null());
HXLINE(  56)		::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("dialogue",18,2d,94,a7)),null(),true,null());
HXLINE(  57)		::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("dialogueClose",80,e3,49,e3)),null(),true,null());
HXLINE(  59)		bool _hx_tmp;
HXDLIN(  59)		if (::hx::IsNotNull( song )) {
HXLINE(  59)			_hx_tmp = (song != HX_("",00,00,00,00));
            		}
            		else {
HXLINE(  59)			_hx_tmp = false;
            		}
HXDLIN(  59)		if (_hx_tmp) {
HXLINE(  60)			 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN(  60)			_hx_tmp1->playMusic(::backend::Paths_obj::returnSound((HX_("music/",ea,bf,1b,3f) + song),null(),true,null()),0,null(),null());
HXLINE(  61)			{
HXLINE(  61)				 ::flixel::sound::FlxSound _this = ::flixel::FlxG_obj::sound->music;
HXDLIN(  61)				 ::Dynamic onComplete = null();
HXDLIN(  61)				if (::hx::IsNull( _this->_channel )) {
HXLINE(  61)					_this->play(null(),null(),null());
            				}
HXDLIN(  61)				if (::hx::IsNotNull( _this->fadeTween )) {
HXLINE(  61)					_this->fadeTween->cancel();
            				}
HXDLIN(  61)				_this->fadeTween = ::flixel::tweens::FlxTween_obj::num(( (Float)(0) ),( (Float)(1) ),2, ::Dynamic(::hx::Anon_obj::Create(1)
            					->setFixed(0,HX_("onComplete",f8,d4,7e,5d),onComplete)),_this->volumeTween_dyn());
            			}
            		}
HXLINE(  64)		 ::flixel::FlxSprite _hx_tmp2 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,-500,-500,null());
HXDLIN(  64)		this->bgFade = _hx_tmp2->makeGraphic((::flixel::FlxG_obj::width * 2),(::flixel::FlxG_obj::height * 2),-1,null(),null());
HXLINE(  65)		{
HXLINE(  65)			 ::flixel::math::FlxBasePoint this1 = this->bgFade->scrollFactor;
HXDLIN(  65)			this1->set_x(( (Float)(0) ));
HXDLIN(  65)			this1->set_y(( (Float)(0) ));
            		}
HXLINE(  66)		this->bgFade->set_visible(true);
HXLINE(  67)		this->bgFade->set_alpha(( (Float)(0) ));
HXLINE(  68)		this->add(this->bgFade);
HXLINE(  70)		this->dialogueList = dialogueList;
HXLINE(  71)		this->spawnCharacters();
HXLINE(  73)		this->box =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,70,370,null());
HXLINE(  74)		this->box->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE(  75)		 ::flixel::FlxSprite _hx_tmp3 = this->box;
HXDLIN(  75)		::String parentFolder = null();
HXDLIN(  75)		if ((HX_("speech_bubble",49,db,97,da).indexOf(HX_("psychic",d5,09,aa,19),null()) != -1)) {
HXLINE(  75)			::haxe::Log_obj::trace(HX_("speech_bubble",49,db,97,da), ::Dynamic(::hx::Anon_obj::Create(5)
            				->setFixed(0,HX_("className",a3,92,3d,dc),HX_("backend.Paths",34,17,99,92))
            				->setFixed(1,HX_("customParams",d7,51,18,ed),::cpp::VirtualArray_obj::__new(2)->init(0,parentFolder)->init(1,true))
            				->setFixed(2,HX_("methodName",cc,19,0f,12),HX_("getSparrowAtlas",55,ab,b7,a7))
            				->setFixed(3,HX_("fileName",e7,5a,43,62),HX_("source/backend/Paths.hx",ff,43,8c,3d))
            				->setFixed(4,HX_("lineNumber",dd,81,22,76),372)));
            		}
HXDLIN(  75)		 ::flixel::graphics::FlxGraphic imageLoaded = ::backend::Paths_obj::image(HX_("speech_bubble",49,db,97,da),parentFolder,true);
HXDLIN(  75)		bool xmlExists = false;
HXDLIN(  75)		::String xml = ::backend::Paths_obj::modFolders(((HX_("images/",77,50,74,c1) + HX_("speech_bubble",49,db,97,da)) + HX_(".xml",69,3e,c3,1e)));
HXDLIN(  75)		if (::sys::FileSystem_obj::exists(xml)) {
HXLINE( 378)			xmlExists = true;
            		}
HXLINE(  75)		 ::Dynamic _hx_tmp4;
HXDLIN(  75)		if (xmlExists) {
HXLINE(  75)			_hx_tmp4 = ::sys::io::File_obj::getContent(xml);
            		}
            		else {
HXLINE(  75)			::String key = (HX_("images/",77,50,74,c1) + HX_("speech_bubble",49,db,97,da));
HXDLIN(  75)			::Dynamic this2 = ::backend::Language_obj::phrases;
HXDLIN(  75)			::String str = ( ( ::haxe::ds::StringMap)(this2) )->get_string(::StringTools_obj::trim(key).toLowerCase());
HXDLIN(  75)			if (::hx::IsNotNull( str )) {
HXLINE(  82)				key = str;
            			}
HXLINE(  75)			_hx_tmp4 = ::backend::Paths_obj::getPath((key + HX_(".xml",69,3e,c3,1e)),HX_("TEXT",ad,94,ba,37),parentFolder,null());
            		}
HXDLIN(  75)		_hx_tmp3->set_frames(::flixel::graphics::frames::FlxAtlasFrames_obj::fromSparrow(imageLoaded,_hx_tmp4));
HXLINE(  76)		{
HXLINE(  76)			 ::flixel::math::FlxBasePoint this3 = this->box->scrollFactor;
HXDLIN(  76)			this3->set_x(( (Float)(0) ));
HXDLIN(  76)			this3->set_y(( (Float)(0) ));
            		}
HXLINE(  77)		this->box->animation->addByPrefix(HX_("normal",27,72,69,30),HX_("speech bubble normal",bd,d5,bc,a7),24,null(),null(),null());
HXLINE(  78)		this->box->animation->addByPrefix(HX_("normalOpen",91,41,38,70),HX_("Speech Bubble Normal Open",0d,59,3f,7c),24,false,null(),null());
HXLINE(  79)		this->box->animation->addByPrefix(HX_("angry",21,49,e2,22),HX_("AHH speech bubble",eb,de,b2,20),24,null(),null(),null());
HXLINE(  80)		this->box->animation->addByPrefix(HX_("angryOpen",8b,1d,01,b1),HX_("speech bubble loud open",42,35,10,f0),24,false,null(),null());
HXLINE(  81)		this->box->animation->addByPrefix(HX_("center-normal",df,c0,ab,9c),HX_("speech bubble middle",eb,36,b2,c3),24,null(),null(),null());
HXLINE(  82)		this->box->animation->addByPrefix(HX_("center-normalOpen",49,4c,74,58),HX_("Speech Bubble Middle Open",1f,f1,94,ea),24,false,null(),null());
HXLINE(  83)		this->box->animation->addByPrefix(HX_("center-angry",69,39,92,b0),HX_("AHH Speech Bubble middle",ea,0b,3d,74),24,null(),null(),null());
HXLINE(  84)		this->box->animation->addByPrefix(HX_("center-angryOpen",d3,d1,42,e2),HX_("speech bubble Middle loud open",c3,b9,85,ee),24,false,null(),null());
HXLINE(  85)		this->box->animation->play(HX_("normal",27,72,69,30),true,null(),null());
HXLINE(  86)		this->box->set_visible(false);
HXLINE(  87)		 ::flixel::FlxSprite _hx_tmp5 = this->box;
HXDLIN(  87)		_hx_tmp5->setGraphicSize(::Std_obj::_hx_int((this->box->get_width() * ((Float)0.9))),null());
HXLINE(  88)		this->box->updateHitbox();
HXLINE(  89)		this->add(this->box);
HXLINE(  91)		this->daText =  ::objects::TypedAlphabet_obj::__alloc( HX_CTX ,( (Float)(::cutscenes::DialogueBoxPsych_obj::DEFAULT_TEXT_X) ),( (Float)(::cutscenes::DialogueBoxPsych_obj::DEFAULT_TEXT_Y) ),HX_("",00,00,00,00),null(),null());
HXLINE(  92)		this->daText->setScale(((Float)0.7),null());
HXLINE(  93)		this->add(this->daText);
HXLINE(  95)		int _hx_tmp6 = (::flixel::FlxG_obj::width - 320);
HXDLIN(  95)		int _hx_tmp7 = (::flixel::FlxG_obj::height - 30);
HXDLIN(  95)		::cpp::VirtualArray values = null();
HXDLIN(  95)		::Dynamic this4 = ::backend::Language_obj::phrases;
HXDLIN(  95)		 ::EReg hideChars =  ::EReg_obj::__alloc( HX_CTX ,HX_("[~&\\\\/;:<>#.,'\"%?!]",85,3f,6d,6d),HX_("g",67,00,00,00));
HXDLIN(  95)		::String str1 = ( ( ::haxe::ds::StringMap)(this4) )->get_string(::StringTools_obj::trim(hideChars->replace(::StringTools_obj::replace(HX_("dialogue_skip",46,8e,1f,07),HX_(" ",20,00,00,00),HX_("_",5f,00,00,00)),HX_("",00,00,00,00)).toLowerCase()));
HXDLIN(  95)		if (::hx::IsNull( str1 )) {
HXLINE(  62)			str1 = HX_("Press BACK to Skip",48,df,73,8e);
            		}
HXLINE(  95)		if (::hx::IsNull( str1 )) {
HXLINE(  68)			str1 = HX_("dialogue_skip",46,8e,1f,07);
            		}
HXLINE(  95)		if (::hx::IsNotNull( values )) {
HXLINE(  95)			int _g_current = 0;
HXDLIN(  95)			::cpp::VirtualArray _g_array = values;
HXDLIN(  95)			while((_g_current < _g_array->get_length())){
HXLINE(  95)				 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN(  95)				_g_current = (_g_current + 1);
HXDLIN(  95)				int _g_key = (_g_current - 1);
HXDLIN(  95)				int num = _g_key;
HXDLIN(  95)				 ::Dynamic value = _g_value;
HXLINE(  72)				str1 = ::StringTools_obj::replace(str1,((HX_("{",7b,00,00,00) + (num + 1)) + HX_("}",7d,00,00,00)),( (::String)(value) ));
            			}
            		}
HXLINE(  95)		this->skipText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,_hx_tmp6,_hx_tmp7,300,str1,16,null());
HXLINE(  96)		this->skipText->setFormat(null(),16,-1,HX_("right",dc,0b,64,e9),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn(),-16777216,null());
HXLINE(  97)		this->skipText->set_borderSize(( (Float)(2) ));
HXLINE(  98)		this->add(this->skipText);
HXLINE( 100)		this->startNextDialog();
            	}

Dynamic DialogueBoxPsych_obj::__CreateEmpty() { return new DialogueBoxPsych_obj; }

void *DialogueBoxPsych_obj::_hx_vtable = 0;

Dynamic DialogueBoxPsych_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< DialogueBoxPsych_obj > _hx_result = new DialogueBoxPsych_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool DialogueBoxPsych_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x35dbe371) {
		if (inClassId<=(int)0x2c01639b) {
			if (inClassId<=(int)0x288ce903) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x288ce903;
			} else {
				return inClassId==(int)0x2c01639b;
			}
		} else {
			return inClassId==(int)0x35dbe371;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void DialogueBoxPsych_obj::spawnCharacters(){
            	HX_GC_STACKFRAME(&_hx_pos_abed4712cfea8e8f_110_spawnCharacters)
HXLINE( 111)		 ::haxe::ds::StringMap charsMap =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE( 112)		{
HXLINE( 112)			int _g = 0;
HXDLIN( 112)			int _g1 = ( (::Array< ::Dynamic>)(this->dialogueList->__Field(HX_("dialogue",18,2d,94,a7),::hx::paccDynamic)) )->length;
HXDLIN( 112)			while((_g < _g1)){
HXLINE( 112)				_g = (_g + 1);
HXDLIN( 112)				int i = (_g - 1);
HXLINE( 113)				if (::hx::IsNotNull(  ::Dynamic(this->dialogueList->__Field(HX_("dialogue",18,2d,94,a7),::hx::paccDynamic))->__GetItem(i) )) {
HXLINE( 114)					::String charToAdd = ( (::String)( ::Dynamic(this->dialogueList->__Field(HX_("dialogue",18,2d,94,a7),::hx::paccDynamic))->__GetItem(i)->__Field(HX_("portrait",5b,21,af,b8),::hx::paccDynamic)) );
HXLINE( 115)					bool _hx_tmp;
HXDLIN( 115)					if (charsMap->exists(charToAdd)) {
HXLINE( 115)						_hx_tmp = !(( (bool)(charsMap->get(charToAdd)) ));
            					}
            					else {
HXLINE( 115)						_hx_tmp = true;
            					}
HXDLIN( 115)					if (_hx_tmp) {
HXLINE( 116)						charsMap->set(charToAdd,true);
            					}
            				}
            			}
            		}
HXLINE( 121)		{
HXLINE( 121)			 ::Dynamic individualChar = charsMap->keys();
HXDLIN( 121)			while(( (bool)(individualChar->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 121)				::String individualChar1 = ( (::String)(individualChar->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 122)				Float x = ::cutscenes::DialogueBoxPsych_obj::LEFT_CHAR_X;
HXLINE( 123)				Float y = ::cutscenes::DialogueBoxPsych_obj::DEFAULT_CHAR_Y;
HXLINE( 124)				 ::cutscenes::DialogueCharacter _hx_char =  ::cutscenes::DialogueCharacter_obj::__alloc( HX_CTX ,(x + this->offsetPos),y,individualChar1);
HXLINE( 125)				Float _hx_tmp1 = _hx_char->get_width();
HXDLIN( 125)				_hx_char->setGraphicSize(::Std_obj::_hx_int(((_hx_tmp1 * ::cutscenes::DialogueCharacter_obj::DEFAULT_SCALE) * ( (Float)(_hx_char->jsonFile->__Field(HX_("scale",8a,ce,ce,78),::hx::paccDynamic)) ))),null());
HXLINE( 126)				_hx_char->updateHitbox();
HXLINE( 127)				{
HXLINE( 127)					 ::flixel::math::FlxBasePoint this1 = _hx_char->scrollFactor;
HXDLIN( 127)					this1->set_x(( (Float)(0) ));
HXDLIN( 127)					this1->set_y(( (Float)(0) ));
            				}
HXLINE( 128)				_hx_char->set_alpha(((Float)0.00001));
HXLINE( 129)				this->add(_hx_char);
HXLINE( 131)				bool saveY = false;
HXLINE( 132)				::String _hx_switch_0 = ( (::String)(_hx_char->jsonFile->__Field(HX_("dialogue_pos",ad,3b,6d,1a),::hx::paccDynamic)) );
            				if (  (_hx_switch_0==HX_("center",d5,25,db,05)) ){
HXLINE( 134)					_hx_char->set_x((( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) )));
HXLINE( 135)					Float char1 = _hx_char->x;
HXDLIN( 135)					_hx_char->set_x((char1 - (_hx_char->get_width() / ( (Float)(2) ))));
HXLINE( 136)					y = _hx_char->y;
HXLINE( 137)					_hx_char->set_y(( (Float)((::flixel::FlxG_obj::height + 50)) ));
HXLINE( 138)					saveY = true;
HXLINE( 133)					goto _hx_goto_5;
            				}
            				if (  (_hx_switch_0==HX_("right",dc,0b,64,e9)) ){
HXLINE( 140)					int x1 = ::flixel::FlxG_obj::width;
HXDLIN( 140)					Float x2 = (( (Float)(x1) ) - _hx_char->get_width());
HXDLIN( 140)					x = (x2 + ::cutscenes::DialogueBoxPsych_obj::RIGHT_CHAR_X);
HXLINE( 141)					_hx_char->set_x((x - this->offsetPos));
HXLINE( 139)					goto _hx_goto_5;
            				}
            				_hx_goto_5:;
HXLINE( 143)				x = (x +  ::Dynamic(_hx_char->jsonFile->__Field(HX_("position",a9,a0,fa,ca),::hx::paccDynamic))->__GetItem(0));
HXLINE( 144)				y = (y +  ::Dynamic(_hx_char->jsonFile->__Field(HX_("position",a9,a0,fa,ca),::hx::paccDynamic))->__GetItem(1));
HXLINE( 145)				_hx_char->set_x((_hx_char->x +  ::Dynamic(_hx_char->jsonFile->__Field(HX_("position",a9,a0,fa,ca),::hx::paccDynamic))->__GetItem(0)));
HXLINE( 146)				_hx_char->set_y((_hx_char->y +  ::Dynamic(_hx_char->jsonFile->__Field(HX_("position",a9,a0,fa,ca),::hx::paccDynamic))->__GetItem(1)));
HXLINE( 147)				Float _hx_tmp2;
HXDLIN( 147)				if (saveY) {
HXLINE( 147)					_hx_tmp2 = y;
            				}
            				else {
HXLINE( 147)					_hx_tmp2 = x;
            				}
HXDLIN( 147)				_hx_char->startingPos = _hx_tmp2;
HXLINE( 148)				this->arrayCharacters->push(_hx_char);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(DialogueBoxPsych_obj,spawnCharacters,(void))

void DialogueBoxPsych_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_158_update)
HXLINE( 159)		if (this->ignoreThisFrame) {
HXLINE( 160)			this->ignoreThisFrame = false;
HXLINE( 161)			this->super::update(elapsed);
HXLINE( 162)			return;
            		}
HXLINE( 165)		if (!(this->dialogueEnded)) {
HXLINE( 166)			 ::flixel::FlxSprite fh = this->bgFade;
HXDLIN( 166)			fh->set_alpha((fh->alpha + (((Float)0.5) * elapsed)));
HXLINE( 167)			if ((this->bgFade->alpha > ((Float)0.5))) {
HXLINE( 167)				this->bgFade->set_alpha(((Float)0.5));
            			}
HXLINE( 169)			bool back = ::backend::Controls_obj::instance->get_BACK();
HXLINE( 170)			bool _hx_tmp;
HXDLIN( 170)			if (!(::backend::Controls_obj::instance->get_ACCEPT())) {
HXLINE( 170)				_hx_tmp = back;
            			}
            			else {
HXLINE( 170)				_hx_tmp = true;
            			}
HXDLIN( 170)			if (_hx_tmp) {
HXLINE( 171)				bool _hx_tmp1;
HXDLIN( 171)				if (!(this->daText->finishedText)) {
HXLINE( 171)					_hx_tmp1 = !(back);
            				}
            				else {
HXLINE( 171)					_hx_tmp1 = false;
            				}
HXDLIN( 171)				if (_hx_tmp1) {
HXLINE( 173)					this->daText->finishText();
HXLINE( 174)					if (::hx::IsNotNull( this->skipDialogueThing )) {
HXLINE( 175)						this->skipDialogueThing();
            					}
            				}
            				else {
HXLINE( 178)					bool _hx_tmp2;
HXDLIN( 178)					if (!(back)) {
HXLINE( 178)						_hx_tmp2 = (this->currentText >= ( (::Array< ::Dynamic>)(this->dialogueList->__Field(HX_("dialogue",18,2d,94,a7),::hx::paccDynamic)) )->length);
            					}
            					else {
HXLINE( 178)						_hx_tmp2 = true;
            					}
HXDLIN( 178)					if (_hx_tmp2) {
HXLINE( 180)						this->dialogueEnded = true;
HXLINE( 181)						{
HXLINE( 181)							int _g = 0;
HXDLIN( 181)							int _g1 = this->textBoxTypes->length;
HXDLIN( 181)							while((_g < _g1)){
HXLINE( 181)								_g = (_g + 1);
HXDLIN( 181)								int i = (_g - 1);
HXLINE( 182)								::Array< ::String > checkArray = ::Array_obj< ::String >::fromData( _hx_array_data_ebf841ed_18,2);
HXLINE( 183)								::String animName = this->box->animation->_curAnim->name;
HXLINE( 184)								{
HXLINE( 184)									int _g2 = 0;
HXDLIN( 184)									int _g3 = checkArray->length;
HXDLIN( 184)									while((_g2 < _g3)){
HXLINE( 184)										_g2 = (_g2 + 1);
HXDLIN( 184)										int j = (_g2 - 1);
HXLINE( 185)										bool _hx_tmp3;
HXDLIN( 185)										if ((animName != (checkArray->__get(j) + this->textBoxTypes->__get(i)))) {
HXLINE( 185)											_hx_tmp3 = (animName == ((checkArray->__get(j) + this->textBoxTypes->__get(i)) + HX_("Open",ea,2f,8d,34)));
            										}
            										else {
HXLINE( 185)											_hx_tmp3 = true;
            										}
HXDLIN( 185)										if (_hx_tmp3) {
HXLINE( 186)											this->box->animation->play(((checkArray->__get(j) + this->textBoxTypes->__get(i)) + HX_("Open",ea,2f,8d,34)),true,null(),null());
            										}
            									}
            								}
            							}
            						}
HXLINE( 191)						this->box->animation->_curAnim->set_curFrame((this->box->animation->_curAnim->frames->length - 1));
HXLINE( 192)						this->box->animation->_curAnim->reverse();
HXLINE( 193)						if (::hx::IsNotNull( this->daText )) {
HXLINE( 195)							this->daText->kill();
HXLINE( 196)							this->remove(this->daText,null());
HXLINE( 197)							this->daText->destroy();
            						}
HXLINE( 199)						this->skipText->set_visible(false);
HXLINE( 200)						::cutscenes::DialogueBoxPsych_obj::updateBoxOffsets(this->box);
HXLINE( 201)						{
            							HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            							void _hx_run( ::flixel::tweens::FlxTween _){
            								HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_201_update)
HXLINE( 201)								 ::flixel::sound::FlxSound _this = ::flixel::FlxG_obj::sound->music;
HXDLIN( 201)								_this->cleanup(_this->autoDestroy,true);
            							}
            							HX_END_LOCAL_FUNC1((void))

HXLINE( 201)							 ::flixel::sound::FlxSound _this = ::flixel::FlxG_obj::sound->music;
HXDLIN( 201)							 ::Dynamic To = 0;
HXDLIN( 201)							if (::hx::IsNull( To )) {
HXLINE( 201)								To = 0;
            							}
HXDLIN( 201)							if (::hx::IsNotNull( _this->fadeTween )) {
HXLINE( 201)								_this->fadeTween->cancel();
            							}
HXDLIN( 201)							_this->fadeTween = ::flixel::tweens::FlxTween_obj::num(_this->_volume,( (Float)(To) ),1, ::Dynamic(::hx::Anon_obj::Create(1)
            								->setFixed(0,HX_("onComplete",f8,d4,7e,5d), ::Dynamic(new _hx_Closure_0()))),_this->volumeTween_dyn());
            						}
            					}
            					else {
HXLINE( 203)						this->startNextDialog();
            					}
            				}
HXLINE( 205)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp4 = ::flixel::FlxG_obj::sound;
HXDLIN( 205)				 ::openfl::media::Sound _hx_tmp5 = ::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + this->closeSound),null(),true,null());
HXDLIN( 205)				_hx_tmp4->play(_hx_tmp5,this->closeVolume,null(),null(),null(),null());
            			}
            			else {
HXLINE( 206)				if (this->daText->finishedText) {
HXLINE( 207)					 ::cutscenes::DialogueCharacter _hx_char = this->arrayCharacters->__get(this->lastCharacter).StaticCast<  ::cutscenes::DialogueCharacter >();
HXLINE( 208)					bool _hx_tmp6;
HXDLIN( 208)					bool _hx_tmp7;
HXDLIN( 208)					bool _hx_tmp8;
HXDLIN( 208)					if (::hx::IsNotNull( _hx_char )) {
HXLINE( 208)						_hx_tmp8 = ::hx::IsNotNull( _hx_char->animation->_curAnim );
            					}
            					else {
HXLINE( 208)						_hx_tmp8 = false;
            					}
HXDLIN( 208)					if (_hx_tmp8) {
HXLINE( 208)						_hx_tmp7 = _hx_char->animationIsLoop();
            					}
            					else {
HXLINE( 208)						_hx_tmp7 = false;
            					}
HXDLIN( 208)					if (_hx_tmp7) {
HXLINE( 208)						_hx_tmp6 = _hx_char->animation->get_finished();
            					}
            					else {
HXLINE( 208)						_hx_tmp6 = false;
            					}
HXDLIN( 208)					if (_hx_tmp6) {
HXLINE( 209)						_hx_char->playAnim(_hx_char->animation->_curAnim->name,true);
            					}
            				}
            				else {
HXLINE( 212)					 ::cutscenes::DialogueCharacter char1 = this->arrayCharacters->__get(this->lastCharacter).StaticCast<  ::cutscenes::DialogueCharacter >();
HXLINE( 213)					bool _hx_tmp9;
HXDLIN( 213)					bool _hx_tmp10;
HXDLIN( 213)					if (::hx::IsNotNull( char1 )) {
HXLINE( 213)						_hx_tmp10 = ::hx::IsNotNull( char1->animation->_curAnim );
            					}
            					else {
HXLINE( 213)						_hx_tmp10 = false;
            					}
HXDLIN( 213)					if (_hx_tmp10) {
HXLINE( 213)						_hx_tmp9 = char1->animation->get_finished();
            					}
            					else {
HXLINE( 213)						_hx_tmp9 = false;
            					}
HXDLIN( 213)					if (_hx_tmp9) {
HXLINE( 214)						char1->animation->_curAnim->restart();
            					}
            				}
            			}
HXLINE( 218)			if (this->box->animation->_curAnim->finished) {
HXLINE( 219)				{
HXLINE( 219)					int _g4 = 0;
HXDLIN( 219)					int _g5 = this->textBoxTypes->length;
HXDLIN( 219)					while((_g4 < _g5)){
HXLINE( 219)						_g4 = (_g4 + 1);
HXDLIN( 219)						int i1 = (_g4 - 1);
HXLINE( 220)						::Array< ::String > checkArray1 = ::Array_obj< ::String >::fromData( _hx_array_data_ebf841ed_20,2);
HXLINE( 221)						::String animName1 = this->box->animation->_curAnim->name;
HXLINE( 222)						{
HXLINE( 222)							int _g6 = 0;
HXDLIN( 222)							int _g7 = checkArray1->length;
HXDLIN( 222)							while((_g6 < _g7)){
HXLINE( 222)								_g6 = (_g6 + 1);
HXDLIN( 222)								int j1 = (_g6 - 1);
HXLINE( 223)								bool _hx_tmp11;
HXDLIN( 223)								if ((animName1 != (checkArray1->__get(j1) + this->textBoxTypes->__get(i1)))) {
HXLINE( 223)									_hx_tmp11 = (animName1 == ((checkArray1->__get(j1) + this->textBoxTypes->__get(i1)) + HX_("Open",ea,2f,8d,34)));
            								}
            								else {
HXLINE( 223)									_hx_tmp11 = true;
            								}
HXDLIN( 223)								if (_hx_tmp11) {
HXLINE( 224)									this->box->animation->play((checkArray1->__get(j1) + this->textBoxTypes->__get(i1)),true,null(),null());
            								}
            							}
            						}
            					}
            				}
HXLINE( 228)				::cutscenes::DialogueBoxPsych_obj::updateBoxOffsets(this->box);
            			}
HXLINE( 231)			bool _hx_tmp12;
HXDLIN( 231)			if ((this->lastCharacter != -1)) {
HXLINE( 231)				_hx_tmp12 = (this->arrayCharacters->length > 0);
            			}
            			else {
HXLINE( 231)				_hx_tmp12 = false;
            			}
HXDLIN( 231)			if (_hx_tmp12) {
HXLINE( 232)				int _g8 = 0;
HXDLIN( 232)				int _g9 = this->arrayCharacters->length;
HXDLIN( 232)				while((_g8 < _g9)){
HXLINE( 232)					_g8 = (_g8 + 1);
HXDLIN( 232)					int i2 = (_g8 - 1);
HXLINE( 233)					 ::cutscenes::DialogueCharacter char2 = this->arrayCharacters->__get(i2).StaticCast<  ::cutscenes::DialogueCharacter >();
HXLINE( 234)					if (::hx::IsNotNull( char2 )) {
HXLINE( 235)						if ((i2 != this->lastCharacter)) {
HXLINE( 236)							::String _hx_switch_0 = ( (::String)(char2->jsonFile->__Field(HX_("dialogue_pos",ad,3b,6d,1a),::hx::paccDynamic)) );
            							if (  (_hx_switch_0==HX_("center",d5,25,db,05)) ){
HXLINE( 241)								char2->set_y((char2->y + (( (Float)(this->scrollSpeed) ) * elapsed)));
HXLINE( 242)								if ((char2->y > (char2->startingPos + ::flixel::FlxG_obj::height))) {
HXLINE( 242)									char2->set_y((char2->startingPos + ::flixel::FlxG_obj::height));
            								}
HXLINE( 240)								goto _hx_goto_12;
            							}
            							if (  (_hx_switch_0==HX_("left",07,08,b0,47)) ){
HXLINE( 238)								char2->set_x((char2->x - (( (Float)(this->scrollSpeed) ) * elapsed)));
HXLINE( 239)								if ((char2->x < (char2->startingPos + this->offsetPos))) {
HXLINE( 239)									char2->set_x((char2->startingPos + this->offsetPos));
            								}
HXLINE( 237)								goto _hx_goto_12;
            							}
            							if (  (_hx_switch_0==HX_("right",dc,0b,64,e9)) ){
HXLINE( 244)								char2->set_x((char2->x + (( (Float)(this->scrollSpeed) ) * elapsed)));
HXLINE( 245)								if ((char2->x > (char2->startingPos - this->offsetPos))) {
HXLINE( 245)									char2->set_x((char2->startingPos - this->offsetPos));
            								}
HXLINE( 243)								goto _hx_goto_12;
            							}
            							_hx_goto_12:;
HXLINE( 247)							char2->set_alpha((char2->alpha - (( (Float)(3) ) * elapsed)));
HXLINE( 248)							if ((char2->alpha < ((Float)0.00001))) {
HXLINE( 248)								char2->set_alpha(((Float)0.00001));
            							}
            						}
            						else {
HXLINE( 250)							::String _hx_switch_1 = ( (::String)(char2->jsonFile->__Field(HX_("dialogue_pos",ad,3b,6d,1a),::hx::paccDynamic)) );
            							if (  (_hx_switch_1==HX_("center",d5,25,db,05)) ){
HXLINE( 255)								char2->set_y((char2->y - (( (Float)(this->scrollSpeed) ) * elapsed)));
HXLINE( 256)								if ((char2->y < char2->startingPos)) {
HXLINE( 256)									char2->set_y(char2->startingPos);
            								}
HXLINE( 254)								goto _hx_goto_13;
            							}
            							if (  (_hx_switch_1==HX_("left",07,08,b0,47)) ){
HXLINE( 252)								char2->set_x((char2->x + (( (Float)(this->scrollSpeed) ) * elapsed)));
HXLINE( 253)								if ((char2->x > char2->startingPos)) {
HXLINE( 253)									char2->set_x(char2->startingPos);
            								}
HXLINE( 251)								goto _hx_goto_13;
            							}
            							if (  (_hx_switch_1==HX_("right",dc,0b,64,e9)) ){
HXLINE( 258)								char2->set_x((char2->x - (( (Float)(this->scrollSpeed) ) * elapsed)));
HXLINE( 259)								if ((char2->x < char2->startingPos)) {
HXLINE( 259)									char2->set_x(char2->startingPos);
            								}
HXLINE( 257)								goto _hx_goto_13;
            							}
            							_hx_goto_13:;
HXLINE( 261)							char2->set_alpha((char2->alpha + (( (Float)(3) ) * elapsed)));
HXLINE( 262)							if ((char2->alpha > 1)) {
HXLINE( 262)								char2->set_alpha(( (Float)(1) ));
            							}
            						}
            					}
            				}
            			}
            		}
            		else {
HXLINE( 268)			bool _hx_tmp13;
HXDLIN( 268)			if (::hx::IsNotNull( this->box )) {
HXLINE( 268)				_hx_tmp13 = (this->box->animation->_curAnim->curFrame <= 0);
            			}
            			else {
HXLINE( 268)				_hx_tmp13 = false;
            			}
HXDLIN( 268)			if (_hx_tmp13) {
HXLINE( 269)				this->box->kill();
HXLINE( 270)				this->remove(this->box,null());
HXLINE( 271)				this->box->destroy();
HXLINE( 272)				this->box = null();
            			}
HXLINE( 275)			if (::hx::IsNotNull( this->bgFade )) {
HXLINE( 276)				 ::flixel::FlxSprite fh1 = this->bgFade;
HXDLIN( 276)				fh1->set_alpha((fh1->alpha - (((Float)0.5) * elapsed)));
HXLINE( 277)				if ((this->bgFade->alpha <= 0)) {
HXLINE( 278)					this->bgFade->kill();
HXLINE( 279)					this->remove(this->bgFade,null());
HXLINE( 280)					this->bgFade->destroy();
HXLINE( 281)					this->bgFade = null();
            				}
            			}
HXLINE( 285)			{
HXLINE( 285)				int _g10 = 0;
HXDLIN( 285)				int _g11 = this->arrayCharacters->length;
HXDLIN( 285)				while((_g10 < _g11)){
HXLINE( 285)					_g10 = (_g10 + 1);
HXDLIN( 285)					int i3 = (_g10 - 1);
HXLINE( 286)					 ::cutscenes::DialogueCharacter leChar = this->arrayCharacters->__get(i3).StaticCast<  ::cutscenes::DialogueCharacter >();
HXLINE( 287)					if (::hx::IsNotNull( leChar )) {
HXLINE( 288)						::String _hx_switch_2 = ( (::String)(this->arrayCharacters->__get(i3).StaticCast<  ::cutscenes::DialogueCharacter >()->jsonFile->__Field(HX_("dialogue_pos",ad,3b,6d,1a),::hx::paccDynamic)) );
            						if (  (_hx_switch_2==HX_("center",d5,25,db,05)) ){
HXLINE( 292)							leChar->set_y((leChar->y + (( (Float)(this->scrollSpeed) ) * elapsed)));
HXDLIN( 292)							goto _hx_goto_15;
            						}
            						if (  (_hx_switch_2==HX_("left",07,08,b0,47)) ){
HXLINE( 290)							leChar->set_x((leChar->x - (( (Float)(this->scrollSpeed) ) * elapsed)));
HXDLIN( 290)							goto _hx_goto_15;
            						}
            						if (  (_hx_switch_2==HX_("right",dc,0b,64,e9)) ){
HXLINE( 294)							leChar->set_x((leChar->x + (( (Float)(this->scrollSpeed) ) * elapsed)));
HXDLIN( 294)							goto _hx_goto_15;
            						}
            						_hx_goto_15:;
HXLINE( 296)						leChar->set_alpha((leChar->alpha - (elapsed * ( (Float)(10) ))));
            					}
            				}
            			}
HXLINE( 300)			bool _hx_tmp14;
HXDLIN( 300)			if (::hx::IsNull( this->box )) {
HXLINE( 300)				_hx_tmp14 = ::hx::IsNull( this->bgFade );
            			}
            			else {
HXLINE( 300)				_hx_tmp14 = false;
            			}
HXDLIN( 300)			if (_hx_tmp14) {
HXLINE( 301)				{
HXLINE( 301)					int _g12 = 0;
HXDLIN( 301)					int _g13 = this->arrayCharacters->length;
HXDLIN( 301)					while((_g12 < _g13)){
HXLINE( 301)						_g12 = (_g12 + 1);
HXDLIN( 301)						int i4 = (_g12 - 1);
HXLINE( 302)						 ::cutscenes::DialogueCharacter leChar1 = this->arrayCharacters->__get(0).StaticCast<  ::cutscenes::DialogueCharacter >();
HXLINE( 303)						if (::hx::IsNotNull( leChar1 )) {
HXLINE( 304)							this->arrayCharacters->remove(leChar1);
HXLINE( 305)							leChar1->kill();
HXLINE( 306)							this->remove(leChar1,null());
HXLINE( 307)							leChar1->destroy();
            						}
            					}
            				}
HXLINE( 310)				this->finishThing();
HXLINE( 311)				this->kill();
            			}
            		}
HXLINE( 314)		this->super::update(elapsed);
            	}


void DialogueBoxPsych_obj::startNextDialog(){
            	HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_320_startNextDialog)
HXLINE( 321)		 ::Dynamic curDialogue = null();
HXLINE( 322)		do {
HXLINE( 323)			curDialogue =  ::Dynamic(this->dialogueList->__Field(HX_("dialogue",18,2d,94,a7),::hx::paccDynamic))->__GetItem(this->currentText);
            		} while(::hx::IsNull( curDialogue ));
;
HXLINE( 326)		bool _hx_tmp;
HXDLIN( 326)		if (::hx::IsNotNull( curDialogue->__Field(HX_("text",ad,cc,f9,4c),::hx::paccDynamic) )) {
HXLINE( 326)			_hx_tmp = (( (::String)(curDialogue->__Field(HX_("text",ad,cc,f9,4c),::hx::paccDynamic)) ).length < 1);
            		}
            		else {
HXLINE( 326)			_hx_tmp = true;
            		}
HXDLIN( 326)		if (_hx_tmp) {
HXLINE( 326)			curDialogue->__SetField(HX_("text",ad,cc,f9,4c),HX_(" ",20,00,00,00),::hx::paccDynamic);
            		}
HXLINE( 327)		if (::hx::IsNull( curDialogue->__Field(HX_("boxState",06,60,2a,ff),::hx::paccDynamic) )) {
HXLINE( 327)			curDialogue->__SetField(HX_("boxState",06,60,2a,ff),HX_("normal",27,72,69,30),::hx::paccDynamic);
            		}
HXLINE( 328)		bool _hx_tmp1;
HXDLIN( 328)		if (::hx::IsNotNull( curDialogue->__Field(HX_("speed",87,97,69,81),::hx::paccDynamic) )) {
HXLINE( 328)			_hx_tmp1 = ::Math_obj::isNaN(( (Float)(curDialogue->__Field(HX_("speed",87,97,69,81),::hx::paccDynamic)) ));
            		}
            		else {
HXLINE( 328)			_hx_tmp1 = true;
            		}
HXDLIN( 328)		if (_hx_tmp1) {
HXLINE( 328)			curDialogue->__SetField(HX_("speed",87,97,69,81),((Float)0.05),::hx::paccDynamic);
            		}
HXLINE( 330)		::String animName = ( (::String)(curDialogue->__Field(HX_("boxState",06,60,2a,ff),::hx::paccDynamic)) );
HXLINE( 331)		::String boxType = this->textBoxTypes->__get(0);
HXLINE( 332)		{
HXLINE( 332)			int _g = 0;
HXDLIN( 332)			int _g1 = this->textBoxTypes->length;
HXDLIN( 332)			while((_g < _g1)){
HXLINE( 332)				_g = (_g + 1);
HXDLIN( 332)				int i = (_g - 1);
HXLINE( 333)				if ((this->textBoxTypes->__get(i) == animName)) {
HXLINE( 334)					boxType = animName;
            				}
            			}
            		}
HXLINE( 338)		int character = 0;
HXLINE( 339)		this->box->set_visible(true);
HXLINE( 340)		{
HXLINE( 340)			int _g2 = 0;
HXDLIN( 340)			int _g3 = this->arrayCharacters->length;
HXDLIN( 340)			while((_g2 < _g3)){
HXLINE( 340)				_g2 = (_g2 + 1);
HXDLIN( 340)				int i1 = (_g2 - 1);
HXLINE( 341)				if (::hx::IsEq( this->arrayCharacters->__get(i1).StaticCast<  ::cutscenes::DialogueCharacter >()->curCharacter,curDialogue->__Field(HX_("portrait",5b,21,af,b8),::hx::paccDynamic) )) {
HXLINE( 342)					character = i1;
HXLINE( 343)					goto _hx_goto_23;
            				}
            			}
            			_hx_goto_23:;
            		}
HXLINE( 346)		::String centerPrefix = HX_("",00,00,00,00);
HXLINE( 347)		::String lePosition = ( (::String)(this->arrayCharacters->__get(character).StaticCast<  ::cutscenes::DialogueCharacter >()->jsonFile->__Field(HX_("dialogue_pos",ad,3b,6d,1a),::hx::paccDynamic)) );
HXLINE( 348)		if ((lePosition == HX_("center",d5,25,db,05))) {
HXLINE( 348)			centerPrefix = HX_("center-",b8,f4,e5,19);
            		}
HXLINE( 350)		if ((character != this->lastCharacter)) {
HXLINE( 351)			this->box->animation->play(((centerPrefix + boxType) + HX_("Open",ea,2f,8d,34)),true,null(),null());
HXLINE( 352)			::cutscenes::DialogueBoxPsych_obj::updateBoxOffsets(this->box);
HXLINE( 353)			this->box->set_flipX((lePosition == HX_("left",07,08,b0,47)));
            		}
            		else {
HXLINE( 354)			if ((boxType != this->lastBoxType)) {
HXLINE( 355)				this->box->animation->play((centerPrefix + boxType),true,null(),null());
HXLINE( 356)				::cutscenes::DialogueBoxPsych_obj::updateBoxOffsets(this->box);
            			}
            		}
HXLINE( 358)		this->lastCharacter = character;
HXLINE( 359)		this->lastBoxType = boxType;
HXLINE( 361)		this->daText->set_text(( (::String)(curDialogue->__Field(HX_("text",ad,cc,f9,4c),::hx::paccDynamic)) ));
HXLINE( 362)		this->daText->delay = ( (Float)(curDialogue->__Field(HX_("speed",87,97,69,81),::hx::paccDynamic)) );
HXLINE( 363)		this->daText->sound = ( (::String)(curDialogue->__Field(HX_("sound",cf,8c,cc,80),::hx::paccDynamic)) );
HXLINE( 364)		bool _hx_tmp2;
HXDLIN( 364)		if (::hx::IsNotNull( this->daText->sound )) {
HXLINE( 364)			_hx_tmp2 = (::StringTools_obj::trim(this->daText->sound) == HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 364)			_hx_tmp2 = true;
            		}
HXDLIN( 364)		if (_hx_tmp2) {
HXLINE( 364)			this->daText->sound = HX_("dialogue",18,2d,94,a7);
            		}
HXLINE( 366)		this->daText->set_y(( (Float)(::cutscenes::DialogueBoxPsych_obj::DEFAULT_TEXT_Y) ));
HXLINE( 367)		if ((this->daText->rows > 2)) {
HXLINE( 367)			 ::objects::TypedAlphabet fh = this->daText;
HXDLIN( 367)			fh->set_y((fh->y - ( (Float)(::cutscenes::DialogueBoxPsych_obj::LONG_TEXT_ADD) )));
            		}
HXLINE( 369)		 ::cutscenes::DialogueCharacter _hx_char = this->arrayCharacters->__get(character).StaticCast<  ::cutscenes::DialogueCharacter >();
HXLINE( 370)		if (::hx::IsNotNull( _hx_char )) {
HXLINE( 371)			_hx_char->playAnim(( (::String)(curDialogue->__Field(HX_("expression",98,11,9f,2e),::hx::paccDynamic)) ),this->daText->finishedText);
HXLINE( 372)			if (::hx::IsNotNull( _hx_char->animation->_curAnim )) {
HXLINE( 373)				Float rate = (( (Float)(24) ) - (((( (Float)(curDialogue->__Field(HX_("speed",87,97,69,81),::hx::paccDynamic)) ) - ((Float)0.05)) / ( (Float)(5) )) * ( (Float)(480) )));
HXLINE( 374)				if ((rate < 12)) {
HXLINE( 374)					rate = ( (Float)(12) );
            				}
            				else {
HXLINE( 375)					if ((rate > 48)) {
HXLINE( 375)						rate = ( (Float)(48) );
            					}
            				}
HXLINE( 376)				_hx_char->animation->_curAnim->set_frameRate(rate);
            			}
            		}
HXLINE( 379)		this->currentText++;
HXLINE( 381)		if (::hx::IsNotNull( this->nextDialogueThing )) {
HXLINE( 382)			this->nextDialogueThing();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(DialogueBoxPsych_obj,startNextDialog,(void))

int DialogueBoxPsych_obj::DEFAULT_TEXT_X;

int DialogueBoxPsych_obj::DEFAULT_TEXT_Y;

int DialogueBoxPsych_obj::LONG_TEXT_ADD;

Float DialogueBoxPsych_obj::LEFT_CHAR_X;

Float DialogueBoxPsych_obj::RIGHT_CHAR_X;

Float DialogueBoxPsych_obj::DEFAULT_CHAR_Y;

 ::Dynamic DialogueBoxPsych_obj::parseDialogue(::String path){
            	HX_GC_STACKFRAME(&_hx_pos_abed4712cfea8e8f_388_parseDialogue)
HXDLIN( 388)		 ::Dynamic _hx_tmp;
HXDLIN( 388)		if (::sys::FileSystem_obj::exists(path)) {
HXDLIN( 388)			_hx_tmp =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::sys::io::File_obj::getContent(path))->doParse();
            		}
            		else {
HXDLIN( 388)			_hx_tmp =  ::Dynamic(::hx::Anon_obj::Create(1)
            				->setFixed(0,HX_("dialogue",18,2d,94,a7),::Array_obj< ::Dynamic>::__new(1)->init(0, ::Dynamic(::hx::Anon_obj::Create(5)
            					->setFixed(0,HX_("speed",87,97,69,81),((Float)0.05))
            					->setFixed(1,HX_("portrait",5b,21,af,b8),HX_("bf",c4,55,00,00))
            					->setFixed(2,HX_("boxState",06,60,2a,ff),HX_("normal",27,72,69,30))
            					->setFixed(3,HX_("expression",98,11,9f,2e),HX_("talk",2c,b9,f6,4c))
            					->setFixed(4,HX_("text",ad,cc,f9,4c),HX_("DIALOGUE NOT FOUND",2d,fa,cb,ec))))));
            		}
HXDLIN( 388)		return _hx_tmp;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(DialogueBoxPsych_obj,parseDialogue,return )

 ::Dynamic DialogueBoxPsych_obj::dummy(){
            	HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_396_dummy)
HXDLIN( 396)		return  ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("dialogue",18,2d,94,a7),::Array_obj< ::Dynamic>::__new(1)->init(0, ::Dynamic(::hx::Anon_obj::Create(5)
            				->setFixed(0,HX_("speed",87,97,69,81),((Float)0.05))
            				->setFixed(1,HX_("portrait",5b,21,af,b8),HX_("bf",c4,55,00,00))
            				->setFixed(2,HX_("boxState",06,60,2a,ff),HX_("normal",27,72,69,30))
            				->setFixed(3,HX_("expression",98,11,9f,2e),HX_("talk",2c,b9,f6,4c))
            				->setFixed(4,HX_("text",ad,cc,f9,4c),HX_("DIALOGUE NOT FOUND",2d,fa,cb,ec))))));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(DialogueBoxPsych_obj,dummy,return )

void DialogueBoxPsych_obj::updateBoxOffsets( ::flixel::FlxSprite box){
            	HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_407_updateBoxOffsets)
HXLINE( 408)		box->centerOffsets(null());
HXLINE( 409)		box->updateHitbox();
HXLINE( 410)		if (::StringTools_obj::startsWith(box->animation->_curAnim->name,HX_("angry",21,49,e2,22))) {
HXLINE( 411)			 ::flixel::math::FlxBasePoint this1 = box->offset;
HXDLIN( 411)			this1->set_x(( (Float)(50) ));
HXDLIN( 411)			this1->set_y(( (Float)(65) ));
            		}
            		else {
HXLINE( 412)			if (::StringTools_obj::startsWith(box->animation->_curAnim->name,HX_("center-angry",69,39,92,b0))) {
HXLINE( 413)				 ::flixel::math::FlxBasePoint this2 = box->offset;
HXDLIN( 413)				this2->set_x(( (Float)(50) ));
HXDLIN( 413)				this2->set_y(( (Float)(30) ));
            			}
            			else {
HXLINE( 415)				 ::flixel::math::FlxBasePoint this3 = box->offset;
HXDLIN( 415)				this3->set_x(( (Float)(10) ));
HXDLIN( 415)				this3->set_y(( (Float)(0) ));
            			}
            		}
HXLINE( 418)		if (!(box->flipX)) {
HXLINE( 418)			box->offset->set_y((box->offset->y + 10));
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(DialogueBoxPsych_obj,updateBoxOffsets,(void))


::hx::ObjectPtr< DialogueBoxPsych_obj > DialogueBoxPsych_obj::__new( ::Dynamic dialogueList,::String song) {
	::hx::ObjectPtr< DialogueBoxPsych_obj > __this = new DialogueBoxPsych_obj();
	__this->__construct(dialogueList,song);
	return __this;
}

::hx::ObjectPtr< DialogueBoxPsych_obj > DialogueBoxPsych_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic dialogueList,::String song) {
	DialogueBoxPsych_obj *__this = (DialogueBoxPsych_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(DialogueBoxPsych_obj), true, "cutscenes.DialogueBoxPsych"));
	*(void **)__this = DialogueBoxPsych_obj::_hx_vtable;
	__this->__construct(dialogueList,song);
	return __this;
}

DialogueBoxPsych_obj::DialogueBoxPsych_obj()
{
}

void DialogueBoxPsych_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(DialogueBoxPsych);
	HX_MARK_MEMBER_NAME(scrollSpeed,"scrollSpeed");
	HX_MARK_MEMBER_NAME(dialogue,"dialogue");
	HX_MARK_MEMBER_NAME(dialogueList,"dialogueList");
	HX_MARK_MEMBER_NAME(finishThing,"finishThing");
	HX_MARK_MEMBER_NAME(nextDialogueThing,"nextDialogueThing");
	HX_MARK_MEMBER_NAME(skipDialogueThing,"skipDialogueThing");
	HX_MARK_MEMBER_NAME(bgFade,"bgFade");
	HX_MARK_MEMBER_NAME(box,"box");
	HX_MARK_MEMBER_NAME(textToType,"textToType");
	HX_MARK_MEMBER_NAME(arrayCharacters,"arrayCharacters");
	HX_MARK_MEMBER_NAME(currentText,"currentText");
	HX_MARK_MEMBER_NAME(offsetPos,"offsetPos");
	HX_MARK_MEMBER_NAME(skipText,"skipText");
	HX_MARK_MEMBER_NAME(textBoxTypes,"textBoxTypes");
	HX_MARK_MEMBER_NAME(curCharacter,"curCharacter");
	HX_MARK_MEMBER_NAME(dialogueStarted,"dialogueStarted");
	HX_MARK_MEMBER_NAME(dialogueEnded,"dialogueEnded");
	HX_MARK_MEMBER_NAME(daText,"daText");
	HX_MARK_MEMBER_NAME(ignoreThisFrame,"ignoreThisFrame");
	HX_MARK_MEMBER_NAME(closeSound,"closeSound");
	HX_MARK_MEMBER_NAME(closeVolume,"closeVolume");
	HX_MARK_MEMBER_NAME(lastCharacter,"lastCharacter");
	HX_MARK_MEMBER_NAME(lastBoxType,"lastBoxType");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void DialogueBoxPsych_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(scrollSpeed,"scrollSpeed");
	HX_VISIT_MEMBER_NAME(dialogue,"dialogue");
	HX_VISIT_MEMBER_NAME(dialogueList,"dialogueList");
	HX_VISIT_MEMBER_NAME(finishThing,"finishThing");
	HX_VISIT_MEMBER_NAME(nextDialogueThing,"nextDialogueThing");
	HX_VISIT_MEMBER_NAME(skipDialogueThing,"skipDialogueThing");
	HX_VISIT_MEMBER_NAME(bgFade,"bgFade");
	HX_VISIT_MEMBER_NAME(box,"box");
	HX_VISIT_MEMBER_NAME(textToType,"textToType");
	HX_VISIT_MEMBER_NAME(arrayCharacters,"arrayCharacters");
	HX_VISIT_MEMBER_NAME(currentText,"currentText");
	HX_VISIT_MEMBER_NAME(offsetPos,"offsetPos");
	HX_VISIT_MEMBER_NAME(skipText,"skipText");
	HX_VISIT_MEMBER_NAME(textBoxTypes,"textBoxTypes");
	HX_VISIT_MEMBER_NAME(curCharacter,"curCharacter");
	HX_VISIT_MEMBER_NAME(dialogueStarted,"dialogueStarted");
	HX_VISIT_MEMBER_NAME(dialogueEnded,"dialogueEnded");
	HX_VISIT_MEMBER_NAME(daText,"daText");
	HX_VISIT_MEMBER_NAME(ignoreThisFrame,"ignoreThisFrame");
	HX_VISIT_MEMBER_NAME(closeSound,"closeSound");
	HX_VISIT_MEMBER_NAME(closeVolume,"closeVolume");
	HX_VISIT_MEMBER_NAME(lastCharacter,"lastCharacter");
	HX_VISIT_MEMBER_NAME(lastBoxType,"lastBoxType");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val DialogueBoxPsych_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"box") ) { return ::hx::Val( box ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"bgFade") ) { return ::hx::Val( bgFade ); }
		if (HX_FIELD_EQ(inName,"daText") ) { return ::hx::Val( daText ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"dialogue") ) { return ::hx::Val( dialogue ); }
		if (HX_FIELD_EQ(inName,"skipText") ) { return ::hx::Val( skipText ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"offsetPos") ) { return ::hx::Val( offsetPos ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"textToType") ) { return ::hx::Val( textToType ); }
		if (HX_FIELD_EQ(inName,"closeSound") ) { return ::hx::Val( closeSound ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"scrollSpeed") ) { return ::hx::Val( scrollSpeed ); }
		if (HX_FIELD_EQ(inName,"finishThing") ) { return ::hx::Val( finishThing ); }
		if (HX_FIELD_EQ(inName,"currentText") ) { return ::hx::Val( currentText ); }
		if (HX_FIELD_EQ(inName,"closeVolume") ) { return ::hx::Val( closeVolume ); }
		if (HX_FIELD_EQ(inName,"lastBoxType") ) { return ::hx::Val( lastBoxType ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"dialogueList") ) { return ::hx::Val( dialogueList ); }
		if (HX_FIELD_EQ(inName,"textBoxTypes") ) { return ::hx::Val( textBoxTypes ); }
		if (HX_FIELD_EQ(inName,"curCharacter") ) { return ::hx::Val( curCharacter ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"dialogueEnded") ) { return ::hx::Val( dialogueEnded ); }
		if (HX_FIELD_EQ(inName,"lastCharacter") ) { return ::hx::Val( lastCharacter ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"arrayCharacters") ) { return ::hx::Val( arrayCharacters ); }
		if (HX_FIELD_EQ(inName,"dialogueStarted") ) { return ::hx::Val( dialogueStarted ); }
		if (HX_FIELD_EQ(inName,"spawnCharacters") ) { return ::hx::Val( spawnCharacters_dyn() ); }
		if (HX_FIELD_EQ(inName,"ignoreThisFrame") ) { return ::hx::Val( ignoreThisFrame ); }
		if (HX_FIELD_EQ(inName,"startNextDialog") ) { return ::hx::Val( startNextDialog_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"nextDialogueThing") ) { return ::hx::Val( nextDialogueThing ); }
		if (HX_FIELD_EQ(inName,"skipDialogueThing") ) { return ::hx::Val( skipDialogueThing ); }
	}
	return super::__Field(inName,inCallProp);
}

bool DialogueBoxPsych_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"dummy") ) { outValue = dummy_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"LEFT_CHAR_X") ) { outValue = ( LEFT_CHAR_X ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"RIGHT_CHAR_X") ) { outValue = ( RIGHT_CHAR_X ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"LONG_TEXT_ADD") ) { outValue = ( LONG_TEXT_ADD ); return true; }
		if (HX_FIELD_EQ(inName,"parseDialogue") ) { outValue = parseDialogue_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"DEFAULT_TEXT_X") ) { outValue = ( DEFAULT_TEXT_X ); return true; }
		if (HX_FIELD_EQ(inName,"DEFAULT_TEXT_Y") ) { outValue = ( DEFAULT_TEXT_Y ); return true; }
		if (HX_FIELD_EQ(inName,"DEFAULT_CHAR_Y") ) { outValue = ( DEFAULT_CHAR_Y ); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"updateBoxOffsets") ) { outValue = updateBoxOffsets_dyn(); return true; }
	}
	return false;
}

::hx::Val DialogueBoxPsych_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"box") ) { box=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"bgFade") ) { bgFade=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"daText") ) { daText=inValue.Cast<  ::objects::TypedAlphabet >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"dialogue") ) { dialogue=inValue.Cast<  ::objects::TypedAlphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"skipText") ) { skipText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"offsetPos") ) { offsetPos=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"textToType") ) { textToType=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"closeSound") ) { closeSound=inValue.Cast< ::String >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"scrollSpeed") ) { scrollSpeed=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"finishThing") ) { finishThing=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"currentText") ) { currentText=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"closeVolume") ) { closeVolume=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastBoxType") ) { lastBoxType=inValue.Cast< ::String >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"dialogueList") ) { dialogueList=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"textBoxTypes") ) { textBoxTypes=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"curCharacter") ) { curCharacter=inValue.Cast< ::String >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"dialogueEnded") ) { dialogueEnded=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lastCharacter") ) { lastCharacter=inValue.Cast< int >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"arrayCharacters") ) { arrayCharacters=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"dialogueStarted") ) { dialogueStarted=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ignoreThisFrame") ) { ignoreThisFrame=inValue.Cast< bool >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"nextDialogueThing") ) { nextDialogueThing=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"skipDialogueThing") ) { skipDialogueThing=inValue.Cast<  ::Dynamic >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool DialogueBoxPsych_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"LEFT_CHAR_X") ) { LEFT_CHAR_X=ioValue.Cast< Float >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"RIGHT_CHAR_X") ) { RIGHT_CHAR_X=ioValue.Cast< Float >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"LONG_TEXT_ADD") ) { LONG_TEXT_ADD=ioValue.Cast< int >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"DEFAULT_TEXT_X") ) { DEFAULT_TEXT_X=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"DEFAULT_TEXT_Y") ) { DEFAULT_TEXT_Y=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"DEFAULT_CHAR_Y") ) { DEFAULT_CHAR_Y=ioValue.Cast< Float >(); return true; }
	}
	return false;
}

void DialogueBoxPsych_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("scrollSpeed",3a,e0,46,cb));
	outFields->push(HX_("dialogue",18,2d,94,a7));
	outFields->push(HX_("dialogueList",96,e1,d8,0d));
	outFields->push(HX_("bgFade",e1,fd,cd,ab));
	outFields->push(HX_("box",0b,be,4a,00));
	outFields->push(HX_("textToType",62,de,b2,b9));
	outFields->push(HX_("arrayCharacters",a3,23,67,53));
	outFields->push(HX_("currentText",86,a5,8b,85));
	outFields->push(HX_("offsetPos",c1,3b,c0,41));
	outFields->push(HX_("skipText",cc,ba,4e,c3));
	outFields->push(HX_("textBoxTypes",3b,d8,65,ca));
	outFields->push(HX_("curCharacter",09,86,7c,d7));
	outFields->push(HX_("dialogueStarted",09,77,22,70));
	outFields->push(HX_("dialogueEnded",c2,14,61,0b));
	outFields->push(HX_("daText",ca,52,61,0d));
	outFields->push(HX_("ignoreThisFrame",7d,81,d2,40));
	outFields->push(HX_("closeSound",f7,e9,ad,4b));
	outFields->push(HX_("closeVolume",b2,4f,a3,19));
	outFields->push(HX_("lastCharacter",73,b6,0a,40));
	outFields->push(HX_("lastBoxType",af,f2,77,51));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo DialogueBoxPsych_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(DialogueBoxPsych_obj,scrollSpeed),HX_("scrollSpeed",3a,e0,46,cb)},
	{::hx::fsObject /*  ::objects::TypedAlphabet */ ,(int)offsetof(DialogueBoxPsych_obj,dialogue),HX_("dialogue",18,2d,94,a7)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(DialogueBoxPsych_obj,dialogueList),HX_("dialogueList",96,e1,d8,0d)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(DialogueBoxPsych_obj,finishThing),HX_("finishThing",9b,aa,8e,36)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(DialogueBoxPsych_obj,nextDialogueThing),HX_("nextDialogueThing",c3,c2,a1,d9)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(DialogueBoxPsych_obj,skipDialogueThing),HX_("skipDialogueThing",b7,29,12,4e)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(DialogueBoxPsych_obj,bgFade),HX_("bgFade",e1,fd,cd,ab)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(DialogueBoxPsych_obj,box),HX_("box",0b,be,4a,00)},
	{::hx::fsString,(int)offsetof(DialogueBoxPsych_obj,textToType),HX_("textToType",62,de,b2,b9)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(DialogueBoxPsych_obj,arrayCharacters),HX_("arrayCharacters",a3,23,67,53)},
	{::hx::fsInt,(int)offsetof(DialogueBoxPsych_obj,currentText),HX_("currentText",86,a5,8b,85)},
	{::hx::fsFloat,(int)offsetof(DialogueBoxPsych_obj,offsetPos),HX_("offsetPos",c1,3b,c0,41)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(DialogueBoxPsych_obj,skipText),HX_("skipText",cc,ba,4e,c3)},
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(DialogueBoxPsych_obj,textBoxTypes),HX_("textBoxTypes",3b,d8,65,ca)},
	{::hx::fsString,(int)offsetof(DialogueBoxPsych_obj,curCharacter),HX_("curCharacter",09,86,7c,d7)},
	{::hx::fsBool,(int)offsetof(DialogueBoxPsych_obj,dialogueStarted),HX_("dialogueStarted",09,77,22,70)},
	{::hx::fsBool,(int)offsetof(DialogueBoxPsych_obj,dialogueEnded),HX_("dialogueEnded",c2,14,61,0b)},
	{::hx::fsObject /*  ::objects::TypedAlphabet */ ,(int)offsetof(DialogueBoxPsych_obj,daText),HX_("daText",ca,52,61,0d)},
	{::hx::fsBool,(int)offsetof(DialogueBoxPsych_obj,ignoreThisFrame),HX_("ignoreThisFrame",7d,81,d2,40)},
	{::hx::fsString,(int)offsetof(DialogueBoxPsych_obj,closeSound),HX_("closeSound",f7,e9,ad,4b)},
	{::hx::fsFloat,(int)offsetof(DialogueBoxPsych_obj,closeVolume),HX_("closeVolume",b2,4f,a3,19)},
	{::hx::fsInt,(int)offsetof(DialogueBoxPsych_obj,lastCharacter),HX_("lastCharacter",73,b6,0a,40)},
	{::hx::fsString,(int)offsetof(DialogueBoxPsych_obj,lastBoxType),HX_("lastBoxType",af,f2,77,51)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo DialogueBoxPsych_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &DialogueBoxPsych_obj::DEFAULT_TEXT_X,HX_("DEFAULT_TEXT_X",24,d8,31,6c)},
	{::hx::fsInt,(void *) &DialogueBoxPsych_obj::DEFAULT_TEXT_Y,HX_("DEFAULT_TEXT_Y",25,d8,31,6c)},
	{::hx::fsInt,(void *) &DialogueBoxPsych_obj::LONG_TEXT_ADD,HX_("LONG_TEXT_ADD",92,bc,1d,a5)},
	{::hx::fsFloat,(void *) &DialogueBoxPsych_obj::LEFT_CHAR_X,HX_("LEFT_CHAR_X",e7,bb,19,61)},
	{::hx::fsFloat,(void *) &DialogueBoxPsych_obj::RIGHT_CHAR_X,HX_("RIGHT_CHAR_X",d2,58,47,14)},
	{::hx::fsFloat,(void *) &DialogueBoxPsych_obj::DEFAULT_CHAR_Y,HX_("DEFAULT_CHAR_Y",8e,06,1f,4b)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String DialogueBoxPsych_obj_sMemberFields[] = {
	HX_("scrollSpeed",3a,e0,46,cb),
	HX_("dialogue",18,2d,94,a7),
	HX_("dialogueList",96,e1,d8,0d),
	HX_("finishThing",9b,aa,8e,36),
	HX_("nextDialogueThing",c3,c2,a1,d9),
	HX_("skipDialogueThing",b7,29,12,4e),
	HX_("bgFade",e1,fd,cd,ab),
	HX_("box",0b,be,4a,00),
	HX_("textToType",62,de,b2,b9),
	HX_("arrayCharacters",a3,23,67,53),
	HX_("currentText",86,a5,8b,85),
	HX_("offsetPos",c1,3b,c0,41),
	HX_("skipText",cc,ba,4e,c3),
	HX_("textBoxTypes",3b,d8,65,ca),
	HX_("curCharacter",09,86,7c,d7),
	HX_("dialogueStarted",09,77,22,70),
	HX_("dialogueEnded",c2,14,61,0b),
	HX_("spawnCharacters",c5,32,da,c2),
	HX_("daText",ca,52,61,0d),
	HX_("ignoreThisFrame",7d,81,d2,40),
	HX_("closeSound",f7,e9,ad,4b),
	HX_("closeVolume",b2,4f,a3,19),
	HX_("update",09,86,05,87),
	HX_("lastCharacter",73,b6,0a,40),
	HX_("lastBoxType",af,f2,77,51),
	HX_("startNextDialog",1d,3d,9f,9a),
	::String(null()) };

static void DialogueBoxPsych_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(DialogueBoxPsych_obj::DEFAULT_TEXT_X,"DEFAULT_TEXT_X");
	HX_MARK_MEMBER_NAME(DialogueBoxPsych_obj::DEFAULT_TEXT_Y,"DEFAULT_TEXT_Y");
	HX_MARK_MEMBER_NAME(DialogueBoxPsych_obj::LONG_TEXT_ADD,"LONG_TEXT_ADD");
	HX_MARK_MEMBER_NAME(DialogueBoxPsych_obj::LEFT_CHAR_X,"LEFT_CHAR_X");
	HX_MARK_MEMBER_NAME(DialogueBoxPsych_obj::RIGHT_CHAR_X,"RIGHT_CHAR_X");
	HX_MARK_MEMBER_NAME(DialogueBoxPsych_obj::DEFAULT_CHAR_Y,"DEFAULT_CHAR_Y");
};

#ifdef HXCPP_VISIT_ALLOCS
static void DialogueBoxPsych_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(DialogueBoxPsych_obj::DEFAULT_TEXT_X,"DEFAULT_TEXT_X");
	HX_VISIT_MEMBER_NAME(DialogueBoxPsych_obj::DEFAULT_TEXT_Y,"DEFAULT_TEXT_Y");
	HX_VISIT_MEMBER_NAME(DialogueBoxPsych_obj::LONG_TEXT_ADD,"LONG_TEXT_ADD");
	HX_VISIT_MEMBER_NAME(DialogueBoxPsych_obj::LEFT_CHAR_X,"LEFT_CHAR_X");
	HX_VISIT_MEMBER_NAME(DialogueBoxPsych_obj::RIGHT_CHAR_X,"RIGHT_CHAR_X");
	HX_VISIT_MEMBER_NAME(DialogueBoxPsych_obj::DEFAULT_CHAR_Y,"DEFAULT_CHAR_Y");
};

#endif

::hx::Class DialogueBoxPsych_obj::__mClass;

static ::String DialogueBoxPsych_obj_sStaticFields[] = {
	HX_("DEFAULT_TEXT_X",24,d8,31,6c),
	HX_("DEFAULT_TEXT_Y",25,d8,31,6c),
	HX_("LONG_TEXT_ADD",92,bc,1d,a5),
	HX_("LEFT_CHAR_X",e7,bb,19,61),
	HX_("RIGHT_CHAR_X",d2,58,47,14),
	HX_("DEFAULT_CHAR_Y",8e,06,1f,4b),
	HX_("parseDialogue",6b,64,c3,ec),
	HX_("dummy",28,0e,bb,e1),
	HX_("updateBoxOffsets",1e,ea,75,d1),
	::String(null())
};

void DialogueBoxPsych_obj::__register()
{
	DialogueBoxPsych_obj _hx_dummy;
	DialogueBoxPsych_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("cutscenes.DialogueBoxPsych",ed,41,f8,eb);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &DialogueBoxPsych_obj::__GetStatic;
	__mClass->mSetStaticField = &DialogueBoxPsych_obj::__SetStatic;
	__mClass->mMarkFunc = DialogueBoxPsych_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(DialogueBoxPsych_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(DialogueBoxPsych_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< DialogueBoxPsych_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = DialogueBoxPsych_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = DialogueBoxPsych_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = DialogueBoxPsych_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void DialogueBoxPsych_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_25_boot)
HXDLIN(  25)		DEFAULT_TEXT_X = 175;
            	}
{
            	HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_26_boot)
HXDLIN(  26)		DEFAULT_TEXT_Y = 460;
            	}
{
            	HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_27_boot)
HXDLIN(  27)		LONG_TEXT_ADD = 24;
            	}
{
            	HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_106_boot)
HXDLIN( 106)		LEFT_CHAR_X = ((Float)-60);
            	}
{
            	HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_107_boot)
HXDLIN( 107)		RIGHT_CHAR_X = ((Float)-100);
            	}
{
            	HX_STACKFRAME(&_hx_pos_abed4712cfea8e8f_108_boot)
HXDLIN( 108)		DEFAULT_CHAR_Y = ((Float)60);
            	}
}

} // end namespace cutscenes
