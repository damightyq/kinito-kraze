// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_flxanimate_motion_ColorMatrix
#include <flxanimate/motion/ColorMatrix.h>
#endif
#ifndef INCLUDED_flxanimate_motion_DynamicMatrix
#include <flxanimate/motion/DynamicMatrix.h>
#endif
#ifndef INCLUDED_openfl__Vector_FloatVector
#include <openfl/_Vector/FloatVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_IVector
#include <openfl/_Vector/IVector.h>
#endif
#ifndef INCLUDED_openfl__Vector_ObjectVector
#include <openfl/_Vector/ObjectVector.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_8_new,"flxanimate.motion.ColorMatrix","new",0xba11d0bd,"flxanimate.motion.ColorMatrix.new","flxanimate/motion/ColorMatrix.hx",8,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_28_setBrightnessMatrix,"flxanimate.motion.ColorMatrix","setBrightnessMatrix",0xe5109111,"flxanimate.motion.ColorMatrix.setBrightnessMatrix","flxanimate/motion/ColorMatrix.hx",28,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_40_setContrastMatrix,"flxanimate.motion.ColorMatrix","setContrastMatrix",0xf471d542,"flxanimate.motion.ColorMatrix.setContrastMatrix","flxanimate/motion/ColorMatrix.hx",40,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_57_setSaturationMatrix,"flxanimate.motion.ColorMatrix","setSaturationMatrix",0x824ecdd2,"flxanimate.motion.ColorMatrix.setSaturationMatrix","flxanimate/motion/ColorMatrix.hx",57,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_106_setHueMatrix,"flxanimate.motion.ColorMatrix","setHueMatrix",0x4c54a11a,"flxanimate.motion.ColorMatrix.setHueMatrix","flxanimate/motion/ColorMatrix.hx",106,0xc8e73f73)
HX_LOCAL_STACK_FRAME(_hx_pos_9ae7e77ede7af95f_179_getFlatArray,"flxanimate.motion.ColorMatrix","getFlatArray",0x1222dbad,"flxanimate.motion.ColorMatrix.getFlatArray","flxanimate/motion/ColorMatrix.hx",179,0xc8e73f73)
namespace flxanimate{
namespace motion{

void ColorMatrix_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_8_new)
HXLINE(  12)		this->lumB = ((Float)0.0820);
HXLINE(  11)		this->lumG = ((Float)0.6094);
HXLINE(  10)		this->lumR = ((Float)0.3086);
HXLINE(  20)		super::__construct(5,5);
HXLINE(  21)		this->loadIdentity();
            	}

Dynamic ColorMatrix_obj::__CreateEmpty() { return new ColorMatrix_obj; }

void *ColorMatrix_obj::_hx_vtable = 0;

Dynamic ColorMatrix_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ColorMatrix_obj > _hx_result = new ColorMatrix_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ColorMatrix_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x685fb6df) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x685fb6df;
	} else {
		return inClassId==(int)0x79460ebb;
	}
}

void ColorMatrix_obj::setBrightnessMatrix(Float value){
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_28_setBrightnessMatrix)
HXLINE(  29)		if (::hx::IsNull( this->m_matrix )) {
HXLINE(  29)			return;
            		}
HXLINE(  31)		this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->set(4,value);
HXLINE(  32)		this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->set(4,value);
HXLINE(  33)		this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->set(4,value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorMatrix_obj,setBrightnessMatrix,(void))

void ColorMatrix_obj::setContrastMatrix(Float value){
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_40_setContrastMatrix)
HXLINE(  41)		if (::hx::IsNull( this->m_matrix )) {
HXLINE(  41)			return;
            		}
HXLINE(  43)		Float brightness = (((Float)0.5) * (((Float)127.0) - value));
HXLINE(  44)		value = (value / ( (Float)(127) ));
HXLINE(  46)		this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->set(0,value);
HXLINE(  47)		this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->set(1,value);
HXLINE(  48)		this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->set(2,value);
HXLINE(  50)		this->setBrightnessMatrix(brightness);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorMatrix_obj,setContrastMatrix,(void))

void ColorMatrix_obj::setSaturationMatrix(Float value){
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_57_setSaturationMatrix)
HXLINE(  58)		if (::hx::IsNull( this->m_matrix )) {
HXLINE(  58)			return;
            		}
HXLINE(  60)		Float subVal = (((Float)1.0) - value);
HXLINE(  62)		Float mulVal = (subVal * this->lumR);
HXLINE(  63)		this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->set(0,(mulVal + value));
HXLINE(  64)		this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->set(0,mulVal);
HXLINE(  65)		this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->set(0,mulVal);
HXLINE(  67)		mulVal = (subVal * this->lumG);
HXLINE(  68)		this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->set(1,mulVal);
HXLINE(  69)		this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->set(1,(mulVal + value));
HXLINE(  70)		this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->set(1,mulVal);
HXLINE(  72)		mulVal = (subVal * this->lumB);
HXLINE(  73)		this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->set(2,mulVal);
HXLINE(  74)		this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->set(2,mulVal);
HXLINE(  75)		this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->set(2,(mulVal + value));
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorMatrix_obj,setSaturationMatrix,(void))

void ColorMatrix_obj::setHueMatrix(Float angle){
            	HX_GC_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_106_setHueMatrix)
HXLINE( 107)		if (::hx::IsNull( this->m_matrix )) {
HXLINE( 107)			return;
            		}
HXLINE( 109)		this->loadIdentity();
HXLINE( 111)		 ::flxanimate::motion::DynamicMatrix baseMat =  ::flxanimate::motion::DynamicMatrix_obj::__alloc( HX_CTX ,3,3);
HXLINE( 112)		 ::flxanimate::motion::DynamicMatrix cosBaseMat =  ::flxanimate::motion::DynamicMatrix_obj::__alloc( HX_CTX ,3,3);
HXLINE( 113)		 ::flxanimate::motion::DynamicMatrix sinBaseMat =  ::flxanimate::motion::DynamicMatrix_obj::__alloc( HX_CTX ,3,3);
HXLINE( 115)		Float cosValue = ::Math_obj::cos(angle);
HXLINE( 116)		Float sinValue = ::Math_obj::sin(angle);
HXLINE( 118)		Float lumR = ((Float)0.213);
HXLINE( 119)		Float lumG = ((Float)0.715);
HXLINE( 120)		Float lumB = ((Float)0.072);
HXLINE( 122)		baseMat->setValue(0,0,lumR);
HXLINE( 123)		baseMat->setValue(1,0,lumR);
HXLINE( 124)		baseMat->setValue(2,0,lumR);
HXLINE( 126)		baseMat->setValue(0,1,lumG);
HXLINE( 127)		baseMat->setValue(1,1,lumG);
HXLINE( 128)		baseMat->setValue(2,1,lumG);
HXLINE( 130)		baseMat->setValue(0,2,lumB);
HXLINE( 131)		baseMat->setValue(1,2,lumB);
HXLINE( 132)		baseMat->setValue(2,2,lumB);
HXLINE( 134)		cosBaseMat->setValue(0,0,(( (Float)(1) ) - lumR));
HXLINE( 135)		cosBaseMat->setValue(1,0,-(lumR));
HXLINE( 136)		cosBaseMat->setValue(2,0,-(lumR));
HXLINE( 138)		cosBaseMat->setValue(0,1,-(lumG));
HXLINE( 139)		cosBaseMat->setValue(1,1,(( (Float)(1) ) - lumG));
HXLINE( 140)		cosBaseMat->setValue(2,1,-(lumG));
HXLINE( 142)		cosBaseMat->setValue(0,2,-(lumB));
HXLINE( 143)		cosBaseMat->setValue(1,2,-(lumB));
HXLINE( 144)		cosBaseMat->setValue(2,2,(( (Float)(1) ) - lumB));
HXLINE( 146)		cosBaseMat->multiplyNumber(cosValue);
HXLINE( 148)		sinBaseMat->setValue(0,0,-(lumR));
HXLINE( 149)		sinBaseMat->setValue(1,0,((lumR - lumB) + ((Float)0.002)));
HXLINE( 150)		sinBaseMat->setValue(2,0,-((( (Float)(1) ) - lumR)));
HXLINE( 152)		sinBaseMat->setValue(0,1,-(lumG));
HXLINE( 153)		sinBaseMat->setValue(1,1,((lumR - lumB) - ((Float)0.001)));
HXLINE( 154)		sinBaseMat->setValue(2,1,lumG);
HXLINE( 156)		sinBaseMat->setValue(0,2,(( (Float)(1) ) - lumB));
HXLINE( 157)		sinBaseMat->setValue(1,2,(-((lumR + lumB)) + ((Float)0.002)));
HXLINE( 158)		sinBaseMat->setValue(2,2,lumB);
HXLINE( 160)		sinBaseMat->multiplyNumber(sinValue);
HXLINE( 162)		baseMat->add(cosBaseMat);
HXLINE( 163)		baseMat->add(sinBaseMat);
HXLINE( 165)		{
HXLINE( 167)			{
HXLINE( 169)				{
HXLINE( 169)					::Dynamic this1 = this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >();
HXDLIN( 169)					( ( ::openfl::_Vector::FloatVector)(this1) )->set(0,baseMat->getValue(0,0));
            				}
HXDLIN( 169)				{
HXLINE( 169)					::Dynamic this2 = this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >();
HXDLIN( 169)					( ( ::openfl::_Vector::FloatVector)(this2) )->set(1,baseMat->getValue(0,1));
            				}
HXDLIN( 169)				{
HXLINE( 169)					::Dynamic this3 = this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >();
HXDLIN( 169)					( ( ::openfl::_Vector::FloatVector)(this3) )->set(2,baseMat->getValue(0,2));
            				}
            			}
HXLINE( 167)			{
HXLINE( 169)				{
HXLINE( 169)					::Dynamic this4 = this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >();
HXDLIN( 169)					( ( ::openfl::_Vector::FloatVector)(this4) )->set(0,baseMat->getValue(1,0));
            				}
HXDLIN( 169)				{
HXLINE( 169)					::Dynamic this5 = this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >();
HXDLIN( 169)					( ( ::openfl::_Vector::FloatVector)(this5) )->set(1,baseMat->getValue(1,1));
            				}
HXDLIN( 169)				{
HXLINE( 169)					::Dynamic this6 = this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >();
HXDLIN( 169)					( ( ::openfl::_Vector::FloatVector)(this6) )->set(2,baseMat->getValue(1,2));
            				}
            			}
HXLINE( 167)			{
HXLINE( 169)				{
HXLINE( 169)					::Dynamic this7 = this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >();
HXDLIN( 169)					( ( ::openfl::_Vector::FloatVector)(this7) )->set(0,baseMat->getValue(2,0));
            				}
HXDLIN( 169)				{
HXLINE( 169)					::Dynamic this8 = this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >();
HXDLIN( 169)					( ( ::openfl::_Vector::FloatVector)(this8) )->set(1,baseMat->getValue(2,1));
            				}
HXDLIN( 169)				{
HXLINE( 169)					::Dynamic this9 = this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >();
HXDLIN( 169)					( ( ::openfl::_Vector::FloatVector)(this9) )->set(2,baseMat->getValue(2,2));
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorMatrix_obj,setHueMatrix,(void))

::Array< Float > ColorMatrix_obj::getFlatArray(){
            	HX_STACKFRAME(&_hx_pos_9ae7e77ede7af95f_179_getFlatArray)
HXLINE( 180)		if (::hx::IsNull( this->m_matrix )) {
HXLINE( 180)			return null();
            		}
HXLINE( 182)		int index = 0;
HXLINE( 183)		::Array< Float > ptr = ::Array_obj< Float >::__new(0);
HXLINE( 184)		{
HXLINE( 186)			{
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->get(0);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->get(1);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->get(2);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->get(3);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(0).StaticCast<  ::openfl::_Vector::FloatVector >()->get(4);
HXLINE( 190)					index = (index + 1);
            				}
            			}
HXLINE( 186)			{
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->get(0);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->get(1);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->get(2);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->get(3);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(1).StaticCast<  ::openfl::_Vector::FloatVector >()->get(4);
HXLINE( 190)					index = (index + 1);
            				}
            			}
HXLINE( 186)			{
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->get(0);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->get(1);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->get(2);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->get(3);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(2).StaticCast<  ::openfl::_Vector::FloatVector >()->get(4);
HXLINE( 190)					index = (index + 1);
            				}
            			}
HXLINE( 186)			{
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(3).StaticCast<  ::openfl::_Vector::FloatVector >()->get(0);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(3).StaticCast<  ::openfl::_Vector::FloatVector >()->get(1);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(3).StaticCast<  ::openfl::_Vector::FloatVector >()->get(2);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(3).StaticCast<  ::openfl::_Vector::FloatVector >()->get(3);
HXLINE( 190)					index = (index + 1);
            				}
HXLINE( 187)				{
HXLINE( 188)					ptr[index] = this->m_matrix->get(3).StaticCast<  ::openfl::_Vector::FloatVector >()->get(4);
HXLINE( 190)					index = (index + 1);
            				}
            			}
            		}
HXLINE( 194)		return ptr;
            	}


HX_DEFINE_DYNAMIC_FUNC0(ColorMatrix_obj,getFlatArray,return )


::hx::ObjectPtr< ColorMatrix_obj > ColorMatrix_obj::__new() {
	::hx::ObjectPtr< ColorMatrix_obj > __this = new ColorMatrix_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< ColorMatrix_obj > ColorMatrix_obj::__alloc(::hx::Ctx *_hx_ctx) {
	ColorMatrix_obj *__this = (ColorMatrix_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ColorMatrix_obj), true, "flxanimate.motion.ColorMatrix"));
	*(void **)__this = ColorMatrix_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

ColorMatrix_obj::ColorMatrix_obj()
{
}

::hx::Val ColorMatrix_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"lumR") ) { return ::hx::Val( lumR ); }
		if (HX_FIELD_EQ(inName,"lumG") ) { return ::hx::Val( lumG ); }
		if (HX_FIELD_EQ(inName,"lumB") ) { return ::hx::Val( lumB ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"setHueMatrix") ) { return ::hx::Val( setHueMatrix_dyn() ); }
		if (HX_FIELD_EQ(inName,"getFlatArray") ) { return ::hx::Val( getFlatArray_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"setContrastMatrix") ) { return ::hx::Val( setContrastMatrix_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"setBrightnessMatrix") ) { return ::hx::Val( setBrightnessMatrix_dyn() ); }
		if (HX_FIELD_EQ(inName,"setSaturationMatrix") ) { return ::hx::Val( setSaturationMatrix_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ColorMatrix_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"lumR") ) { lumR=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lumG") ) { lumG=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lumB") ) { lumB=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ColorMatrix_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("lumR",0e,32,bc,47));
	outFields->push(HX_("lumG",03,32,bc,47));
	outFields->push(HX_("lumB",fe,31,bc,47));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ColorMatrix_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(ColorMatrix_obj,lumR),HX_("lumR",0e,32,bc,47)},
	{::hx::fsFloat,(int)offsetof(ColorMatrix_obj,lumG),HX_("lumG",03,32,bc,47)},
	{::hx::fsFloat,(int)offsetof(ColorMatrix_obj,lumB),HX_("lumB",fe,31,bc,47)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ColorMatrix_obj_sStaticStorageInfo = 0;
#endif

static ::String ColorMatrix_obj_sMemberFields[] = {
	HX_("lumR",0e,32,bc,47),
	HX_("lumG",03,32,bc,47),
	HX_("lumB",fe,31,bc,47),
	HX_("setBrightnessMatrix",b4,46,bf,bc),
	HX_("setContrastMatrix",25,cc,ca,ca),
	HX_("setSaturationMatrix",75,83,fd,59),
	HX_("setHueMatrix",17,15,c5,52),
	HX_("getFlatArray",aa,4f,93,18),
	::String(null()) };

::hx::Class ColorMatrix_obj::__mClass;

void ColorMatrix_obj::__register()
{
	ColorMatrix_obj _hx_dummy;
	ColorMatrix_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flxanimate.motion.ColorMatrix",4b,ae,d9,d2);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ColorMatrix_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ColorMatrix_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ColorMatrix_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ColorMatrix_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flxanimate
} // end namespace motion
