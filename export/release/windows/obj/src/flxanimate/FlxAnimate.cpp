// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxImageFrame
#include <flixel/graphics/frames/FlxImageFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_LogFrontEnd
#include <flixel/system/frontEnds/LogFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxSignal
#include <flixel/util/IFlxSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxBaseSignal
#include <flixel/util/_FlxSignal/FlxBaseSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal0
#include <flixel/util/_FlxSignal/FlxSignal0.h>
#endif
#ifndef INCLUDED_flxanimate_FlxAnimate
#include <flxanimate/FlxAnimate.h>
#endif
#ifndef INCLUDED_flxanimate_animate_ButtonEvent
#include <flxanimate/animate/ButtonEvent.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxAnim
#include <flxanimate/animate/FlxAnim.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxElement
#include <flxanimate/animate/FlxElement.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxKeyFrame
#include <flxanimate/animate/FlxKeyFrame.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxLayer
#include <flxanimate/animate/FlxLayer.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxMetaData
#include <flxanimate/animate/FlxMetaData.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxSymbol
#include <flxanimate/animate/FlxSymbol.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxTimeline
#include <flxanimate/animate/FlxTimeline.h>
#endif
#ifndef INCLUDED_flxanimate_animate_SymbolParameters
#include <flxanimate/animate/SymbolParameters.h>
#endif
#ifndef INCLUDED_flxanimate_data_LayerType
#include <flxanimate/data/LayerType.h>
#endif
#ifndef INCLUDED_flxanimate_data_SymbolT
#include <flxanimate/data/SymbolT.h>
#endif
#ifndef INCLUDED_flxanimate_display_FlxAnimateFilterRenderer
#include <flxanimate/display/FlxAnimateFilterRenderer.h>
#endif
#ifndef INCLUDED_flxanimate_effects_FlxColorEffect
#include <flxanimate/effects/FlxColorEffect.h>
#endif
#ifndef INCLUDED_flxanimate_frames_FlxAnimateFrames
#include <flxanimate/frames/FlxAnimateFrames.h>
#endif
#ifndef INCLUDED_flxanimate_interfaces_IFilterable
#include <flxanimate/interfaces/IFilterable.h>
#endif
#ifndef INCLUDED_flxanimate_zip_Zip
#include <flxanimate/zip/Zip.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_List
#include <haxe/ds/List.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_ds__List_ListNode
#include <haxe/ds/_List/ListNode.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Path
#include <haxe/io/Path.h>
#endif
#ifndef INCLUDED_lime_utils_ObjectPool
#include <lime/utils/ObjectPool.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_filters_BitmapFilter
#include <openfl/filters/BitmapFilter.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_utils_Assets
#include <openfl/utils/Assets.h>
#endif
#ifndef INCLUDED_openfl_utils_ByteArrayData
#include <openfl/utils/ByteArrayData.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataInput
#include <openfl/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataOutput
#include <openfl/utils/IDataOutput.h>
#endif
#ifndef INCLUDED_openfl_utils__ByteArray_ByteArray_Impl_
#include <openfl/utils/_ByteArray/ByteArray_Impl_.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_5067d88e43c2dc01_51_new,"flxanimate.FlxAnimate","new",0x7e9fba00,"flxanimate.FlxAnimate.new","flxanimate/FlxAnimate.hx",51,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_109_loadAtlas,"flxanimate.FlxAnimate","loadAtlas",0x111f7ae5,"flxanimate.FlxAnimate.loadAtlas","flxanimate/FlxAnimate.hx",109,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_123_loadSeparateAtlas,"flxanimate.FlxAnimate","loadSeparateAtlas",0x63e34e82,"flxanimate.FlxAnimate.loadSeparateAtlas","flxanimate/FlxAnimate.hx",123,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_196_draw,"flxanimate.FlxAnimate","draw",0x4690ae64,"flxanimate.FlxAnimate.draw","flxanimate/FlxAnimate.hx",196,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_233_parseElement,"flxanimate.FlxAnimate","parseElement",0x3628e529,"flxanimate.FlxAnimate.parseElement","flxanimate/FlxAnimate.hx",233,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_391_renderLayer,"flxanimate.FlxAnimate","renderLayer",0x0c30383b,"flxanimate.FlxAnimate.renderLayer","flxanimate/FlxAnimate.hx",391,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_395_renderFilter,"flxanimate.FlxAnimate","renderFilter",0xca85060e,"flxanimate.FlxAnimate.renderFilter","flxanimate/FlxAnimate.hx",395,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_475_setButtonFrames,"flxanimate.FlxAnimate","setButtonFrames",0x804d339a,"flxanimate.FlxAnimate.setButtonFrames","flxanimate/FlxAnimate.hx",475,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_520_drawLimb,"flxanimate.FlxAnimate","drawLimb",0x4e1df396,"flxanimate.FlxAnimate.drawLimb","flxanimate/FlxAnimate.hx",520,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_614_limbOnScreen,"flxanimate.FlxAnimate","limbOnScreen",0x0ed1497d,"flxanimate.FlxAnimate.limbOnScreen","flxanimate/FlxAnimate.hx",614,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_634_destroy,"flxanimate.FlxAnimate","destroy",0xa197669a,"flxanimate.FlxAnimate.destroy","flxanimate/FlxAnimate.hx",634,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_648_updateAnimation,"flxanimate.FlxAnimate","updateAnimation",0xa813995b,"flxanimate.FlxAnimate.updateAnimation","flxanimate/FlxAnimate.hx",648,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_654_setButtonPack,"flxanimate.FlxAnimate","setButtonPack",0xba6cb5cd,"flxanimate.FlxAnimate.setButtonPack","flxanimate/FlxAnimate.hx",654,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_658_set_showPivot,"flxanimate.FlxAnimate","set_showPivot",0x5c1c9808,"flxanimate.FlxAnimate.set_showPivot","flxanimate/FlxAnimate.hx",658,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_681_setTheSettings,"flxanimate.FlxAnimate","setTheSettings",0x7af46852,"flxanimate.FlxAnimate.setTheSettings","flxanimate/FlxAnimate.hx",681,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_710_atlasSetting,"flxanimate.FlxAnimate","atlasSetting",0xd7d0ade5,"flxanimate.FlxAnimate.atlasSetting","flxanimate/FlxAnimate.hx",710,0x8666d8cf)
HX_LOCAL_STACK_FRAME(_hx_pos_5067d88e43c2dc01_707_fromSettings,"flxanimate.FlxAnimate","fromSettings",0x014e3acd,"flxanimate.FlxAnimate.fromSettings","flxanimate/FlxAnimate.hx",707,0x8666d8cf)
namespace flxanimate{

void FlxAnimate_obj::__construct(::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y,::String Path, ::Dynamic Settings){
            		Float X = __o_X.Default(0);
            		Float Y = __o_Y.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_51_new)
HXLINE( 518)		this->_mat =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 473)		this->pressed = false;
HXLINE( 231)		this->st = 0;
HXLINE(  76)		this->relativeY = ((Float)0);
HXLINE(  74)		this->relativeX = ((Float)0);
HXLINE(  70)		this->renderer =  ::flxanimate::display::FlxAnimateFilterRenderer_obj::__alloc( HX_CTX );
HXLINE(  63)		this->filters = null();
HXLINE(  92)		super::__construct(X,Y,null());
HXLINE(  93)		this->anim =  ::flxanimate::animate::FlxAnim_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this),null());
HXLINE(  94)		this->set_showPivot(false);
HXLINE(  95)		if (::hx::IsNotNull( Path )) {
HXLINE(  96)			this->loadAtlas(Path);
            		}
HXLINE(  97)		if (::hx::IsNotNull( Settings )) {
HXLINE(  98)			this->setTheSettings(Settings);
            		}
HXLINE( 101)		this->rect = ::openfl::geom::Rectangle_obj::_hx___pool->get().StaticCast<  ::openfl::geom::Rectangle >();
            	}

Dynamic FlxAnimate_obj::__CreateEmpty() { return new FlxAnimate_obj; }

void *FlxAnimate_obj::_hx_vtable = 0;

Dynamic FlxAnimate_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxAnimate_obj > _hx_result = new FlxAnimate_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool FlxAnimate_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2c01639b) {
		if (inClassId<=(int)0x0943d942) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0943d942;
		} else {
			return inClassId==(int)0x2c01639b;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void FlxAnimate_obj::loadAtlas(::String Path){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_109_loadAtlas)
HXLINE( 110)		bool _hx_tmp;
HXDLIN( 110)		if (!(::openfl::utils::Assets_obj::exists(((HX_("",00,00,00,00) + Path) + HX_("/Animation.json",61,fc,54,44)),null()))) {
HXLINE( 110)			_hx_tmp = (::haxe::io::Path_obj::extension(Path) != HX_("zip",e1,ee,5c,00));
            		}
            		else {
HXLINE( 110)			_hx_tmp = false;
            		}
HXDLIN( 110)		if (_hx_tmp) {
HXLINE( 112)			::flixel::FlxG_obj::log->advanced(((HX_("Animation file not found in specified path: \"",bf,3c,8d,58) + Path) + HX_("\", have you written the correct path?",a9,4e,46,6b)),::flixel::_hx_system::debug::log::LogStyle_obj::ERROR,true);
HXLINE( 113)			return;
            		}
HXLINE( 115)		::String _hx_tmp1 = this->atlasSetting(Path);
HXDLIN( 115)		this->loadSeparateAtlas(_hx_tmp1,::flxanimate::frames::FlxAnimateFrames_obj::fromTextureAtlas(Path));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAnimate_obj,loadAtlas,(void))

void FlxAnimate_obj::loadSeparateAtlas(::String animation, ::flixel::graphics::frames::FlxFramesCollection frames){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_123_loadSeparateAtlas)
HXLINE( 124)		if (::hx::IsNotNull( frames )) {
HXLINE( 125)			this->set_frames(frames);
            		}
HXLINE( 126)		if (::hx::IsNotNull( animation )) {
HXLINE( 184)			 ::Dynamic json =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,animation)->doParse();
HXLINE( 186)			this->anim->_loadAtlas(json);
            		}
HXLINE( 188)		if (::hx::IsNotNull( this->anim )) {
HXLINE( 189)			this->origin = this->anim->curInstance->symbol->transformationPoint;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxAnimate_obj,loadSeparateAtlas,(void))

void FlxAnimate_obj::draw(){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_196_draw)
HXLINE( 197)		this->_matrix->identity();
HXLINE( 198)		if (this->flipX) {
HXLINE( 200)			 ::flixel::math::FlxMatrix fh = this->_matrix;
HXDLIN( 200)			fh->a = (fh->a * ( (Float)(-1) ));
HXLINE( 202)			 ::flixel::math::FlxMatrix fh1 = this->_matrix;
HXDLIN( 202)			Float fh2 = fh1->tx;
HXDLIN( 202)			fh1->tx = (fh2 + this->get_width());
            		}
HXLINE( 205)		if (this->flipY) {
HXLINE( 207)			 ::flixel::math::FlxMatrix fh3 = this->_matrix;
HXDLIN( 207)			fh3->d = (fh3->d * ( (Float)(-1) ));
HXLINE( 208)			 ::flixel::math::FlxMatrix fh4 = this->_matrix;
HXDLIN( 208)			Float fh5 = fh4->ty;
HXDLIN( 208)			fh4->ty = (fh5 + this->get_height());
            		}
HXLINE( 211)		this->_flashRect->setEmpty();
HXLINE( 214)		 ::flxanimate::animate::FlxElement _hx_tmp = this->anim->curInstance;
HXDLIN( 214)		 ::flixel::math::FlxMatrix _hx_tmp1 = this->_matrix;
HXDLIN( 214)		 ::openfl::geom::ColorTransform _hx_tmp2 = this->colorTransform;
HXDLIN( 214)		::Array< ::Dynamic> _hx_tmp3 = this->get_cameras();
HXDLIN( 214)		this->parseElement(_hx_tmp,_hx_tmp1,_hx_tmp2,null(),_hx_tmp3,this->scrollFactor);
HXLINE( 216)		this->set_width(this->_flashRect->width);
HXLINE( 217)		this->set_height(this->_flashRect->height);
HXLINE( 218)		this->frameWidth = ::Math_obj::round(this->get_width());
HXLINE( 219)		this->frameHeight = ::Math_obj::round(this->get_height());
HXLINE( 221)		this->relativeX = (this->_flashRect->x - this->x);
HXLINE( 222)		this->relativeY = (this->_flashRect->y - this->y);
HXLINE( 224)		if (this->showPivot) {
HXLINE( 226)			 ::flixel::graphics::frames::FlxFrame _hx_tmp4 = this->_pivot;
HXDLIN( 226)			 ::flixel::math::FlxMatrix _hx_tmp5 =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,1,0,0,1,(this->origin->x - (this->_pivot->frame->width * ((Float)0.5))),(this->origin->y - (this->_pivot->frame->height * ((Float)0.5))));
HXDLIN( 226)			this->drawLimb(_hx_tmp4,_hx_tmp5,null(),null(),null(),null(),this->get_cameras());
HXLINE( 227)			 ::flixel::graphics::frames::FlxFrame _hx_tmp6 = this->_indicator;
HXDLIN( 227)			 ::flixel::math::FlxMatrix _hx_tmp7 =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,1,0,0,1,(-(this->_indicator->frame->width) * ((Float)0.5)),(-(this->_indicator->frame->height) * ((Float)0.5)));
HXDLIN( 227)			this->drawLimb(_hx_tmp6,_hx_tmp7,null(),null(),null(),null(),this->get_cameras());
            		}
            	}


void FlxAnimate_obj::parseElement( ::flxanimate::animate::FlxElement instance, ::flixel::math::FlxMatrix m, ::openfl::geom::ColorTransform colorFilter, ::Dynamic filterInstance,::Array< ::Dynamic> cameras, ::flixel::math::FlxBasePoint scrollFactor){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_233_parseElement)
HXLINE( 234)		bool _hx_tmp;
HXDLIN( 234)		if (::hx::IsNotNull( instance )) {
HXLINE( 234)			_hx_tmp = !(instance->visible);
            		}
            		else {
HXLINE( 234)			_hx_tmp = true;
            		}
HXDLIN( 234)		if (_hx_tmp) {
HXLINE( 235)			return;
            		}
HXLINE( 237)		bool mainSymbol = ::hx::IsInstanceEq( instance,this->anim->curInstance );
HXLINE( 238)		bool filterin = ::hx::IsNotNull( filterInstance );
HXLINE( 240)		bool skipFilters = this->anim->metadata->skipFilters;
HXLINE( 242)		if (::hx::IsNull( cameras )) {
HXLINE( 243)			cameras = this->get_cameras();
            		}
HXLINE( 251)		 ::flixel::math::FlxMatrix matrix = instance->_matrix;
HXLINE( 253)		matrix->copyFrom(instance->matrix);
HXLINE( 254)		matrix->translate(instance->x,instance->y);
HXLINE( 255)		matrix->concat(m);
HXLINE( 258)		 ::openfl::geom::ColorTransform colorEffect = instance->_color;
HXLINE( 259)		colorEffect->_hx___copyFrom(colorFilter);
HXLINE( 262)		 ::flxanimate::animate::FlxSymbol symbol;
HXDLIN( 262)		if (::hx::IsNotNull( instance->symbol )) {
HXLINE( 262)			symbol = ( ( ::flxanimate::animate::FlxSymbol)(this->anim->symbolDictionary->get(instance->symbol->name)) );
            		}
            		else {
HXLINE( 262)			symbol = null();
            		}
HXLINE( 264)		bool _hx_tmp1;
HXDLIN( 264)		if (::hx::IsNull( instance->bitmap )) {
HXLINE( 264)			_hx_tmp1 = ::hx::IsNull( symbol );
            		}
            		else {
HXLINE( 264)			_hx_tmp1 = false;
            		}
HXDLIN( 264)		if (_hx_tmp1) {
HXLINE( 265)			return;
            		}
HXLINE( 267)		if (::hx::IsNotNull( instance->bitmap )) {
HXLINE( 269)			this->drawLimb(( ( ::flixel::graphics::frames::FlxFrame)(this->frames->framesByName->get(instance->bitmap)) ),matrix,colorEffect,filterin,null(),null(),cameras);
HXLINE( 270)			return;
            		}
HXLINE( 272)		bool cacheToBitmap;
HXDLIN( 272)		bool cacheToBitmap1;
HXDLIN( 272)		if (!(skipFilters)) {
HXLINE( 272)			if (!(instance->symbol->get_cacheAsBitmap())) {
HXLINE( 272)				if (::hx::IsNotNull( this->filters )) {
HXLINE( 272)					cacheToBitmap1 = mainSymbol;
            				}
            				else {
HXLINE( 272)					cacheToBitmap1 = false;
            				}
            			}
            			else {
HXLINE( 272)				cacheToBitmap1 = true;
            			}
            		}
            		else {
HXLINE( 272)			cacheToBitmap1 = false;
            		}
HXDLIN( 272)		if (cacheToBitmap1) {
HXLINE( 272)			if (filterin) {
HXLINE( 272)				if (filterin) {
HXLINE( 272)					cacheToBitmap = ::hx::IsInstanceNotEq( filterInstance->__Field(HX_("instance",95,1f,e1,59),::hx::paccDynamic),instance );
            				}
            				else {
HXLINE( 272)					cacheToBitmap = false;
            				}
            			}
            			else {
HXLINE( 272)				cacheToBitmap = true;
            			}
            		}
            		else {
HXLINE( 272)			cacheToBitmap = false;
            		}
HXLINE( 274)		if (cacheToBitmap) {
HXLINE( 276)			if (instance->symbol->_renderDirty) {
HXLINE( 278)				if (::hx::IsNull( this->filterCamera )) {
HXLINE( 279)					instance->symbol->_filterCamera =  ::flixel::FlxCamera_obj::__alloc( HX_CTX ,0,0,0,0,1);
            				}
HXLINE( 281)				instance->symbol->_filterMatrix->copyFrom(instance->symbol->cacheAsBitmapMatrix);
HXLINE( 283)				 ::flixel::math::FlxMatrix instance1 = instance->symbol->_filterMatrix;
HXDLIN( 283)				this->parseElement(instance,instance1, ::openfl::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null()), ::Dynamic(::hx::Anon_obj::Create(1)
            					->setFixed(0,HX_("instance",95,1f,e1,59),instance)),::Array_obj< ::Dynamic>::__new(1)->init(0,instance->symbol->_filterCamera),null());
HXLINE( 287)				this->renderFilter(instance->symbol,instance->symbol->filters,this->renderer,null());
HXLINE( 288)				instance->symbol->_renderDirty = false;
            			}
HXLINE( 291)			if (::hx::IsNotNull( instance->symbol->_filterFrame )) {
HXLINE( 293)				if (::hx::IsNotNull( instance->symbol->colorEffect )) {
HXLINE( 294)					colorEffect->concat(instance->symbol->colorEffect->c_Transform);
            				}
HXLINE( 296)				matrix->copyFrom(instance->symbol->_filterMatrix);
HXLINE( 297)				matrix->concat(m);
HXLINE( 300)				this->drawLimb(instance->symbol->_filterFrame,matrix,colorEffect,filterin,instance->symbol->blendMode,null(),cameras);
            			}
            		}
            		else {
HXLINE( 305)			bool _hx_tmp2;
HXDLIN( 305)			if (::hx::IsNotNull( instance->symbol->colorEffect )) {
HXLINE( 305)				if (filterin) {
HXLINE( 305)					if (filterin) {
HXLINE( 305)						_hx_tmp2 = ::hx::IsInstanceNotEq( filterInstance->__Field(HX_("instance",95,1f,e1,59),::hx::paccDynamic),instance );
            					}
            					else {
HXLINE( 305)						_hx_tmp2 = false;
            					}
            				}
            				else {
HXLINE( 305)					_hx_tmp2 = true;
            				}
            			}
            			else {
HXLINE( 305)				_hx_tmp2 = false;
            			}
HXDLIN( 305)			if (_hx_tmp2) {
HXLINE( 306)				colorEffect->concat(instance->symbol->colorEffect->c_Transform);
            			}
HXLINE( 308)			int firstFrame = instance->symbol->_curFrame;
HXLINE( 309)			if ((instance->symbol->type->_hx_getIndex() == 2)) {
HXLINE( 311)				firstFrame = this->setButtonFrames(firstFrame);
            			}
HXLINE( 315)			::Array< ::Dynamic> layers = symbol->timeline->getList();
HXLINE( 317)			{
HXLINE( 317)				int _g = 0;
HXDLIN( 317)				int _g1 = layers->length;
HXDLIN( 317)				while((_g < _g1)){
HXLINE( 317)					_g = (_g + 1);
HXDLIN( 317)					int i = (_g - 1);
HXLINE( 319)					 ::flxanimate::animate::FlxLayer layer = layers->__get(((layers->length - 1) - i)).StaticCast<  ::flxanimate::animate::FlxLayer >();
HXLINE( 321)					bool _hx_tmp3;
HXDLIN( 321)					bool _hx_tmp4;
HXDLIN( 321)					if (!(layer->visible)) {
HXLINE( 321)						bool _hx_tmp5;
HXDLIN( 321)						if (!(filterin)) {
HXLINE( 321)							_hx_tmp5 = mainSymbol;
            						}
            						else {
HXLINE( 321)							_hx_tmp5 = false;
            						}
HXDLIN( 321)						if (!(_hx_tmp5)) {
HXLINE( 321)							_hx_tmp4 = !(this->anim->metadata->showHiddenLayers);
            						}
            						else {
HXLINE( 321)							_hx_tmp4 = true;
            						}
            					}
            					else {
HXLINE( 321)						_hx_tmp4 = false;
            					}
HXDLIN( 321)					if (!(_hx_tmp4)) {
HXLINE( 321)						if (::hx::IsPointerEq( layer->type,::flxanimate::data::LayerType_obj::Clipper_dyn() )) {
HXLINE( 321)							_hx_tmp3 = layer->_correctClip;
            						}
            						else {
HXLINE( 321)							_hx_tmp3 = false;
            						}
            					}
            					else {
HXLINE( 321)						_hx_tmp3 = true;
            					}
HXDLIN( 321)					if (_hx_tmp3) {
HXLINE( 321)						continue;
            					}
HXLINE( 323)					if (::hx::IsNotNull( layer->_clipper )) {
HXLINE( 325)						 ::flxanimate::animate::FlxLayer layer1 = layer->_clipper;
HXLINE( 326)						layer1->_setCurFrame(firstFrame);
HXLINE( 327)						 ::flxanimate::animate::FlxKeyFrame frame = layer1->_currFrame;
HXLINE( 328)						if (::hx::IsNull( layer1->_filterCamera )) {
HXLINE( 329)							layer1->_filterCamera =  ::flixel::FlxCamera_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null());
            						}
HXLINE( 330)						if (frame->_renderDirty) {
HXLINE( 332)							{
HXLINE( 332)								 ::flixel::math::FlxMatrix matrix1 =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXDLIN( 332)								 ::openfl::geom::ColorTransform colorEffect1 =  ::openfl::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
HXDLIN( 332)								 ::Dynamic instance2 =  ::Dynamic(::hx::Anon_obj::Create(1)
            									->setFixed(0,HX_("instance",95,1f,e1,59),null()));
HXDLIN( 332)								::Array< ::Dynamic> cameras1 = ::Array_obj< ::Dynamic>::__new(1)->init(0,layer1->_filterCamera);
HXDLIN( 332)								{
HXLINE( 332)									int _g2 = 0;
HXDLIN( 332)									::Array< ::Dynamic> _g3 = frame->getList();
HXDLIN( 332)									while((_g2 < _g3->length)){
HXLINE( 332)										 ::flxanimate::animate::FlxElement element = _g3->__get(_g2).StaticCast<  ::flxanimate::animate::FlxElement >();
HXDLIN( 332)										_g2 = (_g2 + 1);
HXDLIN( 332)										this->parseElement(element,matrix1,colorEffect1,instance2,cameras1,null());
            									}
            								}
            							}
HXLINE( 334)							layer1->_filterMatrix->identity();
HXLINE( 336)							frame->_renderDirty = false;
            						}
            					}
HXLINE( 340)					layer->_setCurFrame(firstFrame);
HXLINE( 342)					 ::flxanimate::animate::FlxKeyFrame frame1 = layer->_currFrame;
HXLINE( 344)					if (::hx::IsNull( frame1 )) {
HXLINE( 344)						continue;
            					}
HXLINE( 346)					bool toBitmap;
HXDLIN( 346)					if (::hx::IsNull( frame1->filters )) {
HXLINE( 346)						toBitmap = (::Type_obj::enumConstructor(layer->type) == HX_("Clipped",df,2f,19,d0));
            					}
            					else {
HXLINE( 346)						toBitmap = true;
            					}
HXLINE( 348)					if (skipFilters) {
HXLINE( 349)						toBitmap = false;
            					}
HXLINE( 350)					 ::openfl::geom::ColorTransform coloreffect =  ::openfl::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
HXLINE( 351)					coloreffect->_hx___copyFrom(colorEffect);
HXLINE( 352)					if (::hx::IsNotNull( frame1->colorEffect )) {
HXLINE( 353)						coloreffect->concat(frame1->colorEffect->_hx___create());
            					}
HXLINE( 355)					if (toBitmap) {
HXLINE( 357)						bool _hx_tmp6;
HXDLIN( 357)						if (!(frame1->_renderDirty)) {
HXLINE( 357)							_hx_tmp6 = ::hx::IsNotNull( layer->_filterFrame );
            						}
            						else {
HXLINE( 357)							_hx_tmp6 = false;
            						}
HXDLIN( 357)						if (_hx_tmp6) {
HXLINE( 359)							 ::flixel::math::FlxMatrix mat =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 360)							mat->copyFrom(layer->_filterMatrix);
HXLINE( 361)							mat->concat(matrix);
HXLINE( 363)							this->drawLimb(layer->_filterFrame,mat,coloreffect,filterin,null(),null(),cameras);
HXLINE( 364)							continue;
            						}
            						else {
HXLINE( 366)							if (::hx::IsNull( layer->_filterCamera )) {
HXLINE( 367)								layer->_filterCamera =  ::flixel::FlxCamera_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null());
            							}
            						}
            					}
HXLINE( 370)					{
HXLINE( 370)						 ::flixel::math::FlxMatrix matrix2;
HXDLIN( 370)						if (toBitmap) {
HXLINE( 370)							matrix2 =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
            						}
            						else {
HXLINE( 370)							matrix2 = matrix;
            						}
HXDLIN( 370)						 ::Dynamic instance3;
HXDLIN( 370)						if (toBitmap) {
HXLINE( 370)							instance3 =  ::Dynamic(::hx::Anon_obj::Create(1)
            								->setFixed(0,HX_("instance",95,1f,e1,59),null()));
            						}
            						else {
HXLINE( 370)							instance3 = filterInstance;
            						}
HXDLIN( 370)						::Array< ::Dynamic> cameras2;
HXDLIN( 370)						if (toBitmap) {
HXLINE( 370)							cameras2 = ::Array_obj< ::Dynamic>::__new(1)->init(0,layer->_filterCamera);
            						}
            						else {
HXLINE( 370)							cameras2 = cameras;
            						}
HXDLIN( 370)						{
HXLINE( 370)							int _g4 = 0;
HXDLIN( 370)							::Array< ::Dynamic> _g5 = frame1->getList();
HXDLIN( 370)							while((_g4 < _g5->length)){
HXLINE( 370)								 ::flxanimate::animate::FlxElement element1 = _g5->__get(_g4).StaticCast<  ::flxanimate::animate::FlxElement >();
HXDLIN( 370)								_g4 = (_g4 + 1);
HXDLIN( 370)								this->parseElement(element1,matrix2,coloreffect,instance3,cameras2,null());
            							}
            						}
            					}
HXLINE( 372)					if (toBitmap) {
HXLINE( 374)						layer->_filterMatrix->identity();
HXLINE( 376)						 ::flixel::FlxCamera _hx_tmp7;
HXDLIN( 376)						if (::hx::IsNotNull( layer->_clipper )) {
HXLINE( 376)							_hx_tmp7 = layer->_clipper->_filterCamera;
            						}
            						else {
HXLINE( 376)							_hx_tmp7 = null();
            						}
HXDLIN( 376)						this->renderFilter(layer,frame1->filters,this->renderer,_hx_tmp7);
HXLINE( 378)						frame1->_renderDirty = false;
HXLINE( 380)						 ::flixel::math::FlxMatrix mat1 =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 381)						mat1->copyFrom(layer->_filterMatrix);
HXLINE( 382)						mat1->concat(matrix);
HXLINE( 384)						this->drawLimb(layer->_filterFrame,mat1,coloreffect,filterin,null(),null(),cameras);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC6(FlxAnimate_obj,parseElement,(void))

void FlxAnimate_obj::renderLayer( ::flxanimate::animate::FlxKeyFrame frame, ::flixel::math::FlxMatrix matrix, ::openfl::geom::ColorTransform colorEffect, ::Dynamic instance,::Array< ::Dynamic> cameras){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_391_renderLayer)
HXDLIN( 391)		int _g = 0;
HXDLIN( 391)		::Array< ::Dynamic> _g1 = frame->getList();
HXDLIN( 391)		while((_g < _g1->length)){
HXDLIN( 391)			 ::flxanimate::animate::FlxElement element = _g1->__get(_g).StaticCast<  ::flxanimate::animate::FlxElement >();
HXDLIN( 391)			_g = (_g + 1);
HXLINE( 392)			this->parseElement(element,matrix,colorEffect,instance,cameras,null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxAnimate_obj,renderLayer,(void))

void FlxAnimate_obj::renderFilter(::Dynamic filterInstance,::Array< ::Dynamic> filters, ::flxanimate::display::FlxAnimateFilterRenderer renderer, ::flixel::FlxCamera mask){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_395_renderFilter)
HXLINE( 396)		bool masking = ::hx::IsNotNull( mask );
HXLINE( 397)		 ::flixel::FlxCamera filterCamera = ( ( ::flixel::FlxCamera)(filterInstance->__Field(HX_("_filterCamera",5c,07,53,a6),::hx::paccDynamic)) );
HXLINE( 398)		filterCamera->render();
HXLINE( 400)		 ::openfl::geom::Rectangle rect = filterCamera->canvas->getBounds(null());
HXLINE( 402)		bool _hx_tmp;
HXDLIN( 402)		if (::hx::IsNotNull( filters )) {
HXLINE( 402)			_hx_tmp = (filters->length > 0);
            		}
            		else {
HXLINE( 402)			_hx_tmp = false;
            		}
HXDLIN( 402)		if (_hx_tmp) {
HXLINE( 404)			 ::openfl::geom::Rectangle extension = ::openfl::geom::Rectangle_obj::_hx___pool->get().StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 406)			{
HXLINE( 406)				int _g = 0;
HXDLIN( 406)				while((_g < filters->length)){
HXLINE( 406)					 ::openfl::filters::BitmapFilter filter = filters->__get(_g).StaticCast<  ::openfl::filters::BitmapFilter >();
HXDLIN( 406)					_g = (_g + 1);
HXLINE( 409)					extension->_hx___expand(( (Float)(-(filter->_hx___leftExtension)) ),( (Float)(-(filter->_hx___topExtension)) ),( (Float)((filter->_hx___leftExtension + filter->_hx___rightExtension)) ),( (Float)((filter->_hx___topExtension + filter->_hx___bottomExtension)) ));
            				}
            			}
HXLINE( 415)			 ::openfl::geom::Rectangle rect1 = rect;
HXDLIN( 415)			rect1->width = (rect1->width + extension->width);
HXLINE( 416)			 ::openfl::geom::Rectangle rect2 = rect;
HXDLIN( 416)			rect2->height = (rect2->height + extension->height);
HXLINE( 417)			rect->x = extension->x;
HXLINE( 418)			rect->y = extension->y;
HXLINE( 420)			::openfl::geom::Rectangle_obj::_hx___pool->release(extension);
            		}
HXLINE( 423)		::flxanimate::interfaces::IFilterable_obj::updateBitmaps(filterInstance,rect);
HXLINE( 425)		 ::openfl::display::Graphics gfx = filterCamera->canvas->get_graphics();
HXDLIN( 425)		 ::openfl::display::BitmapData gfx1 = renderer->graphicstoBitmapData(gfx,( ( ::openfl::display::BitmapData)(filterInstance->__Field(HX_("_bmp1",2b,1c,2b,f4),::hx::paccDynamic)) ));
HXLINE( 427)		if (::hx::IsNull( gfx1 )) {
HXLINE( 427)			return;
            		}
HXLINE( 429)		 ::openfl::display::BitmapData gfxMask = null();
HXLINE( 430)		if (masking) {
HXLINE( 432)			mask->render();
HXLINE( 433)			gfxMask = renderer->graphicstoBitmapData(mask->canvas->get_graphics(),null());
            		}
HXLINE( 436)		 ::openfl::geom::Rectangle b = ::openfl::geom::Rectangle_obj::_hx___pool->get().StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 439)		filterCamera->canvas->_hx___getBounds(b,( ( ::openfl::geom::Matrix)(filterInstance->__Field(HX_("_filterMatrix",f8,f6,8e,aa),::hx::paccDynamic)) ));
HXLINE( 441)		 ::flixel::math::FlxBasePoint point = null();
HXLINE( 444)		bool _hx_tmp1;
HXDLIN( 444)		if (masking) {
HXLINE( 444)			_hx_tmp1 = ::hx::IsNotNull( gfxMask );
            		}
            		else {
HXLINE( 444)			_hx_tmp1 = false;
            		}
HXDLIN( 444)		if (_hx_tmp1) {
HXLINE( 446)			 ::openfl::geom::Rectangle extension1 = ::openfl::geom::Rectangle_obj::_hx___pool->get().StaticCast<  ::openfl::geom::Rectangle >();
HXLINE( 448)			mask->canvas->_hx___getBounds(extension1,( ( ::openfl::geom::Matrix)(filterInstance->__Field(HX_("_filterMatrix",f8,f6,8e,aa),::hx::paccDynamic)) ));
HXLINE( 450)			Float x = (extension1->x / b->width);
HXDLIN( 450)			Float y = (extension1->y / b->height);
HXDLIN( 450)			 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN( 450)			point1->_inPool = false;
HXDLIN( 450)			point = point1;
HXLINE( 452)			::openfl::geom::Rectangle_obj::_hx___pool->release(extension1);
            		}
HXLINE( 455)		renderer->applyFilter(gfx1,( ( ::flixel::graphics::frames::FlxFrame)(filterInstance->__Field(HX_("_filterFrame",56,7b,3f,1c),::hx::paccDynamic)) )->parent->bitmap,( ( ::openfl::display::BitmapData)(filterInstance->__Field(HX_("_bmp1",2b,1c,2b,f4),::hx::paccDynamic)) ),( ( ::openfl::display::BitmapData)(filterInstance->__Field(HX_("_bmp2",2c,1c,2b,f4),::hx::paccDynamic)) ),filters,rect,gfxMask,point);
HXLINE( 456)		point = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(point)) );
HXLINE( 458)		( ( ::openfl::geom::Matrix)(filterInstance->__Field(HX_("_filterMatrix",f8,f6,8e,aa),::hx::paccDynamic)) )->translate(( (Float)(::Math_obj::round((b->x + rect->x))) ),( (Float)(::Math_obj::round((b->y + rect->y))) ));
HXLINE( 460)		filterCamera->clearDrawStack();
HXLINE( 461)		filterCamera->canvas->get_graphics()->clear();
HXLINE( 463)		if (masking) {
HXLINE( 466)			mask->clearDrawStack();
HXLINE( 467)			mask->canvas->get_graphics()->clear();
            		}
HXLINE( 470)		::openfl::geom::Rectangle_obj::_hx___pool->release(b);
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxAnimate_obj,renderFilter,(void))

int FlxAnimate_obj::setButtonFrames(int frame){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_475_setButtonFrames)
HXLINE( 476)		bool badPress = false;
HXLINE( 477)		bool goodPress = false;
HXLINE( 479)		bool _hx_tmp;
HXDLIN( 479)		 ::flixel::input::mouse::FlxMouseButton _this = ::flixel::FlxG_obj::mouse->_leftButton;
HXDLIN( 479)		bool _hx_tmp1;
HXDLIN( 479)		if ((_this->current != 1)) {
HXLINE( 479)			_hx_tmp1 = (_this->current == 2);
            		}
            		else {
HXLINE( 479)			_hx_tmp1 = true;
            		}
HXDLIN( 479)		if (_hx_tmp1) {
HXLINE( 479)			_hx_tmp = ::flixel::FlxG_obj::mouse->overlaps(::hx::ObjectPtr<OBJ_>(this),null());
            		}
            		else {
HXLINE( 479)			_hx_tmp = false;
            		}
HXDLIN( 479)		if (_hx_tmp) {
HXLINE( 480)			goodPress = true;
            		}
HXLINE( 481)		bool _hx_tmp2;
HXDLIN( 481)		bool _hx_tmp3;
HXDLIN( 481)		 ::flixel::input::mouse::FlxMouseButton _this1 = ::flixel::FlxG_obj::mouse->_leftButton;
HXDLIN( 481)		bool _hx_tmp4;
HXDLIN( 481)		if ((_this1->current != 1)) {
HXLINE( 481)			_hx_tmp4 = (_this1->current == 2);
            		}
            		else {
HXLINE( 481)			_hx_tmp4 = true;
            		}
HXDLIN( 481)		if (_hx_tmp4) {
HXLINE( 481)			_hx_tmp3 = !(::flixel::FlxG_obj::mouse->overlaps(::hx::ObjectPtr<OBJ_>(this),null()));
            		}
            		else {
HXLINE( 481)			_hx_tmp3 = false;
            		}
HXDLIN( 481)		if (_hx_tmp3) {
HXLINE( 481)			_hx_tmp2 = !(goodPress);
            		}
            		else {
HXLINE( 481)			_hx_tmp2 = false;
            		}
HXDLIN( 481)		if (_hx_tmp2) {
HXLINE( 483)			badPress = true;
            		}
HXLINE( 485)		 ::flixel::input::mouse::FlxMouseButton _this2 = ::flixel::FlxG_obj::mouse->_leftButton;
HXDLIN( 485)		bool _hx_tmp5;
HXDLIN( 485)		if ((_this2->current != 1)) {
HXLINE( 485)			_hx_tmp5 = (_this2->current == 2);
            		}
            		else {
HXLINE( 485)			_hx_tmp5 = true;
            		}
HXDLIN( 485)		if (!(_hx_tmp5)) {
HXLINE( 487)			badPress = false;
HXLINE( 488)			goodPress = false;
            		}
HXLINE( 490)		bool _hx_tmp6;
HXDLIN( 490)		if (::flixel::FlxG_obj::mouse->overlaps(::hx::ObjectPtr<OBJ_>(this),null())) {
HXLINE( 490)			_hx_tmp6 = !(badPress);
            		}
            		else {
HXLINE( 490)			_hx_tmp6 = false;
            		}
HXDLIN( 490)		if (_hx_tmp6) {
HXLINE( 493)			::Dynamic this1 = this->anim->buttonMap;
HXDLIN( 493)			 ::Dynamic event = ( ( ::haxe::ds::StringMap)(this1) )->get(this->anim->get_curSymbol()->name);
HXLINE( 494)			bool _hx_tmp7;
HXDLIN( 494)			if ((::flixel::FlxG_obj::mouse->_leftButton->current == 2)) {
HXLINE( 494)				_hx_tmp7 = !(this->pressed);
            			}
            			else {
HXLINE( 494)				_hx_tmp7 = false;
            			}
HXDLIN( 494)			if (_hx_tmp7) {
HXLINE( 496)				if (::hx::IsNotNull( event )) {
HXLINE( 497)					 ::Dynamic _this3;
HXDLIN( 497)					if (::hx::IsNotNull( event->__Field(HX_("Callbacks",ee,d2,92,48),::hx::paccDynamic) )) {
HXLINE( 497)						_this3 =  ::Dynamic(event->__Field(HX_("Callbacks",ee,d2,92,48),::hx::paccDynamic))->__Field(HX_("OnClick",89,42,ed,ab),::hx::paccDynamic);
            					}
            					else {
HXLINE( 497)						_this3 = null();
            					}
HXDLIN( 497)					 ::flxanimate::animate::ButtonEvent _this4 =  ::flxanimate::animate::ButtonEvent_obj::__alloc( HX_CTX ,_this3,( ( ::flixel::sound::FlxSound)(event->__Field(HX_("Sound",af,fc,f9,13),::hx::paccDynamic)) ));
HXDLIN( 497)					if (::hx::IsNotNull( _this4->callback )) {
HXLINE( 497)						_this4->callback();
            					}
HXDLIN( 497)					if (::hx::IsNotNull( _this4->sound )) {
HXLINE( 497)						_this4->sound->play(true,null(),null());
            					}
            				}
HXLINE( 498)				this->pressed = true;
            			}
HXLINE( 500)			 ::flixel::input::mouse::FlxMouseButton _this5 = ::flixel::FlxG_obj::mouse->_leftButton;
HXDLIN( 500)			bool frame1;
HXDLIN( 500)			if ((_this5->current != 1)) {
HXLINE( 500)				frame1 = (_this5->current == 2);
            			}
            			else {
HXLINE( 500)				frame1 = true;
            			}
HXDLIN( 500)			if (frame1) {
HXLINE( 500)				frame = 2;
            			}
            			else {
HXLINE( 500)				frame = 1;
            			}
HXLINE( 502)			bool _hx_tmp8;
HXDLIN( 502)			if ((::flixel::FlxG_obj::mouse->_leftButton->current == -1)) {
HXLINE( 502)				_hx_tmp8 = this->pressed;
            			}
            			else {
HXLINE( 502)				_hx_tmp8 = false;
            			}
HXDLIN( 502)			if (_hx_tmp8) {
HXLINE( 504)				if (::hx::IsNotNull( event )) {
HXLINE( 505)					 ::Dynamic _this6;
HXDLIN( 505)					if (::hx::IsNotNull( event->__Field(HX_("Callbacks",ee,d2,92,48),::hx::paccDynamic) )) {
HXLINE( 505)						_this6 =  ::Dynamic(event->__Field(HX_("Callbacks",ee,d2,92,48),::hx::paccDynamic))->__Field(HX_("OnRelease",48,1e,6b,d2),::hx::paccDynamic);
            					}
            					else {
HXLINE( 505)						_this6 = null();
            					}
HXDLIN( 505)					 ::flxanimate::animate::ButtonEvent _this7 =  ::flxanimate::animate::ButtonEvent_obj::__alloc( HX_CTX ,_this6,( ( ::flixel::sound::FlxSound)(event->__Field(HX_("Sound",af,fc,f9,13),::hx::paccDynamic)) ));
HXDLIN( 505)					if (::hx::IsNotNull( _this7->callback )) {
HXLINE( 505)						_this7->callback();
            					}
HXDLIN( 505)					if (::hx::IsNotNull( _this7->sound )) {
HXLINE( 505)						_this7->sound->play(true,null(),null());
            					}
            				}
HXLINE( 506)				this->pressed = false;
            			}
            		}
            		else {
HXLINE( 511)			frame = 0;
            		}
HXLINE( 516)		return frame;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAnimate_obj,setButtonFrames,return )

void FlxAnimate_obj::drawLimb( ::flixel::graphics::frames::FlxFrame limb, ::flixel::math::FlxMatrix _matrix, ::openfl::geom::ColorTransform colorTransform,::hx::Null< bool >  __o_filterin, ::Dynamic blendMode, ::flixel::math::FlxBasePoint scrollFactor,::Array< ::Dynamic> cameras){
            		bool filterin = __o_filterin.Default(false);
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_520_drawLimb)
HXLINE( 521)		bool _hx_tmp;
HXDLIN( 521)		bool _hx_tmp1;
HXDLIN( 521)		bool _hx_tmp2;
HXDLIN( 521)		if (::hx::IsNotNull( colorTransform )) {
HXLINE( 521)			if ((colorTransform->alphaMultiplier != 0)) {
HXLINE( 521)				_hx_tmp2 = (colorTransform->alphaOffset == -255);
            			}
            			else {
HXLINE( 521)				_hx_tmp2 = true;
            			}
            		}
            		else {
HXLINE( 521)			_hx_tmp2 = false;
            		}
HXDLIN( 521)		if (!(_hx_tmp2)) {
HXLINE( 521)			_hx_tmp1 = ::hx::IsNull( limb );
            		}
            		else {
HXLINE( 521)			_hx_tmp1 = true;
            		}
HXDLIN( 521)		if (!(_hx_tmp1)) {
HXLINE( 521)			_hx_tmp = (limb->type == 2);
            		}
            		else {
HXLINE( 521)			_hx_tmp = true;
            		}
HXDLIN( 521)		if (_hx_tmp) {
HXLINE( 522)			return;
            		}
HXLINE( 524)		if (::hx::IsNull( blendMode )) {
HXLINE( 525)			blendMode = 10;
            		}
HXLINE( 527)		if (::hx::IsNull( cameras )) {
HXLINE( 528)			cameras = this->get_cameras();
            		}
HXLINE( 530)		{
HXLINE( 530)			int _g = 0;
HXDLIN( 530)			while((_g < cameras->length)){
HXLINE( 530)				 ::flixel::FlxCamera camera = cameras->__get(_g).StaticCast<  ::flixel::FlxCamera >();
HXDLIN( 530)				_g = (_g + 1);
HXLINE( 532)				this->_mat->identity();
HXLINE( 533)				limb->prepareMatrix(this->_mat,null(),null(),null());
HXLINE( 534)				 ::flixel::math::FlxMatrix matrix = this->_mat;
HXLINE( 535)				matrix->concat(_matrix);
HXLINE( 537)				bool _hx_tmp3;
HXDLIN( 537)				bool _hx_tmp4;
HXDLIN( 537)				if (::hx::IsNotNull( camera )) {
HXLINE( 537)					_hx_tmp4 = !(camera->visible);
            				}
            				else {
HXLINE( 537)					_hx_tmp4 = true;
            				}
HXDLIN( 537)				if (!(_hx_tmp4)) {
HXLINE( 537)					_hx_tmp3 = !(camera->exists);
            				}
            				else {
HXLINE( 537)					_hx_tmp3 = true;
            				}
HXDLIN( 537)				if (_hx_tmp3) {
HXLINE( 538)					return;
            				}
HXLINE( 541)				if (!(filterin)) {
HXLINE( 543)					{
HXLINE( 543)						 ::flixel::math::FlxBasePoint this1 = this->getScreenPosition(this->_point,camera);
HXDLIN( 543)						 ::flixel::math::FlxBasePoint point = this->offset;
HXDLIN( 543)						{
HXLINE( 543)							Float y = point->y;
HXDLIN( 543)							this1->set_x((this1->x - point->x));
HXDLIN( 543)							this1->set_y((this1->y - y));
            						}
HXDLIN( 543)						{
HXLINE( 543)							 ::flixel::math::FlxBasePoint _this = point;
HXDLIN( 543)							if (_this->_weak) {
HXLINE( 543)								_this->put();
            							}
            						}
            					}
HXLINE( 544)					bool _hx_tmp5;
HXDLIN( 544)					if (::hx::IsInstanceNotEq( limb,this->_pivot )) {
HXLINE( 544)						_hx_tmp5 = ::hx::IsInstanceNotEq( limb,this->_indicator );
            					}
            					else {
HXLINE( 544)						_hx_tmp5 = false;
            					}
HXDLIN( 544)					if (_hx_tmp5) {
HXLINE( 546)						matrix->translate(-(this->origin->x),-(this->origin->y));
HXLINE( 548)						matrix->scale(this->scale->x,this->scale->y);
HXLINE( 550)						if ((this->bakedRotationAngle <= 0)) {
HXLINE( 552)							if (this->_angleChanged) {
HXLINE( 552)								Float radians = (this->angle * (::Math_obj::PI / ( (Float)(180) )));
HXDLIN( 552)								this->_sinAngle = ::Math_obj::sin(radians);
HXDLIN( 552)								this->_cosAngle = ::Math_obj::cos(radians);
HXDLIN( 552)								this->_angleChanged = false;
            							}
HXLINE( 554)							if ((this->angle != 0)) {
HXLINE( 555)								Float cos = this->_cosAngle;
HXDLIN( 555)								Float sin = this->_sinAngle;
HXDLIN( 555)								Float a1 = ((matrix->a * cos) - (matrix->b * sin));
HXDLIN( 555)								matrix->b = ((matrix->a * sin) + (matrix->b * cos));
HXDLIN( 555)								matrix->a = a1;
HXDLIN( 555)								Float c1 = ((matrix->c * cos) - (matrix->d * sin));
HXDLIN( 555)								matrix->d = ((matrix->c * sin) + (matrix->d * cos));
HXDLIN( 555)								matrix->c = c1;
HXDLIN( 555)								Float tx1 = ((matrix->tx * cos) - (matrix->ty * sin));
HXDLIN( 555)								matrix->ty = ((matrix->tx * sin) + (matrix->ty * cos));
HXDLIN( 555)								matrix->tx = tx1;
            							}
            						}
HXLINE( 558)						{
HXLINE( 558)							 ::flixel::math::FlxBasePoint this2 = this->_point;
HXDLIN( 558)							 ::flixel::math::FlxBasePoint point1 = this->origin;
HXDLIN( 558)							{
HXLINE( 558)								Float y1 = point1->y;
HXDLIN( 558)								this2->set_x((this2->x + point1->x));
HXDLIN( 558)								this2->set_y((this2->y + y1));
            							}
HXDLIN( 558)							{
HXLINE( 558)								 ::flixel::math::FlxBasePoint _this1 = point1;
HXDLIN( 558)								if (_this1->_weak) {
HXLINE( 558)									_this1->put();
            								}
            							}
            						}
            					}
            					else {
HXLINE( 562)						matrix->scale(((Float)0.9),((Float)0.9));
HXLINE( 564)						 ::flixel::math::FlxMatrix matrix1 = matrix;
HXDLIN( 564)						matrix1->a = (matrix1->a / camera->zoom);
HXLINE( 565)						 ::flixel::math::FlxMatrix matrix2 = matrix;
HXDLIN( 565)						matrix2->d = (matrix2->d / camera->zoom);
HXLINE( 566)						 ::flixel::math::FlxMatrix matrix3 = matrix;
HXDLIN( 566)						matrix3->tx = (matrix3->tx / camera->zoom);
HXLINE( 567)						 ::flixel::math::FlxMatrix matrix4 = matrix;
HXDLIN( 567)						matrix4->ty = (matrix4->ty / camera->zoom);
            					}
HXLINE( 577)					if (this->isPixelPerfectRender(camera)) {
HXLINE( 579)						 ::flixel::math::FlxBasePoint this3 = this->_point;
HXDLIN( 579)						this3->set_x(( (Float)(::Math_obj::floor(this3->x)) ));
HXDLIN( 579)						this3->set_y(( (Float)(::Math_obj::floor(this3->y)) ));
            					}
HXLINE( 582)					matrix->translate(this->_point->x,this->_point->y);
HXLINE( 584)					if (!(this->limbOnScreen(limb,matrix,camera))) {
HXLINE( 585)						continue;
            					}
            				}
HXLINE( 587)				 ::Dynamic _hx_tmp6;
HXDLIN( 587)				if (!(filterin)) {
HXLINE( 587)					_hx_tmp6 = this->antialiasing;
            				}
            				else {
HXLINE( 587)					_hx_tmp6 = true;
            				}
HXDLIN( 587)				camera->drawPixels(limb,null(),matrix,colorTransform,blendMode,_hx_tmp6,this->shader);
            			}
            		}
HXLINE( 590)		this->set_width(this->rect->width);
HXLINE( 591)		this->set_height(this->rect->height);
HXLINE( 592)		this->frameWidth = ::Std_obj::_hx_int(this->get_width());
HXLINE( 593)		this->frameHeight = ::Std_obj::_hx_int(this->get_height());
            	}


HX_DEFINE_DYNAMIC_FUNC7(FlxAnimate_obj,drawLimb,(void))

bool FlxAnimate_obj::limbOnScreen( ::flixel::graphics::frames::FlxFrame limb, ::flixel::math::FlxMatrix m, ::flixel::FlxCamera Camera){
            	HX_GC_STACKFRAME(&_hx_pos_5067d88e43c2dc01_614_limbOnScreen)
HXLINE( 615)		if (::hx::IsNull( Camera )) {
HXLINE( 616)			Camera = ::flixel::FlxG_obj::camera;
            		}
HXLINE( 618)		{
HXLINE( 618)			 ::flixel::math::FlxRect _this = limb->frame;
HXDLIN( 618)			 ::openfl::geom::Rectangle FlashRect = this->rect;
HXDLIN( 618)			if (::hx::IsNull( FlashRect )) {
HXLINE( 618)				FlashRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            			}
HXDLIN( 618)			FlashRect->x = _this->x;
HXDLIN( 618)			FlashRect->y = _this->y;
HXDLIN( 618)			FlashRect->width = _this->width;
HXDLIN( 618)			FlashRect->height = _this->height;
            		}
HXLINE( 620)		this->rect->offset(-(this->rect->x),-(this->rect->y));
HXLINE( 622)		this->rect->_hx___transform(this->rect,m);
HXLINE( 624)		{
HXLINE( 624)			 ::flixel::math::FlxBasePoint this1 = this->_point;
HXDLIN( 624)			 ::openfl::geom::Point p = this->rect->get_topLeft();
HXDLIN( 624)			this1->set(p->x,p->y);
            		}
HXLINE( 627)		bool _hx_tmp;
HXDLIN( 627)		if (::hx::IsInstanceNotEq( this->_indicator,limb )) {
HXLINE( 627)			_hx_tmp = ::hx::IsInstanceNotEq( this->_pivot,limb );
            		}
            		else {
HXLINE( 627)			_hx_tmp = false;
            		}
HXDLIN( 627)		if (_hx_tmp) {
HXLINE( 628)			this->_flashRect = this->_flashRect->_hx_union(this->rect);
            		}
HXLINE( 630)		 ::flixel::math::FlxBasePoint point = this->_point;
HXDLIN( 630)		bool contained;
HXDLIN( 630)		bool contained1;
HXDLIN( 630)		bool contained2;
HXDLIN( 630)		if (((point->x + this->rect->width) > Camera->viewMarginX)) {
HXLINE( 630)			contained2 = (point->x < (( (Float)(Camera->width) ) - Camera->viewMarginX));
            		}
            		else {
HXLINE( 630)			contained2 = false;
            		}
HXDLIN( 630)		if (contained2) {
HXLINE( 630)			contained1 = ((point->y + this->rect->height) > Camera->viewMarginY);
            		}
            		else {
HXLINE( 630)			contained1 = false;
            		}
HXDLIN( 630)		if (contained1) {
HXLINE( 630)			contained = (point->y < (( (Float)(Camera->height) ) - Camera->viewMarginY));
            		}
            		else {
HXLINE( 630)			contained = false;
            		}
HXDLIN( 630)		{
HXLINE( 630)			 ::flixel::math::FlxBasePoint _this1 = point;
HXDLIN( 630)			if (_this1->_weak) {
HXLINE( 630)				_this1->put();
            			}
            		}
HXDLIN( 630)		return contained;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxAnimate_obj,limbOnScreen,return )

void FlxAnimate_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_634_destroy)
HXLINE( 635)		if (::hx::IsNotNull( this->anim )) {
HXLINE( 636)			this->anim->destroy();
            		}
HXLINE( 637)		this->anim = null();
HXLINE( 643)		this->super::destroy();
            	}


void FlxAnimate_obj::updateAnimation(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_648_updateAnimation)
HXDLIN( 648)		this->anim->update(elapsed);
            	}


void FlxAnimate_obj::setButtonPack(::String button, ::Dynamic callbacks, ::flixel::sound::FlxSound sound){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_654_setButtonPack)
HXDLIN( 654)		this->anim->buttonMap->set(button, ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("Sound",af,fc,f9,13),sound)
            			->setFixed(1,HX_("Callbacks",ee,d2,92,48),callbacks)));
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxAnimate_obj,setButtonPack,(void))

bool FlxAnimate_obj::set_showPivot(bool value){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_658_set_showPivot)
HXLINE( 659)		if ((value != this->showPivot)) {
HXLINE( 661)			this->showPivot = value;
HXLINE( 663)			bool _hx_tmp;
HXDLIN( 663)			if (this->showPivot) {
HXLINE( 663)				_hx_tmp = ::hx::IsNull( this->_pivot );
            			}
            			else {
HXLINE( 663)				_hx_tmp = false;
            			}
HXDLIN( 663)			if (_hx_tmp) {
HXLINE( 665)				this->_pivot = ::flixel::graphics::FlxGraphic_obj::fromBitmapData(::openfl::utils::Assets_obj::getBitmapData(HX_("flxanimate/images/pivot.png",86,22,15,80),null()),null(),HX_("__pivot",a2,a3,00,2d),null())->get_imageFrame()->get_frame();
HXLINE( 666)				this->_indicator = ::flixel::graphics::FlxGraphic_obj::fromBitmapData(::openfl::utils::Assets_obj::getBitmapData(HX_("flxanimate/images/indicator.png",93,c2,f2,28),null()),null(),HX_("__indicator",af,30,da,c1),null())->get_imageFrame()->get_frame();
            			}
            		}
HXLINE( 670)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAnimate_obj,set_showPivot,return )

void FlxAnimate_obj::setTheSettings( ::Dynamic Settings){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_681_setTheSettings)
HXLINE( 682)		this->set_antialiasing(( (bool)(Settings->__Field(HX_("Antialiasing",14,63,c5,10),::hx::paccDynamic)) ));
HXLINE( 683)		if (::hx::IsNotNull( Settings->__Field(HX_("ButtonSettings",15,71,23,aa),::hx::paccDynamic) )) {
HXLINE( 685)			this->anim->buttonMap = ( ( ::haxe::ds::StringMap)(Settings->__Field(HX_("ButtonSettings",15,71,23,aa),::hx::paccDynamic)) );
HXLINE( 686)			if (::hx::IsPointerNotEq( this->anim->get_symbolType(),::flxanimate::data::SymbolT_obj::Button_dyn() )) {
HXLINE( 687)				this->anim->set_symbolType(::flxanimate::data::SymbolT_obj::Button_dyn());
            			}
            		}
HXLINE( 689)		if (::hx::IsNotNull( Settings->__Field(HX_("Reversed",22,81,67,5b),::hx::paccDynamic) )) {
HXLINE( 690)			this->anim->set_reversed(( (bool)(Settings->__Field(HX_("Reversed",22,81,67,5b),::hx::paccDynamic)) ));
            		}
HXLINE( 691)		if (::hx::IsNotNull( Settings->__Field(HX_("FrameRate",8d,f1,f7,da),::hx::paccDynamic) )) {
HXLINE( 692)			Float _hx_tmp;
HXDLIN( 692)			if (::hx::IsGreater( Settings->__Field(HX_("FrameRate",8d,f1,f7,da),::hx::paccDynamic),0 )) {
HXLINE( 692)				_hx_tmp = this->anim->metadata->frameRate;
            			}
            			else {
HXLINE( 692)				_hx_tmp = ( (Float)(Settings->__Field(HX_("FrameRate",8d,f1,f7,da),::hx::paccDynamic)) );
            			}
HXDLIN( 692)			this->anim->set_framerate(_hx_tmp);
            		}
HXLINE( 693)		if (::hx::IsNotNull( Settings->__Field(HX_("OnComplete",18,d9,2f,54),::hx::paccDynamic) )) {
HXLINE( 694)			this->anim->onComplete->add( ::Dynamic(Settings->__Field(HX_("OnComplete",18,d9,2f,54),::hx::paccDynamic)));
            		}
HXLINE( 695)		if (::hx::IsNotNull( Settings->__Field(HX_("ShowPivot",65,90,d9,92),::hx::paccDynamic) )) {
HXLINE( 696)			this->set_showPivot(( (bool)(Settings->__Field(HX_("ShowPivot",65,90,d9,92),::hx::paccDynamic)) ));
            		}
HXLINE( 697)		if (::hx::IsNotNull( Settings->__Field(HX_("Antialiasing",14,63,c5,10),::hx::paccDynamic) )) {
HXLINE( 698)			this->set_antialiasing(( (bool)(Settings->__Field(HX_("Antialiasing",14,63,c5,10),::hx::paccDynamic)) ));
            		}
HXLINE( 699)		if (::hx::IsNotNull( Settings->__Field(HX_("ScrollFactor",dc,38,e2,03),::hx::paccDynamic) )) {
HXLINE( 700)			this->scrollFactor = ( ( ::flixel::math::FlxBasePoint)(Settings->__Field(HX_("ScrollFactor",dc,38,e2,03),::hx::paccDynamic)) );
            		}
HXLINE( 701)		if (::hx::IsNotNull( Settings->__Field(HX_("Offset",b3,0b,d4,94),::hx::paccDynamic) )) {
HXLINE( 702)			this->offset = ( ( ::flixel::math::FlxBasePoint)(Settings->__Field(HX_("Offset",b3,0b,d4,94),::hx::paccDynamic)) );
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAnimate_obj,setTheSettings,(void))

::String FlxAnimate_obj::atlasSetting(::String Path){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_710_atlasSetting)
HXLINE( 711)		::String jsontxt = null();
HXLINE( 712)		if ((::haxe::io::Path_obj::extension(Path) == HX_("zip",e1,ee,5c,00))) {
HXLINE( 714)			 ::haxe::ds::List thing = ::flxanimate::zip::Zip_obj::readZip(::openfl::utils::_ByteArray::ByteArray_Impl__obj::toBytes(::openfl::utils::Assets_obj::getBytes(Path)));
HXLINE( 716)			{
HXLINE( 716)				 ::haxe::ds::_List::ListNode _g_head = ::flxanimate::zip::Zip_obj::unzip(thing)->h;
HXDLIN( 716)				while(::hx::IsNotNull( _g_head )){
HXLINE( 716)					 ::Dynamic val = _g_head->item;
HXDLIN( 716)					_g_head = _g_head->next;
HXDLIN( 716)					 ::Dynamic list = val;
HXLINE( 718)					if ((( (::String)(list->__Field(HX_("fileName",e7,5a,43,62),::hx::paccDynamic)) ).indexOf(HX_("Animation.json",f2,a7,22,ea),null()) != -1)) {
HXLINE( 720)						jsontxt = ( ( ::haxe::io::Bytes)(list->__Field(HX_("data",2a,56,63,42),::hx::paccDynamic)) )->toString();
HXLINE( 721)						thing->remove(list);
HXLINE( 722)						continue;
            					}
            				}
            			}
HXLINE( 726)			::flxanimate::frames::FlxAnimateFrames_obj::zip = thing;
            		}
            		else {
HXLINE( 729)			jsontxt = ::openfl::utils::Assets_obj::getText(((HX_("",00,00,00,00) + Path) + HX_("/Animation.json",61,fc,54,44)));
            		}
HXLINE( 731)		return jsontxt;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxAnimate_obj,atlasSetting,return )

void FlxAnimate_obj::fromSettings(){
            	HX_STACKFRAME(&_hx_pos_5067d88e43c2dc01_707_fromSettings)
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(FlxAnimate_obj,fromSettings,(void))


::hx::ObjectPtr< FlxAnimate_obj > FlxAnimate_obj::__new(::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y,::String Path, ::Dynamic Settings) {
	::hx::ObjectPtr< FlxAnimate_obj > __this = new FlxAnimate_obj();
	__this->__construct(__o_X,__o_Y,Path,Settings);
	return __this;
}

::hx::ObjectPtr< FlxAnimate_obj > FlxAnimate_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_X,::hx::Null< Float >  __o_Y,::String Path, ::Dynamic Settings) {
	FlxAnimate_obj *__this = (FlxAnimate_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxAnimate_obj), true, "flxanimate.FlxAnimate"));
	*(void **)__this = FlxAnimate_obj::_hx_vtable;
	__this->__construct(__o_X,__o_Y,Path,Settings);
	return __this;
}

FlxAnimate_obj::FlxAnimate_obj()
{
}

void FlxAnimate_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxAnimate);
	HX_MARK_MEMBER_NAME(anim,"anim");
	HX_MARK_MEMBER_NAME(rect,"rect");
	HX_MARK_MEMBER_NAME(_symbols,"_symbols");
	HX_MARK_MEMBER_NAME(filters,"filters");
	HX_MARK_MEMBER_NAME(showPivot,"showPivot");
	HX_MARK_MEMBER_NAME(_pivot,"_pivot");
	HX_MARK_MEMBER_NAME(_indicator,"_indicator");
	HX_MARK_MEMBER_NAME(renderer,"renderer");
	HX_MARK_MEMBER_NAME(filterCamera,"filterCamera");
	HX_MARK_MEMBER_NAME(relativeX,"relativeX");
	HX_MARK_MEMBER_NAME(relativeY,"relativeY");
	HX_MARK_MEMBER_NAME(st,"st");
	HX_MARK_MEMBER_NAME(pressed,"pressed");
	HX_MARK_MEMBER_NAME(_mat,"_mat");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxAnimate_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(anim,"anim");
	HX_VISIT_MEMBER_NAME(rect,"rect");
	HX_VISIT_MEMBER_NAME(_symbols,"_symbols");
	HX_VISIT_MEMBER_NAME(filters,"filters");
	HX_VISIT_MEMBER_NAME(showPivot,"showPivot");
	HX_VISIT_MEMBER_NAME(_pivot,"_pivot");
	HX_VISIT_MEMBER_NAME(_indicator,"_indicator");
	HX_VISIT_MEMBER_NAME(renderer,"renderer");
	HX_VISIT_MEMBER_NAME(filterCamera,"filterCamera");
	HX_VISIT_MEMBER_NAME(relativeX,"relativeX");
	HX_VISIT_MEMBER_NAME(relativeY,"relativeY");
	HX_VISIT_MEMBER_NAME(st,"st");
	HX_VISIT_MEMBER_NAME(pressed,"pressed");
	HX_VISIT_MEMBER_NAME(_mat,"_mat");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlxAnimate_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"st") ) { return ::hx::Val( st ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"anim") ) { return ::hx::Val( anim ); }
		if (HX_FIELD_EQ(inName,"rect") ) { return ::hx::Val( rect ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		if (HX_FIELD_EQ(inName,"_mat") ) { return ::hx::Val( _mat ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_pivot") ) { return ::hx::Val( _pivot ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"filters") ) { return ::hx::Val( filters ); }
		if (HX_FIELD_EQ(inName,"pressed") ) { return ::hx::Val( pressed ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_symbols") ) { return ::hx::Val( _symbols ); }
		if (HX_FIELD_EQ(inName,"renderer") ) { return ::hx::Val( renderer ); }
		if (HX_FIELD_EQ(inName,"drawLimb") ) { return ::hx::Val( drawLimb_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"showPivot") ) { return ::hx::Val( showPivot ); }
		if (HX_FIELD_EQ(inName,"relativeX") ) { return ::hx::Val( relativeX ); }
		if (HX_FIELD_EQ(inName,"relativeY") ) { return ::hx::Val( relativeY ); }
		if (HX_FIELD_EQ(inName,"loadAtlas") ) { return ::hx::Val( loadAtlas_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_indicator") ) { return ::hx::Val( _indicator ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"renderLayer") ) { return ::hx::Val( renderLayer_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"filterCamera") ) { return ::hx::Val( filterCamera ); }
		if (HX_FIELD_EQ(inName,"parseElement") ) { return ::hx::Val( parseElement_dyn() ); }
		if (HX_FIELD_EQ(inName,"renderFilter") ) { return ::hx::Val( renderFilter_dyn() ); }
		if (HX_FIELD_EQ(inName,"limbOnScreen") ) { return ::hx::Val( limbOnScreen_dyn() ); }
		if (HX_FIELD_EQ(inName,"atlasSetting") ) { return ::hx::Val( atlasSetting_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"setButtonPack") ) { return ::hx::Val( setButtonPack_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_showPivot") ) { return ::hx::Val( set_showPivot_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"setTheSettings") ) { return ::hx::Val( setTheSettings_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"setButtonFrames") ) { return ::hx::Val( setButtonFrames_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateAnimation") ) { return ::hx::Val( updateAnimation_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"loadSeparateAtlas") ) { return ::hx::Val( loadSeparateAtlas_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxAnimate_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"fromSettings") ) { outValue = fromSettings_dyn(); return true; }
	}
	return false;
}

::hx::Val FlxAnimate_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"st") ) { st=inValue.Cast< int >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"anim") ) { anim=inValue.Cast<  ::flxanimate::animate::FlxAnim >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rect") ) { rect=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_mat") ) { _mat=inValue.Cast<  ::flixel::math::FlxMatrix >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_pivot") ) { _pivot=inValue.Cast<  ::flixel::graphics::frames::FlxFrame >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"filters") ) { filters=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pressed") ) { pressed=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_symbols") ) { _symbols=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"renderer") ) { renderer=inValue.Cast<  ::flxanimate::display::FlxAnimateFilterRenderer >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"showPivot") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_showPivot(inValue.Cast< bool >()) );showPivot=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"relativeX") ) { relativeX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"relativeY") ) { relativeY=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_indicator") ) { _indicator=inValue.Cast<  ::flixel::graphics::frames::FlxFrame >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"filterCamera") ) { filterCamera=inValue.Cast<  ::flixel::FlxCamera >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxAnimate_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("anim",11,86,71,40));
	outFields->push(HX_("rect",24,4d,a7,4b));
	outFields->push(HX_("_symbols",9c,17,d4,4c));
	outFields->push(HX_("filters",bb,a1,46,09));
	outFields->push(HX_("showPivot",85,b0,06,f1));
	outFields->push(HX_("_pivot",03,92,89,be));
	outFields->push(HX_("_indicator",90,63,50,ef));
	outFields->push(HX_("renderer",43,c5,db,b2));
	outFields->push(HX_("filterCamera",7d,74,e4,c3));
	outFields->push(HX_("relativeX",0c,76,50,e4));
	outFields->push(HX_("relativeY",0d,76,50,e4));
	outFields->push(HX_("st",a1,64,00,00));
	outFields->push(HX_("pressed",a2,d2,e6,39));
	outFields->push(HX_("_mat",a1,4f,1e,3f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxAnimate_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flxanimate::animate::FlxAnim */ ,(int)offsetof(FlxAnimate_obj,anim),HX_("anim",11,86,71,40)},
	{::hx::fsObject /*  ::openfl::geom::Rectangle */ ,(int)offsetof(FlxAnimate_obj,rect),HX_("rect",24,4d,a7,4b)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(FlxAnimate_obj,_symbols),HX_("_symbols",9c,17,d4,4c)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(FlxAnimate_obj,filters),HX_("filters",bb,a1,46,09)},
	{::hx::fsBool,(int)offsetof(FlxAnimate_obj,showPivot),HX_("showPivot",85,b0,06,f1)},
	{::hx::fsObject /*  ::flixel::graphics::frames::FlxFrame */ ,(int)offsetof(FlxAnimate_obj,_pivot),HX_("_pivot",03,92,89,be)},
	{::hx::fsObject /*  ::flixel::graphics::frames::FlxFrame */ ,(int)offsetof(FlxAnimate_obj,_indicator),HX_("_indicator",90,63,50,ef)},
	{::hx::fsObject /*  ::flxanimate::display::FlxAnimateFilterRenderer */ ,(int)offsetof(FlxAnimate_obj,renderer),HX_("renderer",43,c5,db,b2)},
	{::hx::fsObject /*  ::flixel::FlxCamera */ ,(int)offsetof(FlxAnimate_obj,filterCamera),HX_("filterCamera",7d,74,e4,c3)},
	{::hx::fsFloat,(int)offsetof(FlxAnimate_obj,relativeX),HX_("relativeX",0c,76,50,e4)},
	{::hx::fsFloat,(int)offsetof(FlxAnimate_obj,relativeY),HX_("relativeY",0d,76,50,e4)},
	{::hx::fsInt,(int)offsetof(FlxAnimate_obj,st),HX_("st",a1,64,00,00)},
	{::hx::fsBool,(int)offsetof(FlxAnimate_obj,pressed),HX_("pressed",a2,d2,e6,39)},
	{::hx::fsObject /*  ::flixel::math::FlxMatrix */ ,(int)offsetof(FlxAnimate_obj,_mat),HX_("_mat",a1,4f,1e,3f)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *FlxAnimate_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxAnimate_obj_sMemberFields[] = {
	HX_("anim",11,86,71,40),
	HX_("rect",24,4d,a7,4b),
	HX_("_symbols",9c,17,d4,4c),
	HX_("filters",bb,a1,46,09),
	HX_("showPivot",85,b0,06,f1),
	HX_("_pivot",03,92,89,be),
	HX_("_indicator",90,63,50,ef),
	HX_("renderer",43,c5,db,b2),
	HX_("filterCamera",7d,74,e4,c3),
	HX_("relativeX",0c,76,50,e4),
	HX_("relativeY",0d,76,50,e4),
	HX_("loadAtlas",45,99,14,42),
	HX_("loadSeparateAtlas",e2,cc,ad,76),
	HX_("draw",04,2c,70,42),
	HX_("st",a1,64,00,00),
	HX_("parseElement",c9,02,2f,60),
	HX_("renderLayer",9b,ae,71,3b),
	HX_("renderFilter",ae,23,8b,f4),
	HX_("pressed",a2,d2,e6,39),
	HX_("setButtonFrames",fa,59,f9,72),
	HX_("_mat",a1,4f,1e,3f),
	HX_("drawLimb",36,c1,1c,5c),
	HX_("limbOnScreen",1d,67,d7,38),
	HX_("destroy",fa,2c,86,24),
	HX_("updateAnimation",bb,bf,bf,9a),
	HX_("setButtonPack",2d,84,c0,55),
	HX_("set_showPivot",68,66,70,f7),
	HX_("setTheSettings",f2,2d,f5,c8),
	HX_("atlasSetting",85,cb,d6,01),
	::String(null()) };

::hx::Class FlxAnimate_obj::__mClass;

static ::String FlxAnimate_obj_sStaticFields[] = {
	HX_("fromSettings",6d,58,54,2b),
	::String(null())
};

void FlxAnimate_obj::__register()
{
	FlxAnimate_obj _hx_dummy;
	FlxAnimate_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flxanimate.FlxAnimate",0e,fa,42,da);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxAnimate_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(FlxAnimate_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxAnimate_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxAnimate_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxAnimate_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxAnimate_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flxanimate
