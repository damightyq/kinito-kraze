// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flxanimate_filters_GradientBevelFilter
#include <flxanimate/filters/GradientBevelFilter.h>
#endif
#ifndef INCLUDED_flxanimate_filters_GradientGlowFilter
#include <flxanimate/filters/GradientGlowFilter.h>
#endif
#ifndef INCLUDED_flxanimate_filters__GradientBevelFilter_ColorRatioBevelShader
#include <flxanimate/filters/_GradientBevelFilter/ColorRatioBevelShader.h>
#endif
#ifndef INCLUDED_flxanimate_filters__GradientGlowFilter_FullCombineShader
#include <flxanimate/filters/_GradientGlowFilter/FullCombineShader.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectRenderer
#include <openfl/display/DisplayObjectRenderer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderInput_openfl_display_BitmapData
#include <openfl/display/ShaderInput_openfl_display_BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_filters_BitmapFilter
#include <openfl/filters/BitmapFilter.h>
#endif
#ifndef INCLUDED_openfl_filters_BitmapFilterShader
#include <openfl/filters/BitmapFilterShader.h>
#endif
#ifndef INCLUDED_openfl_filters_DropShadowFilter
#include <openfl/filters/DropShadowFilter.h>
#endif
#ifndef INCLUDED_openfl_filters_GlowFilter
#include <openfl/filters/GlowFilter.h>
#endif
#ifndef INCLUDED_openfl_filters__BitmapFilterType_BitmapFilterType_Impl_
#include <openfl/filters/_BitmapFilterType/BitmapFilterType_Impl_.h>
#endif
#ifndef INCLUDED_openfl_filters__DropShadowFilter_HideShader
#include <openfl/filters/_DropShadowFilter/HideShader.h>
#endif
#ifndef INCLUDED_openfl_filters__GlowFilter_BlurAlphaShader
#include <openfl/filters/_GlowFilter/BlurAlphaShader.h>
#endif
#ifndef INCLUDED_openfl_filters__GlowFilter_CombineKnockoutShader
#include <openfl/filters/_GlowFilter/CombineKnockoutShader.h>
#endif
#ifndef INCLUDED_openfl_filters__GlowFilter_CombineShader
#include <openfl/filters/_GlowFilter/CombineShader.h>
#endif
#ifndef INCLUDED_openfl_filters__GlowFilter_InnerCombineKnockoutShader
#include <openfl/filters/_GlowFilter/InnerCombineKnockoutShader.h>
#endif
#ifndef INCLUDED_openfl_filters__GlowFilter_InnerCombineShader
#include <openfl/filters/_GlowFilter/InnerCombineShader.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif
#ifndef INCLUDED_openfl_utils_ByteArrayData
#include <openfl/utils/ByteArrayData.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataInput
#include <openfl/utils/IDataInput.h>
#endif
#ifndef INCLUDED_openfl_utils_IDataOutput
#include <openfl/utils/IDataOutput.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_00badf6175ae6572_276_new,"flxanimate.filters.GradientBevelFilter","new",0x994c75e2,"flxanimate.filters.GradientBevelFilter.new","flxanimate/filters/GradientBevelFilter.hx",276,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_311_clone,"flxanimate.filters.GradientBevelFilter","clone",0x8cf19d5f,"flxanimate.filters.GradientBevelFilter.clone","flxanimate/filters/GradientBevelFilter.hx",311,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_316___initShader,"flxanimate.filters.GradientBevelFilter","__initShader",0x87152fb3,"flxanimate.filters.GradientBevelFilter.__initShader","flxanimate/filters/GradientBevelFilter.hx",316,0xd2761650)
static const Float _hx_array_data_08679cf0_4[] = {
	(Float)1,(Float)1,(Float)1,(Float)1,
};
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_410___updateSize,"flxanimate.filters.GradientBevelFilter","__updateSize",0x6ab7a0c8,"flxanimate.filters.GradientBevelFilter.__updateSize","flxanimate/filters/GradientBevelFilter.hx",410,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_421___calculateNumShaderPasses,"flxanimate.filters.GradientBevelFilter","__calculateNumShaderPasses",0xf067df02,"flxanimate.filters.GradientBevelFilter.__calculateNumShaderPasses","flxanimate/filters/GradientBevelFilter.hx",421,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_428___setColorBitmap,"flxanimate.filters.GradientBevelFilter","__setColorBitmap",0x45faf98e,"flxanimate.filters.GradientBevelFilter.__setColorBitmap","flxanimate/filters/GradientBevelFilter.hx",428,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_480_get_alphas,"flxanimate.filters.GradientBevelFilter","get_alphas",0xb7f729dc,"flxanimate.filters.GradientBevelFilter.get_alphas","flxanimate/filters/GradientBevelFilter.hx",480,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_484_set_alphas,"flxanimate.filters.GradientBevelFilter","set_alphas",0xbb74c850,"flxanimate.filters.GradientBevelFilter.set_alphas","flxanimate/filters/GradientBevelFilter.hx",484,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_496_get_angle,"flxanimate.filters.GradientBevelFilter","get_angle",0x7cf4532c,"flxanimate.filters.GradientBevelFilter.get_angle","flxanimate/filters/GradientBevelFilter.hx",496,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_500_set_angle,"flxanimate.filters.GradientBevelFilter","set_angle",0x60453f38,"flxanimate.filters.GradientBevelFilter.set_angle","flxanimate/filters/GradientBevelFilter.hx",500,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_512_get_blurX,"flxanimate.filters.GradientBevelFilter","get_blurX",0x0f131f2a,"flxanimate.filters.GradientBevelFilter.get_blurX","flxanimate/filters/GradientBevelFilter.hx",512,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_516_set_blurX,"flxanimate.filters.GradientBevelFilter","set_blurX",0xf2640b36,"flxanimate.filters.GradientBevelFilter.set_blurX","flxanimate/filters/GradientBevelFilter.hx",516,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_528_get_blurY,"flxanimate.filters.GradientBevelFilter","get_blurY",0x0f131f2b,"flxanimate.filters.GradientBevelFilter.get_blurY","flxanimate/filters/GradientBevelFilter.hx",528,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_532_set_blurY,"flxanimate.filters.GradientBevelFilter","set_blurY",0xf2640b37,"flxanimate.filters.GradientBevelFilter.set_blurY","flxanimate/filters/GradientBevelFilter.hx",532,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_544_get_colors,"flxanimate.filters.GradientBevelFilter","get_colors",0x3c422437,"flxanimate.filters.GradientBevelFilter.get_colors","flxanimate/filters/GradientBevelFilter.hx",544,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_548_set_colors,"flxanimate.filters.GradientBevelFilter","set_colors",0x3fbfc2ab,"flxanimate.filters.GradientBevelFilter.set_colors","flxanimate/filters/GradientBevelFilter.hx",548,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_560_get_distance,"flxanimate.filters.GradientBevelFilter","get_distance",0x4e2ee17c,"flxanimate.filters.GradientBevelFilter.get_distance","flxanimate/filters/GradientBevelFilter.hx",560,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_564_set_distance,"flxanimate.filters.GradientBevelFilter","set_distance",0x632804f0,"flxanimate.filters.GradientBevelFilter.set_distance","flxanimate/filters/GradientBevelFilter.hx",564,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_576_get_knockout,"flxanimate.filters.GradientBevelFilter","get_knockout",0x51daf841,"flxanimate.filters.GradientBevelFilter.get_knockout","flxanimate/filters/GradientBevelFilter.hx",576,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_580_set_knockout,"flxanimate.filters.GradientBevelFilter","set_knockout",0x66d41bb5,"flxanimate.filters.GradientBevelFilter.set_knockout","flxanimate/filters/GradientBevelFilter.hx",580,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_587_get_quality,"flxanimate.filters.GradientBevelFilter","get_quality",0xd2835c58,"flxanimate.filters.GradientBevelFilter.get_quality","flxanimate/filters/GradientBevelFilter.hx",587,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_591_set_quality,"flxanimate.filters.GradientBevelFilter","set_quality",0xdcf06364,"flxanimate.filters.GradientBevelFilter.set_quality","flxanimate/filters/GradientBevelFilter.hx",591,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_598_get_ratios,"flxanimate.filters.GradientBevelFilter","get_ratios",0x3145938f,"flxanimate.filters.GradientBevelFilter.get_ratios","flxanimate/filters/GradientBevelFilter.hx",598,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_602_set_ratios,"flxanimate.filters.GradientBevelFilter","set_ratios",0x34c33203,"flxanimate.filters.GradientBevelFilter.set_ratios","flxanimate/filters/GradientBevelFilter.hx",602,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_614_get_strength,"flxanimate.filters.GradientBevelFilter","get_strength",0x70c420c8,"flxanimate.filters.GradientBevelFilter.get_strength","flxanimate/filters/GradientBevelFilter.hx",614,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_618_set_strength,"flxanimate.filters.GradientBevelFilter","set_strength",0x85bd443c,"flxanimate.filters.GradientBevelFilter.set_strength","flxanimate/filters/GradientBevelFilter.hx",618,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_625_get_type,"flxanimate.filters.GradientBevelFilter","get_type",0x8db9d181,"flxanimate.filters.GradientBevelFilter.get_type","flxanimate/filters/GradientBevelFilter.hx",625,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_629_set_type,"flxanimate.filters.GradientBevelFilter","set_type",0x3c172af5,"flxanimate.filters.GradientBevelFilter.set_type","flxanimate/filters/GradientBevelFilter.hx",629,0xd2761650)
HX_LOCAL_STACK_FRAME(_hx_pos_00badf6175ae6572_57_boot,"flxanimate.filters.GradientBevelFilter","boot",0x81b3b070,"flxanimate.filters.GradientBevelFilter.boot","flxanimate/filters/GradientBevelFilter.hx",57,0xd2761650)
namespace flxanimate{
namespace filters{

void GradientBevelFilter_obj::__construct(::hx::Null< Float >  __o_distance,::hx::Null< Float >  __o_angle,::Array< int > colors,::Array< Float > alphas,::Array< int > ratios,::hx::Null< Float >  __o_blurX,::hx::Null< Float >  __o_blurY,::hx::Null< Float >  __o_strength,::hx::Null< int >  __o_quality,::String __o_type,::hx::Null< bool >  __o_knockout){
            		Float distance = __o_distance.Default(4);
            		Float angle = __o_angle.Default(45);
            		Float blurX = __o_blurX.Default(4);
            		Float blurY = __o_blurY.Default(4);
            		Float strength = __o_strength.Default(1);
            		int quality = __o_quality.Default(1);
            		::String type = __o_type;
            		if (::hx::IsNull(__o_type)) type = HX_("inner",96,31,1c,be);
            		bool knockout = __o_knockout.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_00badf6175ae6572_276_new)
HXLINE( 277)		super::__construct();
HXLINE( 279)		this->_hx___offsetX = ( (Float)(0) );
HXLINE( 280)		this->_hx___offsetY = ( (Float)(0) );
HXLINE( 282)		this->_hx___angle = angle;
HXLINE( 283)		this->_hx___distance = distance;
HXLINE( 284)		this->_hx___angle = angle;
HXLINE( 285)		this->_hx___colors = colors;
HXLINE( 286)		this->_hx___alphas = alphas;
HXLINE( 287)		this->_hx___ratios = ratios;
HXLINE( 288)		this->_hx___blurX = blurX;
HXLINE( 289)		this->_hx___blurY = blurY;
HXLINE( 290)		this->_hx___strength = strength;
HXLINE( 291)		this->_hx___quality = quality;
HXLINE( 292)		this->_hx___type = type;
HXLINE( 293)		this->_hx___knockout = knockout;
HXLINE( 294)		this->_hx___colorFadeArr =  ::openfl::utils::ByteArrayData_obj::__alloc( HX_CTX ,0);
HXLINE( 296)		this->_hx___updateSize();
HXLINE( 297)		this->_hx___setColorBitmap();
HXLINE( 299)		this->_hx___needSecondBitmapData = true;
HXLINE( 300)		this->_hx___preserveObject = true;
HXLINE( 301)		this->_hx___renderDirty = true;
            	}

Dynamic GradientBevelFilter_obj::__CreateEmpty() { return new GradientBevelFilter_obj; }

void *GradientBevelFilter_obj::_hx_vtable = 0;

Dynamic GradientBevelFilter_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< GradientBevelFilter_obj > _hx_result = new GradientBevelFilter_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6],inArgs[7],inArgs[8],inArgs[9],inArgs[10]);
	return _hx_result;
}

bool GradientBevelFilter_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x26de6bd2) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x26de6bd2;
	} else {
		return inClassId==(int)0x3b04323e;
	}
}

 ::openfl::filters::BitmapFilter GradientBevelFilter_obj::clone(){
            	HX_GC_STACKFRAME(&_hx_pos_00badf6175ae6572_311_clone)
HXDLIN( 311)		return  ::flxanimate::filters::GradientGlowFilter_obj::__alloc( HX_CTX ,this->_hx___distance,this->_hx___angle,this->_hx___colors,this->_hx___alphas,this->_hx___ratios,this->_hx___blurX,this->_hx___blurY,this->_hx___strength,this->_hx___quality,this->_hx___type,this->_hx___knockout);
            	}


 ::openfl::display::Shader GradientBevelFilter_obj::_hx___initShader( ::openfl::display::DisplayObjectRenderer renderer,int pass, ::openfl::display::BitmapData sourceBitmapData){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_316___initShader)
HXLINE( 317)		int blurPass = pass;
HXLINE( 318)		int numBlurPasses = (this->_hx___horizontalPasses + this->_hx___verticalPasses);
HXLINE( 320)		if ((blurPass < numBlurPasses)) {
HXLINE( 322)			 ::openfl::filters::_GlowFilter::BlurAlphaShader shader = ::openfl::filters::GlowFilter_obj::_hx___blurAlphaShader;
HXLINE( 323)			if ((blurPass < this->_hx___horizontalPasses)) {
HXLINE( 325)				Float scale = (::Math_obj::pow(((Float)0.5),( (Float)((blurPass >> 1)) )) * ((Float)0.5));
HXLINE( 326)				shader->uRadius->value[0] = (this->get_blurX() * scale);
HXLINE( 327)				shader->uRadius->value[1] = ( (Float)(0) );
            			}
            			else {
HXLINE( 331)				Float scale1 = (::Math_obj::pow(((Float)0.5),( (Float)(((blurPass - this->_hx___horizontalPasses) >> 1)) )) * ((Float)0.5));
HXLINE( 332)				shader->uRadius->value[0] = ( (Float)(0) );
HXLINE( 333)				shader->uRadius->value[1] = (this->get_blurY() * scale1);
            			}
HXLINE( 335)			shader->uColor->value = ::Array_obj< Float >::fromData( _hx_array_data_08679cf0_4,4);
HXLINE( 336)			shader->uStrength->value[0] = ((Float)1.0);
HXLINE( 338)			return shader;
            		}
HXLINE( 341)		if ((pass == numBlurPasses)) {
HXLINE( 343)			 ::flxanimate::filters::_GradientBevelFilter::ColorRatioBevelShader shader1 = ::flxanimate::filters::GradientBevelFilter_obj::_hx___colorRatioShader;
HXLINE( 344)			::flxanimate::filters::GradientGlowFilter_obj::_hx___colorFadeBmp->setPixels(::flxanimate::filters::GradientGlowFilter_obj::_hx___colorFadeBmp->rect,this->_hx___colorFadeArr);
HXLINE( 345)			shader1->colorGradient->input = ::flxanimate::filters::GradientGlowFilter_obj::_hx___colorFadeBmp;
HXLINE( 346)			shader1->offset->value[0] = this->_hx___offsetX;
HXLINE( 347)			shader1->offset->value[1] = this->_hx___offsetY;
HXLINE( 348)			shader1->uStrength->value[0] = this->_hx___strength;
HXLINE( 350)			return shader1;
            		}
HXLINE( 352)		::String _hx_switch_0 = this->get_type();
            		if (  (_hx_switch_0==HX_("full",8f,e9,c4,43)) ){
HXLINE( 388)			if (this->_hx___knockout) {
HXLINE( 390)				 ::openfl::filters::_DropShadowFilter::HideShader shader2 = ::openfl::filters::DropShadowFilter_obj::_hx___hideShader;
HXLINE( 391)				shader2->sourceBitmap->input = sourceBitmapData;
HXLINE( 392)				shader2->offset->value[0] = ((Float)0.);
HXLINE( 393)				shader2->offset->value[1] = ((Float)0.);
HXLINE( 394)				return shader2;
            			}
HXLINE( 397)			 ::flxanimate::filters::_GradientGlowFilter::FullCombineShader shader3 = ::flxanimate::filters::GradientGlowFilter_obj::_hx___fullCombineShader;
HXLINE( 398)			shader3->sourceBitmap->input = sourceBitmapData;
HXLINE( 399)			shader3->offset->value[0] = ((Float)0.);
HXLINE( 400)			shader3->offset->value[1] = ((Float)0.);
HXLINE( 401)			return shader3;
HXLINE( 387)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("inner",96,31,1c,be)) ){
HXLINE( 372)			if (this->_hx___knockout) {
HXLINE( 374)				 ::openfl::filters::_GlowFilter::InnerCombineKnockoutShader shader4 = ::openfl::filters::GlowFilter_obj::_hx___innerCombineKnockoutShader;
HXLINE( 375)				shader4->sourceBitmap->input = sourceBitmapData;
HXLINE( 376)				shader4->offset->value[0] = ((Float)0.);
HXLINE( 377)				shader4->offset->value[1] = ((Float)0.);
HXLINE( 378)				return shader4;
            			}
HXLINE( 380)			 ::openfl::filters::_GlowFilter::InnerCombineShader shader5 = ::openfl::filters::GlowFilter_obj::_hx___innerCombineShader;
HXLINE( 381)			shader5->sourceBitmap->input = sourceBitmapData;
HXLINE( 382)			shader5->offset->value[0] = ((Float)0.);
HXLINE( 383)			shader5->offset->value[1] = ((Float)0.);
HXLINE( 384)			return shader5;
HXLINE( 371)			goto _hx_goto_2;
            		}
            		if (  (_hx_switch_0==HX_("outer",7b,b8,28,37)) ){
HXLINE( 356)			if (this->_hx___knockout) {
HXLINE( 358)				 ::openfl::filters::_GlowFilter::CombineKnockoutShader shader6 = ::openfl::filters::GlowFilter_obj::_hx___combineKnockoutShader;
HXLINE( 359)				shader6->sourceBitmap->input = sourceBitmapData;
HXLINE( 360)				shader6->offset->value[0] = ((Float)0.);
HXLINE( 361)				shader6->offset->value[1] = ((Float)0.);
HXLINE( 362)				return shader6;
            			}
HXLINE( 364)			 ::openfl::filters::_GlowFilter::CombineShader shader7 = ::openfl::filters::GlowFilter_obj::_hx___combineShader;
HXLINE( 365)			shader7->sourceBitmap->input = sourceBitmapData;
HXLINE( 366)			shader7->offset->value[0] = ((Float)0.);
HXLINE( 367)			shader7->offset->value[1] = ((Float)0.);
HXLINE( 368)			return shader7;
HXLINE( 355)			goto _hx_goto_2;
            		}
            		_hx_goto_2:;
HXLINE( 405)		return null();
            	}


void GradientBevelFilter_obj::_hx___updateSize(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_410___updateSize)
HXLINE( 411)		this->_hx___offsetX = ( (Float)(::Std_obj::_hx_int((this->_hx___distance * ::Math_obj::cos(((this->_hx___angle * ::Math_obj::PI) / ( (Float)(180) )))))) );
HXLINE( 412)		this->_hx___offsetY = ( (Float)(::Std_obj::_hx_int((this->_hx___distance * ::Math_obj::sin(((this->_hx___angle * ::Math_obj::PI) / ( (Float)(180) )))))) );
HXLINE( 413)		int _hx_tmp;
HXDLIN( 413)		if (::hx::IsNotEq( ::openfl::filters::_BitmapFilterType::BitmapFilterType_Impl__obj::fromString(this->get_type()),1 )) {
HXLINE( 413)			_hx_tmp = ::Math_obj::ceil((::Math_obj::abs(this->_hx___offsetY) + this->_hx___blurY));
            		}
            		else {
HXLINE( 413)			_hx_tmp = 0;
            		}
HXDLIN( 413)		this->_hx___topExtension = _hx_tmp;
HXLINE( 414)		this->_hx___bottomExtension = this->_hx___topExtension;
HXLINE( 415)		int _hx_tmp1;
HXDLIN( 415)		if (::hx::IsNotEq( ::openfl::filters::_BitmapFilterType::BitmapFilterType_Impl__obj::fromString(this->get_type()),1 )) {
HXLINE( 415)			_hx_tmp1 = ::Math_obj::ceil((::Math_obj::abs(this->_hx___offsetX) + this->_hx___blurX));
            		}
            		else {
HXLINE( 415)			_hx_tmp1 = 0;
            		}
HXDLIN( 415)		this->_hx___leftExtension = _hx_tmp1;
HXLINE( 416)		this->_hx___rightExtension = this->_hx___leftExtension;
HXLINE( 417)		this->_hx___calculateNumShaderPasses();
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,_hx___updateSize,(void))

void GradientBevelFilter_obj::_hx___calculateNumShaderPasses(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_421___calculateNumShaderPasses)
HXLINE( 422)		int _hx_tmp;
HXDLIN( 422)		if ((this->_hx___blurX <= 0)) {
HXLINE( 422)			_hx_tmp = 0;
            		}
            		else {
HXLINE( 422)			_hx_tmp = (::Math_obj::round((this->_hx___blurX * (( (Float)(this->_hx___quality) ) / ( (Float)(4) )))) + 1);
            		}
HXDLIN( 422)		this->_hx___horizontalPasses = _hx_tmp;
HXLINE( 423)		int _hx_tmp1;
HXDLIN( 423)		if ((this->_hx___blurY <= 0)) {
HXLINE( 423)			_hx_tmp1 = 0;
            		}
            		else {
HXLINE( 423)			_hx_tmp1 = (::Math_obj::round((this->_hx___blurY * (( (Float)(this->_hx___quality) ) / ( (Float)(4) )))) + 1);
            		}
HXDLIN( 423)		this->_hx___verticalPasses = _hx_tmp1;
HXLINE( 424)		this->_hx___numShaderPasses = ((this->_hx___horizontalPasses + this->_hx___verticalPasses) + 2);
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,_hx___calculateNumShaderPasses,(void))

void GradientBevelFilter_obj::_hx___setColorBitmap(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_428___setColorBitmap)
HXLINE( 429)		this->_hx___colorFadeArr->clear();
HXLINE( 430)		if ((this->_hx___colors->length < 0)) {
HXLINE( 430)			return;
            		}
HXLINE( 432)		int _rat = 0;
HXLINE( 434)		{
HXLINE( 434)			int _g = 0;
HXDLIN( 434)			while((_g < 255)){
HXLINE( 434)				_g = (_g + 1);
HXDLIN( 434)				int i = (_g - 1);
HXLINE( 436)				int preRatio = this->_hx___ratios->__get(_rat);
HXLINE( 439)				int currentRatio;
HXDLIN( 439)				if (((this->_hx___ratios->length - 1) < (_rat + 1))) {
HXLINE( 439)					currentRatio = 255;
            				}
            				else {
HXLINE( 439)					currentRatio = this->_hx___ratios->__get((_rat + 1));
            				}
HXLINE( 441)				if ((currentRatio < i)) {
HXLINE( 443)					_rat = (_rat + 1);
HXLINE( 444)					preRatio = this->_hx___ratios->__get(_rat);
HXLINE( 445)					if (((this->_hx___ratios->length - 1) < (_rat + 1))) {
HXLINE( 445)						currentRatio = 255;
            					}
            					else {
HXLINE( 445)						currentRatio = this->_hx___ratios->__get((_rat + 1));
            					}
            				}
HXLINE( 447)				Float preAlpha;
HXDLIN( 447)				if (((this->_hx___alphas->length - 1) > _rat)) {
HXLINE( 447)					preAlpha = this->_hx___alphas->__get(_rat);
            				}
            				else {
HXLINE( 447)					preAlpha = ((Float)1.);
            				}
HXLINE( 448)				Float postAlpha;
HXDLIN( 448)				if (((this->_hx___alphas->length - 1) > (_rat + 1))) {
HXLINE( 448)					postAlpha = this->_hx___alphas->__get((_rat + 1));
            				}
            				else {
HXLINE( 448)					postAlpha = ((Float)1.);
            				}
HXLINE( 450)				int preColor = this->_hx___colors->__get(_rat);
HXLINE( 452)				int postColor;
HXDLIN( 452)				if (((this->_hx___colors->length - 1) < (_rat + 1))) {
HXLINE( 452)					postColor = preColor;
            				}
            				else {
HXLINE( 452)					postColor = this->_hx___colors->__get((_rat + 1));
            				}
HXLINE( 454)				bool _hx_tmp;
HXDLIN( 454)				if ((_rat == 0)) {
HXLINE( 454)					_hx_tmp = (preRatio > i);
            				}
            				else {
HXLINE( 454)					_hx_tmp = false;
            				}
HXDLIN( 454)				if (_hx_tmp) {
HXLINE( 456)					{
HXLINE( 456)						 ::openfl::utils::ByteArrayData this1 = this->_hx___colorFadeArr;
HXDLIN( 456)						this1->writeInt((::Std_obj::_hx_int((preAlpha * ( (Float)(255) ))) | preColor));
            					}
HXLINE( 457)					continue;
            				}
HXLINE( 459)				int preA = (::Std_obj::_hx_int((preAlpha * ( (Float)(255) ))) & 255);
HXLINE( 460)				int preR = ((preColor >> 16) & 255);
HXLINE( 461)				int preG = ((preColor >> 8) & 255);
HXLINE( 462)				int preB = (preColor & 255);
HXLINE( 464)				int postA = (::Std_obj::_hx_int((postAlpha * ( (Float)(255) ))) & 255);
HXLINE( 465)				int postR = ((postColor >> 16) & 255);
HXLINE( 466)				int postG = ((postColor >> 8) & 255);
HXLINE( 467)				int postB = (postColor & 255);
HXLINE( 469)				Float progr = (( (Float)((i - preRatio)) ) / ( (Float)((currentRatio - preRatio)) ));
HXLINE( 470)				Float q = (( (Float)(1) ) - progr);
HXLINE( 472)				{
HXLINE( 472)					 ::openfl::utils::ByteArrayData this2 = this->_hx___colorFadeArr;
HXDLIN( 472)					int value = (::Std_obj::_hx_int(((( (Float)(preA) ) * q) + (( (Float)(postA) ) * progr))) << 24);
HXDLIN( 472)					int value1 = (value | (::Std_obj::_hx_int(((( (Float)(preR) ) * q) + (( (Float)(postR) ) * progr))) << 16));
HXDLIN( 472)					int value2 = (value1 | (::Std_obj::_hx_int(((( (Float)(preG) ) * q) + (( (Float)(postG) ) * progr))) << 8));
HXDLIN( 472)					this2->writeInt((value2 | ::Std_obj::_hx_int(((( (Float)(preB) ) * q) + (( (Float)(postB) ) * progr)))));
            				}
            			}
            		}
HXLINE( 475)		this->_hx___colorFadeArr->position = 0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,_hx___setColorBitmap,(void))

::Array< Float > GradientBevelFilter_obj::get_alphas(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_480_get_alphas)
HXDLIN( 480)		return this->_hx___alphas;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_alphas,return )

::Array< Float > GradientBevelFilter_obj::set_alphas(::Array< Float > value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_484_set_alphas)
HXLINE( 485)		if (::hx::IsPointerNotEq( value,this->_hx___alphas )) {
HXLINE( 487)			this->_hx___alphas = value;
HXLINE( 488)			this->_hx___renderDirty = true;
HXLINE( 489)			this->_hx___setColorBitmap();
            		}
HXLINE( 491)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_alphas,return )

Float GradientBevelFilter_obj::get_angle(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_496_get_angle)
HXDLIN( 496)		return this->_hx___angle;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_angle,return )

Float GradientBevelFilter_obj::set_angle(Float value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_500_set_angle)
HXLINE( 501)		if ((value != this->_hx___angle)) {
HXLINE( 503)			this->_hx___angle = value;
HXLINE( 504)			this->_hx___renderDirty = true;
HXLINE( 505)			this->_hx___updateSize();
            		}
HXLINE( 507)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_angle,return )

Float GradientBevelFilter_obj::get_blurX(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_512_get_blurX)
HXDLIN( 512)		return this->_hx___blurX;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_blurX,return )

Float GradientBevelFilter_obj::set_blurX(Float value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_516_set_blurX)
HXLINE( 517)		if ((value != this->_hx___blurX)) {
HXLINE( 519)			this->_hx___blurX = value;
HXLINE( 520)			this->_hx___renderDirty = true;
HXLINE( 521)			this->_hx___updateSize();
            		}
HXLINE( 523)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_blurX,return )

Float GradientBevelFilter_obj::get_blurY(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_528_get_blurY)
HXDLIN( 528)		return this->_hx___blurY;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_blurY,return )

Float GradientBevelFilter_obj::set_blurY(Float value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_532_set_blurY)
HXLINE( 533)		if ((value != this->_hx___blurY)) {
HXLINE( 535)			this->_hx___blurY = value;
HXLINE( 536)			this->_hx___renderDirty = true;
HXLINE( 537)			this->_hx___updateSize();
            		}
HXLINE( 539)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_blurY,return )

::Array< int > GradientBevelFilter_obj::get_colors(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_544_get_colors)
HXDLIN( 544)		return this->_hx___colors;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_colors,return )

::Array< int > GradientBevelFilter_obj::set_colors(::Array< int > value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_548_set_colors)
HXLINE( 549)		if (::hx::IsPointerNotEq( value,this->_hx___colors )) {
HXLINE( 551)			this->_hx___colors = value;
HXLINE( 552)			this->_hx___renderDirty = true;
HXLINE( 553)			this->_hx___setColorBitmap();
            		}
HXLINE( 555)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_colors,return )

Float GradientBevelFilter_obj::get_distance(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_560_get_distance)
HXDLIN( 560)		return this->_hx___distance;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_distance,return )

Float GradientBevelFilter_obj::set_distance(Float value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_564_set_distance)
HXLINE( 565)		if ((value != this->_hx___distance)) {
HXLINE( 567)			this->_hx___distance = value;
HXLINE( 568)			this->_hx___renderDirty = true;
HXLINE( 569)			this->_hx___updateSize();
            		}
HXLINE( 571)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_distance,return )

bool GradientBevelFilter_obj::get_knockout(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_576_get_knockout)
HXDLIN( 576)		return this->_hx___knockout;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_knockout,return )

bool GradientBevelFilter_obj::set_knockout(bool value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_580_set_knockout)
HXLINE( 581)		if ((value != this->_hx___knockout)) {
HXLINE( 581)			this->_hx___renderDirty = true;
            		}
HXLINE( 582)		return (this->_hx___knockout = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_knockout,return )

int GradientBevelFilter_obj::get_quality(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_587_get_quality)
HXDLIN( 587)		return this->_hx___quality;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_quality,return )

int GradientBevelFilter_obj::set_quality(int value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_591_set_quality)
HXLINE( 592)		if ((value != this->_hx___quality)) {
HXLINE( 592)			this->_hx___renderDirty = true;
            		}
HXLINE( 593)		return (this->_hx___quality = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_quality,return )

::Array< int > GradientBevelFilter_obj::get_ratios(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_598_get_ratios)
HXDLIN( 598)		return this->_hx___ratios;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_ratios,return )

::Array< int > GradientBevelFilter_obj::set_ratios(::Array< int > value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_602_set_ratios)
HXLINE( 603)		if (::hx::IsPointerNotEq( value,this->_hx___ratios )) {
HXLINE( 605)			this->_hx___ratios = value;
HXLINE( 606)			this->_hx___renderDirty = true;
HXLINE( 607)			this->_hx___setColorBitmap();
            		}
HXLINE( 609)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_ratios,return )

Float GradientBevelFilter_obj::get_strength(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_614_get_strength)
HXDLIN( 614)		return this->_hx___strength;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_strength,return )

Float GradientBevelFilter_obj::set_strength(Float value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_618_set_strength)
HXLINE( 619)		if ((value != this->_hx___strength)) {
HXLINE( 619)			this->_hx___renderDirty = true;
            		}
HXLINE( 620)		return (this->_hx___strength = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_strength,return )

::String GradientBevelFilter_obj::get_type(){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_625_get_type)
HXDLIN( 625)		return this->_hx___type;
            	}


HX_DEFINE_DYNAMIC_FUNC0(GradientBevelFilter_obj,get_type,return )

::String GradientBevelFilter_obj::set_type(::String value){
            	HX_STACKFRAME(&_hx_pos_00badf6175ae6572_629_set_type)
HXLINE( 630)		if ((value != this->_hx___type)) {
HXLINE( 632)			this->_hx___type = value;
HXLINE( 633)			this->_hx___renderDirty = true;
HXLINE( 634)			this->_hx___updateSize();
            		}
HXLINE( 636)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(GradientBevelFilter_obj,set_type,return )

 ::flxanimate::filters::_GradientBevelFilter::ColorRatioBevelShader GradientBevelFilter_obj::_hx___colorRatioShader;


::hx::ObjectPtr< GradientBevelFilter_obj > GradientBevelFilter_obj::__new(::hx::Null< Float >  __o_distance,::hx::Null< Float >  __o_angle,::Array< int > colors,::Array< Float > alphas,::Array< int > ratios,::hx::Null< Float >  __o_blurX,::hx::Null< Float >  __o_blurY,::hx::Null< Float >  __o_strength,::hx::Null< int >  __o_quality,::String __o_type,::hx::Null< bool >  __o_knockout) {
	::hx::ObjectPtr< GradientBevelFilter_obj > __this = new GradientBevelFilter_obj();
	__this->__construct(__o_distance,__o_angle,colors,alphas,ratios,__o_blurX,__o_blurY,__o_strength,__o_quality,__o_type,__o_knockout);
	return __this;
}

::hx::ObjectPtr< GradientBevelFilter_obj > GradientBevelFilter_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_distance,::hx::Null< Float >  __o_angle,::Array< int > colors,::Array< Float > alphas,::Array< int > ratios,::hx::Null< Float >  __o_blurX,::hx::Null< Float >  __o_blurY,::hx::Null< Float >  __o_strength,::hx::Null< int >  __o_quality,::String __o_type,::hx::Null< bool >  __o_knockout) {
	GradientBevelFilter_obj *__this = (GradientBevelFilter_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(GradientBevelFilter_obj), true, "flxanimate.filters.GradientBevelFilter"));
	*(void **)__this = GradientBevelFilter_obj::_hx_vtable;
	__this->__construct(__o_distance,__o_angle,colors,alphas,ratios,__o_blurX,__o_blurY,__o_strength,__o_quality,__o_type,__o_knockout);
	return __this;
}

GradientBevelFilter_obj::GradientBevelFilter_obj()
{
}

void GradientBevelFilter_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(GradientBevelFilter);
	HX_MARK_MEMBER_NAME(_hx___alphas,"__alphas");
	HX_MARK_MEMBER_NAME(_hx___angle,"__angle");
	HX_MARK_MEMBER_NAME(_hx___blurX,"__blurX");
	HX_MARK_MEMBER_NAME(_hx___horizontalPasses,"__horizontalPasses");
	HX_MARK_MEMBER_NAME(_hx___blurY,"__blurY");
	HX_MARK_MEMBER_NAME(_hx___verticalPasses,"__verticalPasses");
	HX_MARK_MEMBER_NAME(_hx___colors,"__colors");
	HX_MARK_MEMBER_NAME(_hx___distance,"__distance");
	HX_MARK_MEMBER_NAME(_hx___knockout,"__knockout");
	HX_MARK_MEMBER_NAME(_hx___quality,"__quality");
	HX_MARK_MEMBER_NAME(_hx___ratios,"__ratios");
	HX_MARK_MEMBER_NAME(_hx___strength,"__strength");
	HX_MARK_MEMBER_NAME(_hx___type,"__type");
	HX_MARK_MEMBER_NAME(_hx___offsetX,"__offsetX");
	HX_MARK_MEMBER_NAME(_hx___offsetY,"__offsetY");
	HX_MARK_MEMBER_NAME(_hx___colorFadeArr,"__colorFadeArr");
	 ::openfl::filters::BitmapFilter_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void GradientBevelFilter_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_hx___alphas,"__alphas");
	HX_VISIT_MEMBER_NAME(_hx___angle,"__angle");
	HX_VISIT_MEMBER_NAME(_hx___blurX,"__blurX");
	HX_VISIT_MEMBER_NAME(_hx___horizontalPasses,"__horizontalPasses");
	HX_VISIT_MEMBER_NAME(_hx___blurY,"__blurY");
	HX_VISIT_MEMBER_NAME(_hx___verticalPasses,"__verticalPasses");
	HX_VISIT_MEMBER_NAME(_hx___colors,"__colors");
	HX_VISIT_MEMBER_NAME(_hx___distance,"__distance");
	HX_VISIT_MEMBER_NAME(_hx___knockout,"__knockout");
	HX_VISIT_MEMBER_NAME(_hx___quality,"__quality");
	HX_VISIT_MEMBER_NAME(_hx___ratios,"__ratios");
	HX_VISIT_MEMBER_NAME(_hx___strength,"__strength");
	HX_VISIT_MEMBER_NAME(_hx___type,"__type");
	HX_VISIT_MEMBER_NAME(_hx___offsetX,"__offsetX");
	HX_VISIT_MEMBER_NAME(_hx___offsetY,"__offsetY");
	HX_VISIT_MEMBER_NAME(_hx___colorFadeArr,"__colorFadeArr");
	 ::openfl::filters::BitmapFilter_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val GradientBevelFilter_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_type() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"angle") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_angle() ); }
		if (HX_FIELD_EQ(inName,"blurX") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_blurX() ); }
		if (HX_FIELD_EQ(inName,"blurY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_blurY() ); }
		if (HX_FIELD_EQ(inName,"clone") ) { return ::hx::Val( clone_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"alphas") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_alphas() ); }
		if (HX_FIELD_EQ(inName,"colors") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_colors() ); }
		if (HX_FIELD_EQ(inName,"ratios") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_ratios() ); }
		if (HX_FIELD_EQ(inName,"__type") ) { return ::hx::Val( _hx___type ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"quality") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_quality() ); }
		if (HX_FIELD_EQ(inName,"__angle") ) { return ::hx::Val( _hx___angle ); }
		if (HX_FIELD_EQ(inName,"__blurX") ) { return ::hx::Val( _hx___blurX ); }
		if (HX_FIELD_EQ(inName,"__blurY") ) { return ::hx::Val( _hx___blurY ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"distance") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_distance() ); }
		if (HX_FIELD_EQ(inName,"knockout") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_knockout() ); }
		if (HX_FIELD_EQ(inName,"strength") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_strength() ); }
		if (HX_FIELD_EQ(inName,"__alphas") ) { return ::hx::Val( _hx___alphas ); }
		if (HX_FIELD_EQ(inName,"__colors") ) { return ::hx::Val( _hx___colors ); }
		if (HX_FIELD_EQ(inName,"__ratios") ) { return ::hx::Val( _hx___ratios ); }
		if (HX_FIELD_EQ(inName,"get_type") ) { return ::hx::Val( get_type_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_type") ) { return ::hx::Val( set_type_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"__quality") ) { return ::hx::Val( _hx___quality ); }
		if (HX_FIELD_EQ(inName,"__offsetX") ) { return ::hx::Val( _hx___offsetX ); }
		if (HX_FIELD_EQ(inName,"__offsetY") ) { return ::hx::Val( _hx___offsetY ); }
		if (HX_FIELD_EQ(inName,"get_angle") ) { return ::hx::Val( get_angle_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_angle") ) { return ::hx::Val( set_angle_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_blurX") ) { return ::hx::Val( get_blurX_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_blurX") ) { return ::hx::Val( set_blurX_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_blurY") ) { return ::hx::Val( get_blurY_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_blurY") ) { return ::hx::Val( set_blurY_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__distance") ) { return ::hx::Val( _hx___distance ); }
		if (HX_FIELD_EQ(inName,"__knockout") ) { return ::hx::Val( _hx___knockout ); }
		if (HX_FIELD_EQ(inName,"__strength") ) { return ::hx::Val( _hx___strength ); }
		if (HX_FIELD_EQ(inName,"get_alphas") ) { return ::hx::Val( get_alphas_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_alphas") ) { return ::hx::Val( set_alphas_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_colors") ) { return ::hx::Val( get_colors_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_colors") ) { return ::hx::Val( set_colors_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_ratios") ) { return ::hx::Val( get_ratios_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_ratios") ) { return ::hx::Val( set_ratios_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"get_quality") ) { return ::hx::Val( get_quality_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_quality") ) { return ::hx::Val( set_quality_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"__initShader") ) { return ::hx::Val( _hx___initShader_dyn() ); }
		if (HX_FIELD_EQ(inName,"__updateSize") ) { return ::hx::Val( _hx___updateSize_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_distance") ) { return ::hx::Val( get_distance_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_distance") ) { return ::hx::Val( set_distance_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_knockout") ) { return ::hx::Val( get_knockout_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_knockout") ) { return ::hx::Val( set_knockout_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_strength") ) { return ::hx::Val( get_strength_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_strength") ) { return ::hx::Val( set_strength_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"__colorFadeArr") ) { return ::hx::Val( _hx___colorFadeArr ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"__verticalPasses") ) { return ::hx::Val( _hx___verticalPasses ); }
		if (HX_FIELD_EQ(inName,"__setColorBitmap") ) { return ::hx::Val( _hx___setColorBitmap_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"__horizontalPasses") ) { return ::hx::Val( _hx___horizontalPasses ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"__calculateNumShaderPasses") ) { return ::hx::Val( _hx___calculateNumShaderPasses_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool GradientBevelFilter_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 18:
		if (HX_FIELD_EQ(inName,"__colorRatioShader") ) { outValue = ( _hx___colorRatioShader ); return true; }
	}
	return false;
}

::hx::Val GradientBevelFilter_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_type(inValue.Cast< ::String >()) ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"angle") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_angle(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"blurX") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_blurX(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"blurY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_blurY(inValue.Cast< Float >()) ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"alphas") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_alphas(inValue.Cast< ::Array< Float > >()) ); }
		if (HX_FIELD_EQ(inName,"colors") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_colors(inValue.Cast< ::Array< int > >()) ); }
		if (HX_FIELD_EQ(inName,"ratios") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_ratios(inValue.Cast< ::Array< int > >()) ); }
		if (HX_FIELD_EQ(inName,"__type") ) { _hx___type=inValue.Cast< ::String >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"quality") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_quality(inValue.Cast< int >()) ); }
		if (HX_FIELD_EQ(inName,"__angle") ) { _hx___angle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__blurX") ) { _hx___blurX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__blurY") ) { _hx___blurY=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"distance") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_distance(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"knockout") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_knockout(inValue.Cast< bool >()) ); }
		if (HX_FIELD_EQ(inName,"strength") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_strength(inValue.Cast< Float >()) ); }
		if (HX_FIELD_EQ(inName,"__alphas") ) { _hx___alphas=inValue.Cast< ::Array< Float > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__colors") ) { _hx___colors=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__ratios") ) { _hx___ratios=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"__quality") ) { _hx___quality=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__offsetX") ) { _hx___offsetX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__offsetY") ) { _hx___offsetY=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"__distance") ) { _hx___distance=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__knockout") ) { _hx___knockout=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"__strength") ) { _hx___strength=inValue.Cast< Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"__colorFadeArr") ) { _hx___colorFadeArr=inValue.Cast<  ::openfl::utils::ByteArrayData >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"__verticalPasses") ) { _hx___verticalPasses=inValue.Cast< int >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"__horizontalPasses") ) { _hx___horizontalPasses=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool GradientBevelFilter_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 18:
		if (HX_FIELD_EQ(inName,"__colorRatioShader") ) { _hx___colorRatioShader=ioValue.Cast<  ::flxanimate::filters::_GradientBevelFilter::ColorRatioBevelShader >(); return true; }
	}
	return false;
}

void GradientBevelFilter_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("alphas",55,cb,3b,42));
	outFields->push(HX_("angle",d3,43,e2,22));
	outFields->push(HX_("blurX",d1,0f,01,b5));
	outFields->push(HX_("blurY",d2,0f,01,b5));
	outFields->push(HX_("colors",b0,c5,86,c6));
	outFields->push(HX_("distance",35,93,f9,6b));
	outFields->push(HX_("knockout",fa,a9,a5,6f));
	outFields->push(HX_("quality",bf,04,4c,44));
	outFields->push(HX_("ratios",08,35,8a,bb));
	outFields->push(HX_("strength",81,d2,8e,8e));
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("__alphas",75,36,6b,ea));
	outFields->push(HX_("__angle",b3,9c,40,8d));
	outFields->push(HX_("__blurX",b1,68,5f,1f));
	outFields->push(HX_("__horizontalPasses",a3,9a,5d,02));
	outFields->push(HX_("__blurY",b2,68,5f,1f));
	outFields->push(HX_("__verticalPasses",b5,4b,f5,ec));
	outFields->push(HX_("__colors",d0,30,b6,6e));
	outFields->push(HX_("__distance",55,06,32,0f));
	outFields->push(HX_("__knockout",1a,1d,de,12));
	outFields->push(HX_("__quality",9f,55,9a,c5));
	outFields->push(HX_("__ratios",28,a0,b9,63));
	outFields->push(HX_("__strength",a1,45,c7,31));
	outFields->push(HX_("__type",da,55,01,fc));
	outFields->push(HX_("__offsetX",45,5a,b3,58));
	outFields->push(HX_("__offsetY",46,5a,b3,58));
	outFields->push(HX_("__colorFadeArr",42,12,49,7b));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo GradientBevelFilter_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(GradientBevelFilter_obj,_hx___alphas),HX_("__alphas",75,36,6b,ea)},
	{::hx::fsFloat,(int)offsetof(GradientBevelFilter_obj,_hx___angle),HX_("__angle",b3,9c,40,8d)},
	{::hx::fsFloat,(int)offsetof(GradientBevelFilter_obj,_hx___blurX),HX_("__blurX",b1,68,5f,1f)},
	{::hx::fsInt,(int)offsetof(GradientBevelFilter_obj,_hx___horizontalPasses),HX_("__horizontalPasses",a3,9a,5d,02)},
	{::hx::fsFloat,(int)offsetof(GradientBevelFilter_obj,_hx___blurY),HX_("__blurY",b2,68,5f,1f)},
	{::hx::fsInt,(int)offsetof(GradientBevelFilter_obj,_hx___verticalPasses),HX_("__verticalPasses",b5,4b,f5,ec)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(GradientBevelFilter_obj,_hx___colors),HX_("__colors",d0,30,b6,6e)},
	{::hx::fsFloat,(int)offsetof(GradientBevelFilter_obj,_hx___distance),HX_("__distance",55,06,32,0f)},
	{::hx::fsBool,(int)offsetof(GradientBevelFilter_obj,_hx___knockout),HX_("__knockout",1a,1d,de,12)},
	{::hx::fsInt,(int)offsetof(GradientBevelFilter_obj,_hx___quality),HX_("__quality",9f,55,9a,c5)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(GradientBevelFilter_obj,_hx___ratios),HX_("__ratios",28,a0,b9,63)},
	{::hx::fsFloat,(int)offsetof(GradientBevelFilter_obj,_hx___strength),HX_("__strength",a1,45,c7,31)},
	{::hx::fsString,(int)offsetof(GradientBevelFilter_obj,_hx___type),HX_("__type",da,55,01,fc)},
	{::hx::fsFloat,(int)offsetof(GradientBevelFilter_obj,_hx___offsetX),HX_("__offsetX",45,5a,b3,58)},
	{::hx::fsFloat,(int)offsetof(GradientBevelFilter_obj,_hx___offsetY),HX_("__offsetY",46,5a,b3,58)},
	{::hx::fsObject /*  ::openfl::utils::ByteArrayData */ ,(int)offsetof(GradientBevelFilter_obj,_hx___colorFadeArr),HX_("__colorFadeArr",42,12,49,7b)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo GradientBevelFilter_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::flxanimate::filters::_GradientBevelFilter::ColorRatioBevelShader */ ,(void *) &GradientBevelFilter_obj::_hx___colorRatioShader,HX_("__colorRatioShader",0d,01,2d,3b)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String GradientBevelFilter_obj_sMemberFields[] = {
	HX_("__alphas",75,36,6b,ea),
	HX_("__angle",b3,9c,40,8d),
	HX_("__blurX",b1,68,5f,1f),
	HX_("__horizontalPasses",a3,9a,5d,02),
	HX_("__blurY",b2,68,5f,1f),
	HX_("__verticalPasses",b5,4b,f5,ec),
	HX_("__colors",d0,30,b6,6e),
	HX_("__distance",55,06,32,0f),
	HX_("__knockout",1a,1d,de,12),
	HX_("__quality",9f,55,9a,c5),
	HX_("__ratios",28,a0,b9,63),
	HX_("__strength",a1,45,c7,31),
	HX_("__type",da,55,01,fc),
	HX_("__offsetX",45,5a,b3,58),
	HX_("__offsetY",46,5a,b3,58),
	HX_("__colorFadeArr",42,12,49,7b),
	HX_("clone",5d,13,63,48),
	HX_("__initShader",75,95,f9,59),
	HX_("__updateSize",8a,06,9c,3d),
	HX_("__calculateNumShaderPasses",44,14,02,b7),
	HX_("__setColorBitmap",50,68,32,87),
	HX_("get_alphas",1e,3b,c3,32),
	HX_("set_alphas",92,d9,40,36),
	HX_("get_angle",2a,a0,8b,66),
	HX_("set_angle",36,8c,dc,49),
	HX_("get_blurX",28,6c,aa,f8),
	HX_("set_blurX",34,58,fb,db),
	HX_("get_blurY",29,6c,aa,f8),
	HX_("set_blurY",35,58,fb,db),
	HX_("get_colors",79,35,0e,b7),
	HX_("set_colors",ed,d3,8b,ba),
	HX_("get_distance",3e,47,13,21),
	HX_("set_distance",b2,6a,0c,36),
	HX_("get_knockout",03,5e,bf,24),
	HX_("set_knockout",77,81,b8,39),
	HX_("get_quality",d6,64,46,ca),
	HX_("set_quality",e2,6b,b3,d4),
	HX_("get_ratios",d1,a4,11,ac),
	HX_("set_ratios",45,43,8f,af),
	HX_("get_strength",8a,86,a8,43),
	HX_("set_strength",fe,a9,a1,58),
	HX_("get_type",43,ae,c3,cc),
	HX_("set_type",b7,07,21,7b),
	::String(null()) };

static void GradientBevelFilter_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GradientBevelFilter_obj::_hx___colorRatioShader,"__colorRatioShader");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GradientBevelFilter_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GradientBevelFilter_obj::_hx___colorRatioShader,"__colorRatioShader");
};

#endif

::hx::Class GradientBevelFilter_obj::__mClass;

static ::String GradientBevelFilter_obj_sStaticFields[] = {
	HX_("__colorRatioShader",0d,01,2d,3b),
	::String(null())
};

void GradientBevelFilter_obj::__register()
{
	GradientBevelFilter_obj _hx_dummy;
	GradientBevelFilter_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flxanimate.filters.GradientBevelFilter",f0,9c,67,08);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GradientBevelFilter_obj::__GetStatic;
	__mClass->mSetStaticField = &GradientBevelFilter_obj::__SetStatic;
	__mClass->mMarkFunc = GradientBevelFilter_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(GradientBevelFilter_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(GradientBevelFilter_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< GradientBevelFilter_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GradientBevelFilter_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GradientBevelFilter_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GradientBevelFilter_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void GradientBevelFilter_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_00badf6175ae6572_57_boot)
HXDLIN(  57)		_hx___colorRatioShader =  ::flxanimate::filters::_GradientBevelFilter::ColorRatioBevelShader_obj::__alloc( HX_CTX );
            	}
}

} // end namespace flxanimate
} // end namespace filters
