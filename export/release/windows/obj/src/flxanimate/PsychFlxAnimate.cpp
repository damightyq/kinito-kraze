// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_Xml
#include <Xml.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flxanimate_FlxAnimate
#include <flxanimate/FlxAnimate.h>
#endif
#ifndef INCLUDED_flxanimate_PsychFlxAnimate
#include <flxanimate/PsychFlxAnimate.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxAnim
#include <flxanimate/animate/FlxAnim.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxElement
#include <flxanimate/animate/FlxElement.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxMetaData
#include <flxanimate/animate/FlxMetaData.h>
#endif
#ifndef INCLUDED_flxanimate_animate_FlxSymbol
#include <flxanimate/animate/FlxSymbol.h>
#endif
#ifndef INCLUDED_flxanimate_animate_SymbolParameters
#include <flxanimate/animate/SymbolParameters.h>
#endif
#ifndef INCLUDED_flxanimate_frames_FlxAnimateFrames
#include <flxanimate/frames/FlxAnimateFrames.h>
#endif
#ifndef INCLUDED_flxanimate_interfaces_IFilterable
#include <flxanimate/interfaces/IFilterable.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_807c05833712c389_9_new,"flxanimate.PsychFlxAnimate","new",0x9b1bb9bd,"flxanimate.PsychFlxAnimate.new","flxanimate/PsychFlxAnimate.hx",9,0x6d10a094)
HX_LOCAL_STACK_FRAME(_hx_pos_807c05833712c389_12_loadAtlasEx,"flxanimate.PsychFlxAnimate","loadAtlasEx",0xf76d7f75,"flxanimate.PsychFlxAnimate.loadAtlasEx","flxanimate/PsychFlxAnimate.hx",12,0x6d10a094)
HX_LOCAL_STACK_FRAME(_hx_pos_807c05833712c389_71_draw,"flxanimate.PsychFlxAnimate","draw",0x16947407,"flxanimate.PsychFlxAnimate.draw","flxanimate/PsychFlxAnimate.hx",71,0x6d10a094)
HX_LOCAL_STACK_FRAME(_hx_pos_807c05833712c389_78_destroy,"flxanimate.PsychFlxAnimate","destroy",0x183a88d7,"flxanimate.PsychFlxAnimate.destroy","flxanimate/PsychFlxAnimate.hx",78,0x6d10a094)
HX_LOCAL_STACK_FRAME(_hx_pos_807c05833712c389_93__removeBOM,"flxanimate.PsychFlxAnimate","_removeBOM",0x33d2e820,"flxanimate.PsychFlxAnimate._removeBOM","flxanimate/PsychFlxAnimate.hx",93,0x6d10a094)
HX_LOCAL_STACK_FRAME(_hx_pos_807c05833712c389_99_pauseAnimation,"flxanimate.PsychFlxAnimate","pauseAnimation",0x4e7df2f1,"flxanimate.PsychFlxAnimate.pauseAnimation","flxanimate/PsychFlxAnimate.hx",99,0x6d10a094)
HX_LOCAL_STACK_FRAME(_hx_pos_807c05833712c389_104_resumeAnimation,"flxanimate.PsychFlxAnimate","resumeAnimation",0xe3f04874,"flxanimate.PsychFlxAnimate.resumeAnimation","flxanimate/PsychFlxAnimate.hx",104,0x6d10a094)
namespace flxanimate{

void PsychFlxAnimate_obj::__construct( ::Dynamic X, ::Dynamic Y,::String Path, ::Dynamic Settings){
            	HX_STACKFRAME(&_hx_pos_807c05833712c389_9_new)
HXDLIN(   9)		super::__construct(X,Y,Path,Settings);
            	}

Dynamic PsychFlxAnimate_obj::__CreateEmpty() { return new PsychFlxAnimate_obj; }

void *PsychFlxAnimate_obj::_hx_vtable = 0;

Dynamic PsychFlxAnimate_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PsychFlxAnimate_obj > _hx_result = new PsychFlxAnimate_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool PsychFlxAnimate_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x6d2f127b) {
		if (inClassId<=(int)0x2c01639b) {
			if (inClassId<=(int)0x0943d942) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0943d942;
			} else {
				return inClassId==(int)0x2c01639b;
			}
		} else {
			return inClassId==(int)0x6d2f127b;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void PsychFlxAnimate_obj::loadAtlasEx( ::Dynamic img,::String pathOrStr, ::Dynamic myJson){
            	HX_GC_STACKFRAME(&_hx_pos_807c05833712c389_12_loadAtlasEx)
HXLINE(  13)		 ::Dynamic animJson = null();
HXLINE(  14)		if (::Std_obj::isOfType(myJson,::hx::ClassOf< ::String >())) {
HXLINE(  16)			::String trimmed = ::StringTools_obj::trim(pathOrStr);
HXLINE(  17)			trimmed = trimmed.substr((trimmed.length - 5),null()).toLowerCase();
HXLINE(  19)			if ((trimmed == HX_(".json",56,f1,d6,c2))) {
HXLINE(  19)				myJson = ::sys::io::File_obj::getContent(( (::String)(myJson) ));
            			}
HXLINE(  20)			animJson =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,this->_removeBOM(( (::String)(myJson) )))->doParse();
            		}
            		else {
HXLINE(  22)			animJson = myJson;
            		}
HXLINE(  24)		 ::Dynamic isXml = null();
HXLINE(  25)		 ::Dynamic myData = pathOrStr;
HXLINE(  27)		::String trimmed1 = ::StringTools_obj::trim(pathOrStr);
HXLINE(  28)		trimmed1 = trimmed1.substr((trimmed1.length - 5),null()).toLowerCase();
HXLINE(  30)		if ((trimmed1 == HX_(".json",56,f1,d6,c2))) {
HXLINE(  32)			myData = ::sys::io::File_obj::getContent(pathOrStr);
HXLINE(  33)			isXml = false;
            		}
            		else {
HXLINE(  35)			if ((trimmed1.substr(1,null()) == HX_(".xml",69,3e,c3,1e))) {
HXLINE(  37)				myData = ::sys::io::File_obj::getContent(pathOrStr);
HXLINE(  38)				isXml = true;
            			}
            		}
HXLINE(  40)		myData = this->_removeBOM(( (::String)(myData) ));
HXLINE(  43)		if (::hx::IsNull( isXml )) {
HXLINE(  50)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  52)				myData =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,( (::String)(myData) ))->doParse();
HXLINE(  53)				isXml = false;
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g = _hx_e;
HXLINE(  58)					myData = ::Xml_obj::parse(( (::String)(myData) ));
HXLINE(  59)					isXml = true;
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
            		}
            		else {
HXLINE(  43)			if (( (bool)(isXml) )) {
HXLINE(  46)				myData = ::Xml_obj::parse(( (::String)(myData) ));
            			}
            			else {
HXLINE(  48)				myData =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,( (::String)(myData) ))->doParse();
            			}
            		}
HXLINE(  64)		this->anim->_loadAtlas(animJson);
HXLINE(  65)		if (!(( (bool)(isXml) ))) {
HXLINE(  65)			this->set_frames(::flxanimate::frames::FlxAnimateFrames_obj::fromSpriteMap(myData,img));
            		}
            		else {
HXLINE(  66)			this->set_frames(::flxanimate::frames::FlxAnimateFrames_obj::fromSparrow(myData,img));
            		}
HXLINE(  67)		this->origin = this->anim->curInstance->symbol->transformationPoint;
            	}


HX_DEFINE_DYNAMIC_FUNC3(PsychFlxAnimate_obj,loadAtlasEx,(void))

void PsychFlxAnimate_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_807c05833712c389_71_draw)
HXLINE(  72)		bool _hx_tmp;
HXDLIN(  72)		if (::hx::IsNotNull( this->anim->curInstance )) {
HXLINE(  72)			_hx_tmp = ::hx::IsNull( this->anim->get_curSymbol() );
            		}
            		else {
HXLINE(  72)			_hx_tmp = true;
            		}
HXDLIN(  72)		if (_hx_tmp) {
HXLINE(  72)			return;
            		}
HXLINE(  73)		this->super::draw();
            	}


void PsychFlxAnimate_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_807c05833712c389_78_destroy)
HXDLIN(  78)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  80)			this->super::destroy();
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE(  84)				this->anim->curInstance = ( ( ::flxanimate::animate::FlxElement)(::flixel::util::FlxDestroyUtil_obj::destroy(this->anim->curInstance)) );
HXLINE(  85)				this->anim->stageInstance = ( ( ::flxanimate::animate::FlxElement)(::flixel::util::FlxDestroyUtil_obj::destroy(this->anim->stageInstance)) );
HXLINE(  87)				this->anim->metadata->destroy();
HXLINE(  88)				this->anim->symbolDictionary = null();
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
            	}


::String PsychFlxAnimate_obj::_removeBOM(::String str){
            	HX_STACKFRAME(&_hx_pos_807c05833712c389_93__removeBOM)
HXLINE(  94)		if (::hx::IsEq( str.charCodeAt(0),65279 )) {
HXLINE(  94)			str = str.substr(1,null());
            		}
HXLINE(  95)		return str;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychFlxAnimate_obj,_removeBOM,return )

void PsychFlxAnimate_obj::pauseAnimation(){
            	HX_STACKFRAME(&_hx_pos_807c05833712c389_99_pauseAnimation)
HXLINE( 100)		bool _hx_tmp;
HXDLIN( 100)		if (::hx::IsNotNull( this->anim->curInstance )) {
HXLINE( 100)			_hx_tmp = ::hx::IsNull( this->anim->get_curSymbol() );
            		}
            		else {
HXLINE( 100)			_hx_tmp = true;
            		}
HXDLIN( 100)		if (_hx_tmp) {
HXLINE( 100)			return;
            		}
HXLINE( 101)		this->anim->pause();
            	}


HX_DEFINE_DYNAMIC_FUNC0(PsychFlxAnimate_obj,pauseAnimation,(void))

void PsychFlxAnimate_obj::resumeAnimation(){
            	HX_STACKFRAME(&_hx_pos_807c05833712c389_104_resumeAnimation)
HXLINE( 105)		bool _hx_tmp;
HXDLIN( 105)		if (::hx::IsNotNull( this->anim->curInstance )) {
HXLINE( 105)			_hx_tmp = ::hx::IsNull( this->anim->get_curSymbol() );
            		}
            		else {
HXLINE( 105)			_hx_tmp = true;
            		}
HXDLIN( 105)		if (_hx_tmp) {
HXLINE( 105)			return;
            		}
HXLINE( 106)		this->anim->play(null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(PsychFlxAnimate_obj,resumeAnimation,(void))


::hx::ObjectPtr< PsychFlxAnimate_obj > PsychFlxAnimate_obj::__new( ::Dynamic X, ::Dynamic Y,::String Path, ::Dynamic Settings) {
	::hx::ObjectPtr< PsychFlxAnimate_obj > __this = new PsychFlxAnimate_obj();
	__this->__construct(X,Y,Path,Settings);
	return __this;
}

::hx::ObjectPtr< PsychFlxAnimate_obj > PsychFlxAnimate_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic X, ::Dynamic Y,::String Path, ::Dynamic Settings) {
	PsychFlxAnimate_obj *__this = (PsychFlxAnimate_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PsychFlxAnimate_obj), true, "flxanimate.PsychFlxAnimate"));
	*(void **)__this = PsychFlxAnimate_obj::_hx_vtable;
	__this->__construct(X,Y,Path,Settings);
	return __this;
}

PsychFlxAnimate_obj::PsychFlxAnimate_obj()
{
}

::hx::Val PsychFlxAnimate_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_removeBOM") ) { return ::hx::Val( _removeBOM_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"loadAtlasEx") ) { return ::hx::Val( loadAtlasEx_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"pauseAnimation") ) { return ::hx::Val( pauseAnimation_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"resumeAnimation") ) { return ::hx::Val( resumeAnimation_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *PsychFlxAnimate_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *PsychFlxAnimate_obj_sStaticStorageInfo = 0;
#endif

static ::String PsychFlxAnimate_obj_sMemberFields[] = {
	HX_("loadAtlasEx",18,71,61,63),
	HX_("draw",04,2c,70,42),
	HX_("destroy",fa,2c,86,24),
	HX_("_removeBOM",dd,3b,88,26),
	HX_("pauseAnimation",2e,69,94,54),
	HX_("resumeAnimation",97,47,81,31),
	::String(null()) };

::hx::Class PsychFlxAnimate_obj::__mClass;

void PsychFlxAnimate_obj::__register()
{
	PsychFlxAnimate_obj _hx_dummy;
	PsychFlxAnimate_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flxanimate.PsychFlxAnimate",4b,17,7b,bc);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PsychFlxAnimate_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PsychFlxAnimate_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PsychFlxAnimate_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PsychFlxAnimate_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flxanimate
