// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderInput_openfl_display_BitmapData
#include <openfl/display/ShaderInput_openfl_display_BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Int
#include <openfl/display/ShaderParameter_Int.h>
#endif
#ifndef INCLUDED_shaders_RainShader
#include <shaders/RainShader.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0533870a35796cfb_16_new,"shaders.RainShader","new",0xad9befeb,"shaders.RainShader.new","shaders/RainShader.hx",16,0x97d50944)
static const Float _hx_array_data_db7d1e79_1[] = {
	1.0,
};
static const Float _hx_array_data_db7d1e79_2[] = {
	1.0,
};
static const Float _hx_array_data_db7d1e79_3[] = {
	0.5,
};
static const Float _hx_array_data_db7d1e79_4[] = {
	0.0,
};
static const Float _hx_array_data_db7d1e79_5[] = {
	0.0,
};
static const int _hx_array_data_db7d1e79_6[] = {
	(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_370_set_time,"shaders.RainShader","set_time",0x4c97899f,"shaders.RainShader.set_time","shaders/RainShader.hx",370,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_381_set_scale,"shaders.RainShader","set_scale",0x2099f0b8,"shaders.RainShader.set_scale","shaders/RainShader.hx",381,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_390_set_intensity,"shaders.RainShader","set_intensity",0xfa5097e1,"shaders.RainShader.set_intensity","shaders/RainShader.hx",390,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_399_set_puddleY,"shaders.RainShader","set_puddleY",0x5a1d59c9,"shaders.RainShader.set_puddleY","shaders/RainShader.hx",399,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_408_set_puddleScaleY,"shaders.RainShader","set_puddleScaleY",0xd892cf3f,"shaders.RainShader.set_puddleScaleY","shaders/RainShader.hx",408,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_416_set_blurredScreen,"shaders.RainShader","set_blurredScreen",0x141c8c44,"shaders.RainShader.set_blurredScreen","shaders/RainShader.hx",416,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_424_set_mask,"shaders.RainShader","set_mask",0x47f0fe7e,"shaders.RainShader.set_mask","shaders/RainShader.hx",424,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_432_set_lightMap,"shaders.RainShader","set_lightMap",0x2da9c9f8,"shaders.RainShader.set_lightMap","shaders/RainShader.hx",432,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_440_set_numLightsSwag,"shaders.RainShader","set_numLightsSwag",0x18da6a1b,"shaders.RainShader.set_numLightsSwag","shaders/RainShader.hx",440,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_459_update,"shaders.RainShader","update",0x303b6f5e,"shaders.RainShader.update","shaders/RainShader.hx",459,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_479_updateViewInfo,"shaders.RainShader","updateViewInfo",0xe0f5e6f1,"shaders.RainShader.updateViewInfo","shaders/RainShader.hx",479,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_500_addFloatUniform,"shaders.RainShader","addFloatUniform",0x79bcfec4,"shaders.RainShader.addFloatUniform","shaders/RainShader.hx",500,0x97d50944)
HX_LOCAL_STACK_FRAME(_hx_pos_0533870a35796cfb_358_boot,"shaders.RainShader","boot",0x32eefe47,"shaders.RainShader.boot","shaders/RainShader.hx",358,0x97d50944)
namespace shaders{

void RainShader_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_16_new)
HXLINE( 437)		this->numLightsSwag = 0;
HXLINE( 405)		this->puddleScaleY = ((Float)0);
HXLINE( 396)		this->puddleY = ((Float)0);
HXLINE( 387)		this->intensity = ((Float)0.5);
HXLINE( 378)		this->scale = ((Float)1);
HXLINE( 367)		this->time = ((Float)1);
HXLINE( 182)		if (::hx::IsNull( this->_hx___glFragmentSource )) {
HXLINE( 184)			this->_hx___glFragmentSource = HX_("\n\t  \t\tvarying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\t\tuniform sampler2D bitmap;\n\n\t\tuniform bool hasTransform;\n\t\tuniform bool hasColorTransform;\n\n\t\tvec4 flixel_texture2D(sampler2D bitmap, vec2 coord)\n\t\t{\n\t\t\tvec4 color = texture2D(bitmap, coord);\n\t\t\tif (!hasTransform)\n\t\t\t{\n\t\t\t\treturn color;\n\t\t\t}\n\n\t\t\tif (color.a == 0.0)\n\t\t\t{\n\t\t\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\t}\n\n\t\t\tif (!hasColorTransform)\n\t\t\t{\n\t\t\t\treturn color * openfl_Alphav;\n\t\t\t}\n\n\t\t\tcolor = vec4(color.rgb / color.a, color.a);\n\n\t\t\tmat4 colorMultiplier = mat4(0);\n\t\t\tcolorMultiplier[0][0] = openfl_ColorMultiplierv.x;\n\t\t\tcolorMultiplier[1][1] = openfl_ColorMultiplierv.y;\n\t\t\tcolorMultiplier[2][2] = openfl_ColorMultiplierv.z;\n\t\t\tcolorMultiplier[3][3] = openfl_ColorMultiplierv.w;\n\n\t\t\tcolor = clamp(openfl_ColorOffsetv + (color * colorMultiplier), 0.0, 1.0);\n\n\t\t\tif (color.a > 0.0)\n\t\t\t{\n\t\t\t\treturn vec4(color.rgb * color.a * openfl_Alphav, color.a * openfl_Alphav);\n\t\t\t}\n\t\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n\t\t}\n\t\n\n\t\t  // normalized screen coord\n\t\t  //   (0, 0) is the top left of the window\n\t\t  //   (1, 1) is the bottom right of the window\n\t\t  varying vec2 screenCoord;\n  \n\t\t  // equals (FlxG.width, FlxG.height)\n\t\t  uniform vec2 uScreenResolution;\n  \n\t\t  // equals (camera.viewLeft, camera.viewTop, camera.viewRight, camera.viewBottom)\n\t\t  uniform vec4 uCameraBounds;\n  \n\t\t  // screen coord -> world coord conversion\n\t\t  // returns world coord in px\n\t\t  vec2 screenToWorld(vec2 screenCoord) {\n\t\t\t  float left = uCameraBounds.x;\n\t\t\t  float top = uCameraBounds.y;\n\t\t\t  float right = uCameraBounds.z;\n\t\t\t  float bottom = uCameraBounds.w;\n\t\t\t  vec2 scale = vec2(right - left, bottom - top);\n\t\t\t  vec2 offset = vec2(left, top);\n\t\t\t  return screenCoord * scale + offset;\n\t\t  }\n  \n\t\t  // world coord -> screen coord conversion\n\t\t  // returns normalized screen coord\n\t\t  vec2 worldToScreen(vec2 worldCoord) {\n\t\t\t  float left = uCameraBounds.x;\n\t\t\t  float top = uCameraBounds.y;\n\t\t\t  float right = uCameraBounds.z;\n\t\t\t  float bottom = uCameraBounds.w;\n\t\t\t  vec2 scale = vec2(right - left, bottom - top);\n\t\t\t  vec2 offset = vec2(left, top);\n\t\t\t  return (worldCoord - offset) / scale;\n\t\t  }\n  \n\t\t  // internally used to get the maximum `openfl_TextureCoordv`\n\t\t  vec2 bitmapCoordScale() {\n\t\t\t  return openfl_TextureCoordv / screenCoord;\n\t\t  }\n  \n\t\t  // internally used to compute bitmap coord\n\t\t  vec2 screenToBitmap(vec2 screenCoord) {\n\t\t\t  return screenCoord * bitmapCoordScale();\n\t\t  }\n  \n\t\t  // samples the frame buffer using a screen coord\n\t\t  vec4 sampleBitmapScreen(vec2 screenCoord) {\n\t\t\t  return texture2D(bitmap, screenToBitmap(screenCoord));\n\t\t  }\n  \n\t\t  // samples the frame buffer using a world coord\n\t\t  vec4 sampleBitmapWorld(vec2 worldCoord) {\n\t\t\t  return sampleBitmapScreen(worldToScreen(worldCoord));\n\t\t  }\n\t  \n\n\t\t\t// TODO: shouldn't this be isolated?\n\n\t\t\t//\n\t\t\t// Description : Array and textureless GLSL 2D/3D/4D simplex\n\t\t\t//               noise functions.\n\t\t\t//      Author : Ian McEwan, Ashima Arts.\n\t\t\t//  Maintainer : stegu\n\t\t\t//     Lastmod : 20201014 (stegu)\n\t\t\t//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\t\t\t//               Distributed under the MIT License. See LICENSE file.\n\t\t\t//               https://github.com/ashima/webgl-noise\n\t\t\t//               https://github.com/stegu/webgl-noise\n\t\t\t//\n\n\t\t\tvec3 mod289(vec3 x) {\n\t\t\t\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t\t}\n\n\t\t\tvec4 mod289(vec4 x) {\n\t\t\t\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t\t}\n\n\t\t\tvec4 permute(vec4 x) {\n\t\t\t\treturn mod289(((x*34.0)+10.0)*x);\n\t\t\t}\n\n\t\t\tvec4 taylorInvSqrt(vec4 r) {\n\t\t\t\treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t\t}\n\n\t\t\tfloat snoise(vec3 v) {\n\t\t\t\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n\t\t\t\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t\t\t\t// First corner\n\t\t\t\tvec3 i  = floor(v + dot(v, C.yyy) );\n\t\t\t\tvec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\t\t\t\t// Other corners\n\t\t\t\tvec3 g = step(x0.yzx, x0.xyz);\n\t\t\t\tvec3 l = 1.0 - g;\n\t\t\t\tvec3 i1 = min( g.xyz, l.zxy );\n\t\t\t\tvec3 i2 = max( g.xyz, l.zxy );\n\n\t\t\t\t//   x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t\t\t\t//   x1 = x0 - i1  + 1.0 * C.xxx;\n\t\t\t\t//   x2 = x0 - i2  + 2.0 * C.xxx;\n\t\t\t\t//   x3 = x0 - 1.0 + 3.0 * C.xxx;\n\t\t\t\tvec3 x1 = x0 - i1 + C.xxx;\n\t\t\t\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\t\t\t\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t\t\t\t// Permutations\n\t\t\t\ti = mod289(i);\n\t\t\t\tvec4 p = permute( permute( permute(\n\t\t\t\t\t\t\ti.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t\t\t\t\t+ i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t\t\t\t\t\t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\t\t\t\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t\t\t\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\t\t\t\tfloat n_ = 0.142857142857; // 1.0/7.0\n\t\t\t\tvec3  ns = n_ * D.wyz - D.xzx;\n\n\t\t\t\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n\t\t\t\tvec4 x_ = floor(j * ns.z);\n\t\t\t\tvec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n\t\t\t\tvec4 x = x_ *ns.x + ns.yyyy;\n\t\t\t\tvec4 y = y_ *ns.x + ns.yyyy;\n\t\t\t\tvec4 h = 1.0 - abs(x) - abs(y);\n\n\t\t\t\tvec4 b0 = vec4( x.xy, y.xy );\n\t\t\t\tvec4 b1 = vec4( x.zw, y.zw );\n\n\t\t\t\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t\t\t\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\t\t\t\tvec4 s0 = floor(b0)*2.0 + 1.0;\n\t\t\t\tvec4 s1 = floor(b1)*2.0 + 1.0;\n\t\t\t\tvec4 sh = -step(h, vec4(0.0));\n\n\t\t\t\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\t\t\t\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n\t\t\t\tvec3 p0 = vec3(a0.xy,h.x);\n\t\t\t\tvec3 p1 = vec3(a0.zw,h.y);\n\t\t\t\tvec3 p2 = vec3(a1.xy,h.z);\n\t\t\t\tvec3 p3 = vec3(a1.zw,h.w);\n\n\t\t\t\t//Normalise gradients\n\t\t\t\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\t\t\t\tp0 *= norm.x;\n\t\t\t\tp1 *= norm.y;\n\t\t\t\tp2 *= norm.z;\n\t\t\t\tp3 *= norm.w;\n\n\t\t\t\t// Mix final noise value\n\t\t\t\tvec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\t\t\t\tm = m * m;\n\t\t\t\treturn 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n\t\t\t\t\t\t\t\t\t\t\t\tdot(p2,x2), dot(p3,x3) ) );\n\t\t\t}\n\n\t\t\tstruct Light {\n\t\t\t\tvec2 position;\n\t\t\t\tvec3 color;\n\t\t\t\tfloat radius;\n\t\t\t};\n\n\t\t\t// prevent auto field generation\n\t\t\t#define UNIFORM uniform\n\n\t\t\tuniform float uScale;\n\t\t\tuniform float uIntensity;\n\t\t\tuniform float uTime;\n\t\t\tuniform float uPuddleY;\n\t\t\tuniform float uPuddleScaleY;\n\t\t\tuniform sampler2D uBlurredScreen;\n\t\t\tuniform sampler2D uMask;\n\t\t\tuniform sampler2D uLightMap;\n\t\t\tuniform int numLights;\n\n\t\t\tconst int MAX_LIGHTS = 8;\n\t\t\tUNIFORM Light lights[MAX_LIGHTS];\n\n\t\t\tfloat rand(vec2 a) {\n\t\t\t\treturn fract(sin(dot(mod(a, vec2(1000.0)).xy, vec2(12.9898, 78.233))) * 43758.5453);\n\t\t\t}\n\n\t\t\tfloat ease(float t) {\n\t\t\t\treturn t * t * (3.0 - 2.0 * t);\n\t\t\t}\n\n\t\t\tfloat rainDist(vec2 p, float scale, float intensity) {\n\t\t\t\t// scale everything\n\t\t\t\tp *= 0.1;\n\t\t\t\t// sheer\n\t\t\t\tp.x += p.y * 0.1;\n\t\t\t\t// scroll\n\t\t\t\tp.y -= uTime * 500.0 / scale;\n\t\t\t\t// expand Y\n\t\t\t\tp.y *= 0.03;\n\t\t\t\tfloat ix = floor(p.x);\n\t\t\t\t// shift Y\n\t\t\t\tp.y += mod(ix, 2.0) * 0.5 + (rand(vec2(ix)) - 0.5) * 0.3;\n\t\t\t\tfloat iy = floor(p.y);\n\t\t\t\tvec2 index = vec2(ix, iy);\n\t\t\t\t// mod\n\t\t\t\tp -= index;\n\t\t\t\t// shift X\n\t\t\t\tp.x += (rand(index.yx) * 2.0 - 1.0) * 0.35;\n\t\t\t\t// distance\n\t\t\t\tvec2 a = abs(p - 0.5);\n\t\t\t\tfloat res = max(a.x * 0.8, a.y * 0.5) - 0.1;\n\t\t\t\t// decimate\n\t\t\t\tbool empty = rand(index) < mix(1.0, 0.1, intensity);\n\t\t\t\treturn empty ? 1.0 : res;\n\t\t\t}\n\n\t\t\tfloat rippleHeight(vec2 p, vec2 pos, float age, float size, float modSize, float thickness) {\n\t\t\t\tfloat strength = 1.0 - exp(-(1.0 - age) * 1.0);\n\t\t\t\tfloat h = max(0.0, 1.0 - abs(length(mod(p - pos + modSize * 0.5, vec2(modSize)) - modSize * 0.5) - size * age) / thickness);\n\t\t\t\th = h * h * (3.0 - 2.0 * h); // smoothstep\n\t\t\t\treturn h * strength;\n\t\t\t}\n\n\t\t\tvec2 puddleDisplace(vec2 p, float intensity) {\n\t\t\t\tvec2 res = vec2(0);\n\n\t\t\t\tconst int numRipples = 30;\n\t\t\t\tconst float rippleLife = 0.8;\n\t\t\t\tconst float rippleSize = 100.0;\n\t\t\t\tconst float rippleMod = rippleSize * 2.0;\n\t\t\t\tfor (int i = 0; i < numRipples; i++) {\n\t\t\t\t\tfloat shift = float(i) / float(numRipples);\n\t\t\t\t\tfloat rippleNumber = uTime / rippleLife + shift;\n\t\t\t\t\tfloat rippleId = floor(rippleNumber);\n\t\t\t\t\trippleId = rand(vec2(rippleId, i));\n\t\t\t\t\tfloat x = rand(vec2(rippleId, rippleId + 1.0)) * rippleMod;\n\t\t\t\t\tfloat y = rand(vec2(rippleId + 2.0, rippleId + 3.0)) * rippleMod;\n\t\t\t\t\tvec2 pos = vec2(x, y);\n\t\t\t\t\tfloat age = fract(rippleNumber);\n\t\t\t\t\tfloat thickness = 4.0;\n\t\t\t\t\tfloat eps = 1.0;\n\t\t\t\t\tvec2 pScale = vec2(1, 1.0 / uPuddleScaleY);\n\t\t\t\t\tfloat hc = rippleHeight(p * pScale, pos, age, rippleSize, rippleMod, thickness);\n\t\t\t\t\tfloat hx = rippleHeight((p + vec2(eps, 0)) * pScale, pos, age, rippleSize, rippleMod, thickness);\n\t\t\t\t\tfloat hy = rippleHeight((p + vec2(0, eps)) * pScale, pos, age, rippleSize, rippleMod, thickness);\n\t\t\t\t\tvec2 normal = (vec2(hx, hy) - hc) / eps;\n\t\t\t\t\tres += normal * 20.0;\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tvec3 lightUp(vec2 p) {\n\t\t\t\tvec3 res = vec3(0);\n\t\t\t\tfor (int i = 0; i < MAX_LIGHTS; i++) {\n\t\t\t\t\tif (i >= numLights) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvec2 lp = lights[i].position;\n\t\t\t\t\tvec3 lc = lights[i].color;\n\t\t\t\t\tfloat lr = lights[i].radius;\n\t\t\t\t\tfloat w = max(0.0, 1.0 - length(lp - p) / lr);\n\t\t\t\t\tres += ease(w) * lc;\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tvec2 worldToBackground(vec2 worldCoord) {\n\t\t\t\t// this should work as long as the background sprite is placed at the origin without scaling\n\t\t\t\treturn worldCoord / uScreenResolution;\n\t\t\t}\n\n\t\t\tvoid main() {\n\t\t\t\tvec2 wpos = screenToWorld(screenCoord);\n\t\t\t\tvec2 origWpos = wpos;\n\t\t\t\tfloat intensity = uIntensity;\n\n\t\t\t\tvec3 add = vec3(0);\n\t\t\t\tfloat rainSum = 0.0;\n\n\t\t\t\tconst int numLayers = 4;\n\t\t\t\tfloat scales[4];\n\t\t\t\tscales[0] = 1.0;\n\t\t\t\tscales[1] = 1.8;\n\t\t\t\tscales[2] = 2.6;\n\t\t\t\tscales[3] = 4.8;\n\n\t\t\t\tfor (int i = 0; i < numLayers; i++) {\n\t\t\t\t\tfloat scale = scales[i];\n\t\t\t\t\tfloat r = rainDist(wpos * scale / uScale + 500.0 * float(i), scale, intensity);\n\t\t\t\t\tif (r < 0.0) {\n\t\t\t\t\t\tfloat v = (1.0 - exp(r * 5.0)) / scale * 2.0;\n\t\t\t\t\t\twpos.x += v * 10.0 * uScale;\n\t\t\t\t\t\twpos.y -= v * 2.0 * uScale;\n\t\t\t\t\t\tadd += vec3(0.1, 0.15, 0.2) * v;\n\t\t\t\t\t\trainSum += (1.0 - rainSum) * 0.75;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//vec3 light = (texture2D(uLightMap, screenCoord).xyz + lightUp(wpos)) * intensity;\n\n\t\t\t\tvec3 color = sampleBitmapWorld(wpos).xyz;\n\n\t\t\t\t/*\n\t\t\t\tbool isPuddle = texture2D(uMask, screenCoord).x > 0.5;\n\t\t\t\tif (isPuddle) {\n\t\t\t\t\tvec2 wpos2 = vec2(wpos.x, uPuddleY - (wpos.y - uPuddleY) / uPuddleScaleY);\n\t\t\t\t\twpos2 += puddleDisplace(wpos / uScale, intensity) * uScale;\n\t\t\t\t\tvec3 reflection = texture2D(uBlurredScreen, worldToScreen(wpos2)).xyz * 0.3 + 0.3;\n\t\t\t\t\tfloat reflectionRatio = 1.0;\n\t\t\t\t\tcolor = reflection;\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t\tvec3 rainColor = vec3(0.4, 0.5, 0.8);\n\t\t\t\tcolor += add;\n\t\t\t\tcolor = mix(color, rainColor, 0.1 * rainSum);\n\n\t\t\t\t// vec3 fog = light * (0.5 + rainSum * 0.5);\n\t\t\t\t// color = color / (1.0 + fog) + fog;\n\n\t\t\t\tgl_FragColor = vec4(color, 1);\n\t\t\t}\n\t\t",cd,1f,5f,4a);
            		}
HXLINE( 174)		if (::hx::IsNull( this->_hx___glVertexSource )) {
HXLINE( 176)			this->_hx___glVertexSource = HX_("\n\t\tattribute float openfl_Alpha;\n\t\tattribute vec4 openfl_ColorMultiplier;\n\t\tattribute vec4 openfl_ColorOffset;\n\t\tattribute vec4 openfl_Position;\n\t\tattribute vec2 openfl_TextureCoord;\n\n\t\tvarying float openfl_Alphav;\n\t\tvarying vec4 openfl_ColorMultiplierv;\n\t\tvarying vec4 openfl_ColorOffsetv;\n\t\tvarying vec2 openfl_TextureCoordv;\n\n\t\tuniform mat4 openfl_Matrix;\n\t\tuniform bool openfl_HasColorTransform;\n\t\tuniform vec2 openfl_TextureSize;\n\n\t\t  // normalized screen coord\n\t\t  //   (0, 0) is the top left of the window\n\t\t  //   (1, 1) is the bottom right of the window\n\t\t  varying vec2 screenCoord;\n\t  \n\t\t\n\t\tattribute float alpha;\n\t\tattribute vec4 colorMultiplier;\n\t\tattribute vec4 colorOffset;\n\t\tuniform bool hasColorTransform;\n\t\t\n\t\tvoid main(void)\n\t\t{\n\t\t\topenfl_Alphav = openfl_Alpha;\n\t\topenfl_TextureCoordv = openfl_TextureCoord;\n\n\t\tif (openfl_HasColorTransform) {\n\n\t\t\topenfl_ColorMultiplierv = openfl_ColorMultiplier;\n\t\t\topenfl_ColorOffsetv = openfl_ColorOffset / 255.0;\n\n\t\t}\n\n\t\tgl_Position = openfl_Matrix * openfl_Position;\n\n\t\t  screenCoord = vec2(\n\t\t\t  openfl_TextureCoord.x > 0.0 ? 1.0 : 0.0,\n\t\t\t  openfl_TextureCoord.y > 0.0 ? 1.0 : 0.0\n\t\t  );\n\t  \n\t\t\t\n\t\t\topenfl_Alphav = openfl_Alpha * alpha;\n\t\t\t\n\t\t\tif (hasColorTransform)\n\t\t\t{\n\t\t\t\topenfl_ColorOffsetv = colorOffset / 255.0;\n\t\t\t\topenfl_ColorMultiplierv = colorMultiplier;\n\t\t\t}\n\t\t}",4f,49,50,fd);
            		}
HXLINE( 447)		super::__construct();
HXLINE( 448)		this->uTime->value = ::Array_obj< Float >::fromData( _hx_array_data_db7d1e79_1,1);
HXLINE( 449)		this->uScale->value = ::Array_obj< Float >::fromData( _hx_array_data_db7d1e79_2,1);
HXLINE( 450)		this->uIntensity->value = ::Array_obj< Float >::fromData( _hx_array_data_db7d1e79_3,1);
HXLINE( 451)		this->uPuddleY->value = ::Array_obj< Float >::fromData( _hx_array_data_db7d1e79_4,1);
HXLINE( 452)		this->uPuddleScaleY->value = ::Array_obj< Float >::fromData( _hx_array_data_db7d1e79_5,1);
HXLINE( 453)		this->numLights->value = ::Array_obj< int >::fromData( _hx_array_data_db7d1e79_6,1);
HXLINE( 454)		this->uScreenResolution->value = ::Array_obj< Float >::__new(2)->init(0,::flixel::FlxG_obj::width)->init(1,::flixel::FlxG_obj::height);
HXLINE(  16)		this->_hx___isGenerated = true;
HXDLIN(  16)		this->_hx___initGL();
            	}

Dynamic RainShader_obj::__CreateEmpty() { return new RainShader_obj; }

void *RainShader_obj::_hx_vtable = 0;

Dynamic RainShader_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< RainShader_obj > _hx_result = new RainShader_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool RainShader_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x1efca5b6) {
		if (inClassId<=(int)0x04f93fcd) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x04f93fcd;
		} else {
			return inClassId==(int)0x1efca5b6;
		}
	} else {
		return inClassId==(int)0x5d863b83 || inClassId==(int)0x78d8d737;
	}
}

Float RainShader_obj::set_time(Float value){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_370_set_time)
HXLINE( 371)		this->uTime->value[0] = value;
HXLINE( 372)		return (this->time = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RainShader_obj,set_time,return )

Float RainShader_obj::set_scale(Float value){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_381_set_scale)
HXLINE( 382)		this->uScale->value[0] = value;
HXLINE( 383)		return (this->scale = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RainShader_obj,set_scale,return )

Float RainShader_obj::set_intensity(Float value){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_390_set_intensity)
HXLINE( 391)		this->uIntensity->value[0] = value;
HXLINE( 392)		return (this->intensity = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RainShader_obj,set_intensity,return )

Float RainShader_obj::set_puddleY(Float value){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_399_set_puddleY)
HXLINE( 400)		this->uPuddleY->value[0] = value;
HXLINE( 401)		return (this->puddleY = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RainShader_obj,set_puddleY,return )

Float RainShader_obj::set_puddleScaleY(Float value){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_408_set_puddleScaleY)
HXLINE( 409)		this->uPuddleScaleY->value[0] = value;
HXLINE( 410)		return (this->puddleScaleY = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RainShader_obj,set_puddleScaleY,return )

 ::openfl::display::BitmapData RainShader_obj::set_blurredScreen( ::openfl::display::BitmapData value){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_416_set_blurredScreen)
HXLINE( 417)		this->uBlurredScreen->input = value;
HXLINE( 418)		return (this->blurredScreen = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RainShader_obj,set_blurredScreen,return )

 ::openfl::display::BitmapData RainShader_obj::set_mask( ::openfl::display::BitmapData value){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_424_set_mask)
HXLINE( 425)		this->uMask->input = value;
HXLINE( 426)		return (this->mask = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RainShader_obj,set_mask,return )

 ::openfl::display::BitmapData RainShader_obj::set_lightMap( ::openfl::display::BitmapData value){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_432_set_lightMap)
HXLINE( 433)		this->uLightMap->input = value;
HXLINE( 434)		return (this->lightMap = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RainShader_obj,set_lightMap,return )

int RainShader_obj::set_numLightsSwag(int value){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_440_set_numLightsSwag)
HXLINE( 441)		this->numLights->value[0] = value;
HXLINE( 442)		return (this->numLightsSwag = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(RainShader_obj,set_numLightsSwag,return )

void RainShader_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_459_update)
HXDLIN( 459)		this->set_time((this->time + elapsed));
            	}


HX_DEFINE_DYNAMIC_FUNC1(RainShader_obj,update,(void))

void RainShader_obj::updateViewInfo(Float screenWidth,Float screenHeight, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_479_updateViewInfo)
HXLINE( 480)		this->uScreenResolution->value = ::Array_obj< Float >::__new(2)->init(0,screenWidth)->init(1,screenHeight);
HXLINE( 481)		this->uCameraBounds->value = ::Array_obj< Float >::__new(4)->init(0,(camera->scroll->x + camera->viewMarginX))->init(1,(camera->scroll->y + camera->viewMarginY))->init(2,(camera->scroll->x + (( (Float)(camera->width) ) - camera->viewMarginX)))->init(3,(camera->scroll->y + (( (Float)(camera->height) ) - camera->viewMarginY)));
            	}


HX_DEFINE_DYNAMIC_FUNC3(RainShader_obj,updateViewInfo,(void))

 ::openfl::display::ShaderParameter_Float RainShader_obj::addFloatUniform(::String name,int length){
            	HX_GC_STACKFRAME(&_hx_pos_0533870a35796cfb_500_addFloatUniform)
HXLINE( 501)		 ::openfl::display::ShaderParameter_Float res =  ::openfl::display::ShaderParameter_Float_obj::__alloc( HX_CTX );
HXLINE( 502)		res->set_name(name);
HXLINE( 503)		res->type = ::Array_obj< ::Dynamic>::__new(5)->init(0,null())->init(1,4)->init(2,5)->init(3,6)->init(4,7)->__get(length);
HXLINE( 504)		res->_hx___arrayLength = 1;
HXLINE( 505)		res->_hx___isFloat = true;
HXLINE( 506)		res->_hx___isUniform = true;
HXLINE( 507)		res->__length = length;
HXLINE( 508)		this->_hx___paramFloat->push(res);
HXLINE( 509)		return res;
            	}


HX_DEFINE_DYNAMIC_FUNC2(RainShader_obj,addFloatUniform,return )

int RainShader_obj::MAX_LIGHTS;


::hx::ObjectPtr< RainShader_obj > RainShader_obj::__new() {
	::hx::ObjectPtr< RainShader_obj > __this = new RainShader_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< RainShader_obj > RainShader_obj::__alloc(::hx::Ctx *_hx_ctx) {
	RainShader_obj *__this = (RainShader_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(RainShader_obj), true, "shaders.RainShader"));
	*(void **)__this = RainShader_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

RainShader_obj::RainShader_obj()
{
}

void RainShader_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(RainShader);
	HX_MARK_MEMBER_NAME(lights,"lights");
	HX_MARK_MEMBER_NAME(time,"time");
	HX_MARK_MEMBER_NAME(scale,"scale");
	HX_MARK_MEMBER_NAME(intensity,"intensity");
	HX_MARK_MEMBER_NAME(puddleY,"puddleY");
	HX_MARK_MEMBER_NAME(puddleScaleY,"puddleScaleY");
	HX_MARK_MEMBER_NAME(blurredScreen,"blurredScreen");
	HX_MARK_MEMBER_NAME(mask,"mask");
	HX_MARK_MEMBER_NAME(lightMap,"lightMap");
	HX_MARK_MEMBER_NAME(numLightsSwag,"numLightsSwag");
	HX_MARK_MEMBER_NAME(uScreenResolution,"uScreenResolution");
	HX_MARK_MEMBER_NAME(uCameraBounds,"uCameraBounds");
	HX_MARK_MEMBER_NAME(uScale,"uScale");
	HX_MARK_MEMBER_NAME(uIntensity,"uIntensity");
	HX_MARK_MEMBER_NAME(uTime,"uTime");
	HX_MARK_MEMBER_NAME(uPuddleY,"uPuddleY");
	HX_MARK_MEMBER_NAME(uPuddleScaleY,"uPuddleScaleY");
	HX_MARK_MEMBER_NAME(uBlurredScreen,"uBlurredScreen");
	HX_MARK_MEMBER_NAME(uMask,"uMask");
	HX_MARK_MEMBER_NAME(uLightMap,"uLightMap");
	HX_MARK_MEMBER_NAME(numLights,"numLights");
	 ::flixel::graphics::tile::FlxGraphicsShader_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void RainShader_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(lights,"lights");
	HX_VISIT_MEMBER_NAME(time,"time");
	HX_VISIT_MEMBER_NAME(scale,"scale");
	HX_VISIT_MEMBER_NAME(intensity,"intensity");
	HX_VISIT_MEMBER_NAME(puddleY,"puddleY");
	HX_VISIT_MEMBER_NAME(puddleScaleY,"puddleScaleY");
	HX_VISIT_MEMBER_NAME(blurredScreen,"blurredScreen");
	HX_VISIT_MEMBER_NAME(mask,"mask");
	HX_VISIT_MEMBER_NAME(lightMap,"lightMap");
	HX_VISIT_MEMBER_NAME(numLightsSwag,"numLightsSwag");
	HX_VISIT_MEMBER_NAME(uScreenResolution,"uScreenResolution");
	HX_VISIT_MEMBER_NAME(uCameraBounds,"uCameraBounds");
	HX_VISIT_MEMBER_NAME(uScale,"uScale");
	HX_VISIT_MEMBER_NAME(uIntensity,"uIntensity");
	HX_VISIT_MEMBER_NAME(uTime,"uTime");
	HX_VISIT_MEMBER_NAME(uPuddleY,"uPuddleY");
	HX_VISIT_MEMBER_NAME(uPuddleScaleY,"uPuddleScaleY");
	HX_VISIT_MEMBER_NAME(uBlurredScreen,"uBlurredScreen");
	HX_VISIT_MEMBER_NAME(uMask,"uMask");
	HX_VISIT_MEMBER_NAME(uLightMap,"uLightMap");
	HX_VISIT_MEMBER_NAME(numLights,"numLights");
	 ::flixel::graphics::tile::FlxGraphicsShader_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val RainShader_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"time") ) { return ::hx::Val( time ); }
		if (HX_FIELD_EQ(inName,"mask") ) { return ::hx::Val( mask ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"scale") ) { return ::hx::Val( scale ); }
		if (HX_FIELD_EQ(inName,"uTime") ) { return ::hx::Val( uTime ); }
		if (HX_FIELD_EQ(inName,"uMask") ) { return ::hx::Val( uMask ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"lights") ) { return ::hx::Val( lights ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"uScale") ) { return ::hx::Val( uScale ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"puddleY") ) { return ::hx::Val( puddleY ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"set_time") ) { return ::hx::Val( set_time_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_mask") ) { return ::hx::Val( set_mask_dyn() ); }
		if (HX_FIELD_EQ(inName,"lightMap") ) { return ::hx::Val( lightMap ); }
		if (HX_FIELD_EQ(inName,"uPuddleY") ) { return ::hx::Val( uPuddleY ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"set_scale") ) { return ::hx::Val( set_scale_dyn() ); }
		if (HX_FIELD_EQ(inName,"intensity") ) { return ::hx::Val( intensity ); }
		if (HX_FIELD_EQ(inName,"uLightMap") ) { return ::hx::Val( uLightMap ); }
		if (HX_FIELD_EQ(inName,"numLights") ) { return ::hx::Val( numLights ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"uIntensity") ) { return ::hx::Val( uIntensity ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"set_puddleY") ) { return ::hx::Val( set_puddleY_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"puddleScaleY") ) { return ::hx::Val( puddleScaleY ); }
		if (HX_FIELD_EQ(inName,"set_lightMap") ) { return ::hx::Val( set_lightMap_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"set_intensity") ) { return ::hx::Val( set_intensity_dyn() ); }
		if (HX_FIELD_EQ(inName,"blurredScreen") ) { return ::hx::Val( blurredScreen ); }
		if (HX_FIELD_EQ(inName,"numLightsSwag") ) { return ::hx::Val( numLightsSwag ); }
		if (HX_FIELD_EQ(inName,"uCameraBounds") ) { return ::hx::Val( uCameraBounds ); }
		if (HX_FIELD_EQ(inName,"uPuddleScaleY") ) { return ::hx::Val( uPuddleScaleY ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"updateViewInfo") ) { return ::hx::Val( updateViewInfo_dyn() ); }
		if (HX_FIELD_EQ(inName,"uBlurredScreen") ) { return ::hx::Val( uBlurredScreen ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"addFloatUniform") ) { return ::hx::Val( addFloatUniform_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"set_puddleScaleY") ) { return ::hx::Val( set_puddleScaleY_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"set_blurredScreen") ) { return ::hx::Val( set_blurredScreen_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_numLightsSwag") ) { return ::hx::Val( set_numLightsSwag_dyn() ); }
		if (HX_FIELD_EQ(inName,"uScreenResolution") ) { return ::hx::Val( uScreenResolution ); }
	}
	return super::__Field(inName,inCallProp);
}

bool RainShader_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"MAX_LIGHTS") ) { outValue = ( MAX_LIGHTS ); return true; }
	}
	return false;
}

::hx::Val RainShader_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"time") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_time(inValue.Cast< Float >()) );time=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mask") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_mask(inValue.Cast<  ::openfl::display::BitmapData >()) );mask=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"scale") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_scale(inValue.Cast< Float >()) );scale=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uTime") ) { uTime=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uMask") ) { uMask=inValue.Cast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"lights") ) { lights=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uScale") ) { uScale=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"puddleY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_puddleY(inValue.Cast< Float >()) );puddleY=inValue.Cast< Float >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"lightMap") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_lightMap(inValue.Cast<  ::openfl::display::BitmapData >()) );lightMap=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uPuddleY") ) { uPuddleY=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"intensity") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_intensity(inValue.Cast< Float >()) );intensity=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uLightMap") ) { uLightMap=inValue.Cast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"numLights") ) { numLights=inValue.Cast<  ::openfl::display::ShaderParameter_Int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"uIntensity") ) { uIntensity=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"puddleScaleY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_puddleScaleY(inValue.Cast< Float >()) );puddleScaleY=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"blurredScreen") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_blurredScreen(inValue.Cast<  ::openfl::display::BitmapData >()) );blurredScreen=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"numLightsSwag") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_numLightsSwag(inValue.Cast< int >()) );numLightsSwag=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uCameraBounds") ) { uCameraBounds=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"uPuddleScaleY") ) { uPuddleScaleY=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"uBlurredScreen") ) { uBlurredScreen=inValue.Cast<  ::openfl::display::ShaderInput_openfl_display_BitmapData >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"uScreenResolution") ) { uScreenResolution=inValue.Cast<  ::openfl::display::ShaderParameter_Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool RainShader_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"MAX_LIGHTS") ) { MAX_LIGHTS=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void RainShader_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("lights",dd,2a,02,e8));
	outFields->push(HX_("time",0d,cc,fc,4c));
	outFields->push(HX_("scale",8a,ce,ce,78));
	outFields->push(HX_("intensity",b3,c6,dd,f4));
	outFields->push(HX_("puddleY",1b,d0,a2,cf));
	outFields->push(HX_("puddleScaleY",ad,2f,c5,26));
	outFields->push(HX_("blurredScreen",16,8c,fe,31));
	outFields->push(HX_("mask",ec,40,56,48));
	outFields->push(HX_("lightMap",66,db,eb,8c));
	outFields->push(HX_("numLightsSwag",ed,69,bc,36));
	outFields->push(HX_("uScreenResolution",4d,4a,8e,f5));
	outFields->push(HX_("uCameraBounds",0f,f3,17,d8));
	outFields->push(HX_("uScale",d5,75,bd,d3));
	outFields->push(HX_("uIntensity",7e,6f,b9,78));
	outFields->push(HX_("uTime",22,d7,b7,95));
	outFields->push(HX_("uPuddleY",26,20,02,c1));
	outFields->push(HX_("uPuddleScaleY",c2,d7,d0,cf));
	outFields->push(HX_("uBlurredScreen",61,f6,25,73));
	outFields->push(HX_("uMask",01,4c,11,91));
	outFields->push(HX_("uLightMap",fb,94,f2,ce));
	outFields->push(HX_("numLights",c3,75,03,99));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo RainShader_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(RainShader_obj,lights),HX_("lights",dd,2a,02,e8)},
	{::hx::fsFloat,(int)offsetof(RainShader_obj,time),HX_("time",0d,cc,fc,4c)},
	{::hx::fsFloat,(int)offsetof(RainShader_obj,scale),HX_("scale",8a,ce,ce,78)},
	{::hx::fsFloat,(int)offsetof(RainShader_obj,intensity),HX_("intensity",b3,c6,dd,f4)},
	{::hx::fsFloat,(int)offsetof(RainShader_obj,puddleY),HX_("puddleY",1b,d0,a2,cf)},
	{::hx::fsFloat,(int)offsetof(RainShader_obj,puddleScaleY),HX_("puddleScaleY",ad,2f,c5,26)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(RainShader_obj,blurredScreen),HX_("blurredScreen",16,8c,fe,31)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(RainShader_obj,mask),HX_("mask",ec,40,56,48)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(RainShader_obj,lightMap),HX_("lightMap",66,db,eb,8c)},
	{::hx::fsInt,(int)offsetof(RainShader_obj,numLightsSwag),HX_("numLightsSwag",ed,69,bc,36)},
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(RainShader_obj,uScreenResolution),HX_("uScreenResolution",4d,4a,8e,f5)},
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(RainShader_obj,uCameraBounds),HX_("uCameraBounds",0f,f3,17,d8)},
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(RainShader_obj,uScale),HX_("uScale",d5,75,bd,d3)},
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(RainShader_obj,uIntensity),HX_("uIntensity",7e,6f,b9,78)},
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(RainShader_obj,uTime),HX_("uTime",22,d7,b7,95)},
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(RainShader_obj,uPuddleY),HX_("uPuddleY",26,20,02,c1)},
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Float */ ,(int)offsetof(RainShader_obj,uPuddleScaleY),HX_("uPuddleScaleY",c2,d7,d0,cf)},
	{::hx::fsObject /*  ::openfl::display::ShaderInput_openfl_display_BitmapData */ ,(int)offsetof(RainShader_obj,uBlurredScreen),HX_("uBlurredScreen",61,f6,25,73)},
	{::hx::fsObject /*  ::openfl::display::ShaderInput_openfl_display_BitmapData */ ,(int)offsetof(RainShader_obj,uMask),HX_("uMask",01,4c,11,91)},
	{::hx::fsObject /*  ::openfl::display::ShaderInput_openfl_display_BitmapData */ ,(int)offsetof(RainShader_obj,uLightMap),HX_("uLightMap",fb,94,f2,ce)},
	{::hx::fsObject /*  ::openfl::display::ShaderParameter_Int */ ,(int)offsetof(RainShader_obj,numLights),HX_("numLights",c3,75,03,99)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo RainShader_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &RainShader_obj::MAX_LIGHTS,HX_("MAX_LIGHTS",78,da,04,18)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String RainShader_obj_sMemberFields[] = {
	HX_("lights",dd,2a,02,e8),
	HX_("time",0d,cc,fc,4c),
	HX_("set_time",0a,e1,14,7b),
	HX_("scale",8a,ce,ce,78),
	HX_("set_scale",ed,16,c9,9f),
	HX_("intensity",b3,c6,dd,f4),
	HX_("set_intensity",96,7c,47,fb),
	HX_("puddleY",1b,d0,a2,cf),
	HX_("set_puddleY",3e,37,0a,60),
	HX_("puddleScaleY",ad,2f,c5,26),
	HX_("set_puddleScaleY",aa,09,a6,81),
	HX_("blurredScreen",16,8c,fe,31),
	HX_("set_blurredScreen",79,6f,dc,5b),
	HX_("mask",ec,40,56,48),
	HX_("set_mask",e9,55,6e,76),
	HX_("lightMap",66,db,eb,8c),
	HX_("set_lightMap",e3,b2,fe,56),
	HX_("numLightsSwag",ed,69,bc,36),
	HX_("set_numLightsSwag",50,4d,9a,60),
	HX_("update",09,86,05,87),
	HX_("updateViewInfo",9c,20,07,b8),
	HX_("addFloatUniform",b9,3a,be,d1),
	HX_("uScreenResolution",4d,4a,8e,f5),
	HX_("uCameraBounds",0f,f3,17,d8),
	HX_("uScale",d5,75,bd,d3),
	HX_("uIntensity",7e,6f,b9,78),
	HX_("uTime",22,d7,b7,95),
	HX_("uPuddleY",26,20,02,c1),
	HX_("uPuddleScaleY",c2,d7,d0,cf),
	HX_("uBlurredScreen",61,f6,25,73),
	HX_("uMask",01,4c,11,91),
	HX_("uLightMap",fb,94,f2,ce),
	HX_("numLights",c3,75,03,99),
	::String(null()) };

static void RainShader_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(RainShader_obj::MAX_LIGHTS,"MAX_LIGHTS");
};

#ifdef HXCPP_VISIT_ALLOCS
static void RainShader_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(RainShader_obj::MAX_LIGHTS,"MAX_LIGHTS");
};

#endif

::hx::Class RainShader_obj::__mClass;

static ::String RainShader_obj_sStaticFields[] = {
	HX_("MAX_LIGHTS",78,da,04,18),
	::String(null())
};

void RainShader_obj::__register()
{
	RainShader_obj _hx_dummy;
	RainShader_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("shaders.RainShader",79,1e,7d,db);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &RainShader_obj::__GetStatic;
	__mClass->mSetStaticField = &RainShader_obj::__SetStatic;
	__mClass->mMarkFunc = RainShader_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(RainShader_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(RainShader_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< RainShader_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = RainShader_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = RainShader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = RainShader_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void RainShader_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_0533870a35796cfb_358_boot)
HXDLIN( 358)		MAX_LIGHTS = 8;
            	}
}

} // end namespace shaders
