// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_backend_ui_PsychUIDropDownItem
#include <backend/ui/PsychUIDropDownItem.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_4a87544bdb02f918_220_new,"backend.ui.PsychUIDropDownItem","new",0x3996e125,"backend.ui.PsychUIDropDownItem.new","backend/ui/PsychUIDropDownMenu.hx",220,0x0f4dd77f)
HX_LOCAL_STACK_FRAME(_hx_pos_4a87544bdb02f918_252_update,"backend.ui.PsychUIDropDownItem","update",0x4f437e64,"backend.ui.PsychUIDropDownItem.update","backend/ui/PsychUIDropDownMenu.hx",252,0x0f4dd77f)
HX_LOCAL_STACK_FRAME(_hx_pos_4a87544bdb02f918_274_set_label,"backend.ui.PsychUIDropDownItem","set_label",0xfb9cc8dc,"backend.ui.PsychUIDropDownItem.set_label","backend/ui/PsychUIDropDownMenu.hx",274,0x0f4dd77f)
namespace backend{
namespace ui{

void PsychUIDropDownItem_obj::__construct(::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y,::hx::Null< Float >  __o_width){
            		Float x = __o_x.Default(0);
            		Float y = __o_y.Default(0);
            		Float width = __o_width.Default(100);
            	HX_GC_STACKFRAME(&_hx_pos_4a87544bdb02f918_220_new)
HXLINE( 250)		this->forceNextUpdate = false;
HXLINE( 227)		this->normalStyle =  ::Dynamic(::hx::Anon_obj::Create(3)
            			->setFixed(0,HX_("bgAlpha",59,b7,bd,ce),( (Float)(1) ))
            			->setFixed(1,HX_("textColor",76,01,4a,e3),-16777216)
            			->setFixed(2,HX_("bgColor",5e,81,83,f7),-1));
HXLINE( 222)		this->hoverStyle =  ::Dynamic(::hx::Anon_obj::Create(3)
            			->setFixed(0,HX_("bgAlpha",59,b7,bd,ce),( (Float)(1) ))
            			->setFixed(1,HX_("textColor",76,01,4a,e3),-1)
            			->setFixed(2,HX_("bgColor",5e,81,83,f7),-16750849));
HXLINE( 237)		super::__construct(x,y,null());
HXLINE( 239)		this->bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(1,1,-1,null(),null());
HXLINE( 240)		this->bg->setGraphicSize(width,20);
HXLINE( 241)		this->bg->updateHitbox();
HXLINE( 242)		this->add(this->bg);
HXLINE( 244)		this->text =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,0,width,null(),8,null());
HXLINE( 245)		this->text->set_color(-16777216);
HXLINE( 246)		this->add(this->text);
            	}

Dynamic PsychUIDropDownItem_obj::__CreateEmpty() { return new PsychUIDropDownItem_obj; }

void *PsychUIDropDownItem_obj::_hx_vtable = 0;

Dynamic PsychUIDropDownItem_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PsychUIDropDownItem_obj > _hx_result = new PsychUIDropDownItem_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool PsychUIDropDownItem_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2c01639b) {
		if (inClassId<=(int)0x288ce903) {
			if (inClassId<=(int)0x14272f53) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x14272f53;
			} else {
				return inClassId==(int)0x288ce903;
			}
		} else {
			return inClassId==(int)0x2c01639b;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void PsychUIDropDownItem_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_4a87544bdb02f918_252_update)
HXLINE( 253)		this->super::update(elapsed);
HXLINE( 254)		bool _hx_tmp;
HXDLIN( 254)		bool _hx_tmp1;
HXDLIN( 254)		 ::flixel::input::mouse::FlxMouse _this = ::flixel::FlxG_obj::mouse;
HXDLIN( 254)		bool _hx_tmp2;
HXDLIN( 254)		if ((_this->_prevX == _this->x)) {
HXLINE( 254)			_hx_tmp2 = (_this->_prevY != _this->y);
            		}
            		else {
HXLINE( 254)			_hx_tmp2 = true;
            		}
HXDLIN( 254)		if (!(_hx_tmp2)) {
HXLINE( 254)			_hx_tmp1 = (::flixel::FlxG_obj::mouse->_leftButton->current == 2);
            		}
            		else {
HXLINE( 254)			_hx_tmp1 = true;
            		}
HXDLIN( 254)		if (!(_hx_tmp1)) {
HXLINE( 254)			_hx_tmp = this->forceNextUpdate;
            		}
            		else {
HXLINE( 254)			_hx_tmp = true;
            		}
HXDLIN( 254)		if (_hx_tmp) {
HXLINE( 256)			 ::flixel::input::mouse::FlxMouse overlapped = ::flixel::FlxG_obj::mouse;
HXDLIN( 256)			 ::flixel::FlxSprite overlapped1 = this->bg;
HXDLIN( 256)			bool overlapped2 = overlapped->overlaps(overlapped1,this->get_camera());
HXLINE( 258)			 ::Dynamic style;
HXDLIN( 258)			if (overlapped2) {
HXLINE( 258)				style = this->hoverStyle;
            			}
            			else {
HXLINE( 258)				style = this->normalStyle;
            			}
HXLINE( 259)			this->bg->set_color(( (int)(style->__Field(HX_("bgColor",5e,81,83,f7),::hx::paccDynamic)) ));
HXLINE( 260)			this->text->set_color(( (int)(style->__Field(HX_("textColor",76,01,4a,e3),::hx::paccDynamic)) ));
HXLINE( 261)			this->bg->set_alpha(( (Float)(style->__Field(HX_("bgAlpha",59,b7,bd,ce),::hx::paccDynamic)) ));
HXLINE( 262)			this->forceNextUpdate = false;
HXLINE( 264)			bool _hx_tmp3;
HXDLIN( 264)			if (overlapped2) {
HXLINE( 264)				_hx_tmp3 = (::flixel::FlxG_obj::mouse->_leftButton->current == 2);
            			}
            			else {
HXLINE( 264)				_hx_tmp3 = false;
            			}
HXDLIN( 264)			if (_hx_tmp3) {
HXLINE( 265)				this->onClick();
            			}
            		}
HXLINE( 268)		this->text->set_x(this->bg->x);
HXLINE( 269)		 ::flixel::text::FlxText _hx_tmp4 = this->text;
HXDLIN( 269)		Float _hx_tmp5 = this->bg->y;
HXDLIN( 269)		Float _hx_tmp6 = (_hx_tmp5 + (this->bg->get_height() / ( (Float)(2) )));
HXDLIN( 269)		_hx_tmp4->set_y((_hx_tmp6 - (this->text->get_height() / ( (Float)(2) ))));
            	}


::String PsychUIDropDownItem_obj::set_label(::String v){
            	HX_STACKFRAME(&_hx_pos_4a87544bdb02f918_274_set_label)
HXLINE( 275)		this->label = v;
HXLINE( 276)		this->text->set_text(v);
HXLINE( 277)		{
HXLINE( 277)			 ::flixel::math::FlxBasePoint this1 = this->bg->scale;
HXDLIN( 277)			this1->set_y((this->text->get_height() + 6));
            		}
HXLINE( 278)		this->bg->updateHitbox();
HXLINE( 279)		return v;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIDropDownItem_obj,set_label,return )


::hx::ObjectPtr< PsychUIDropDownItem_obj > PsychUIDropDownItem_obj::__new(::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y,::hx::Null< Float >  __o_width) {
	::hx::ObjectPtr< PsychUIDropDownItem_obj > __this = new PsychUIDropDownItem_obj();
	__this->__construct(__o_x,__o_y,__o_width);
	return __this;
}

::hx::ObjectPtr< PsychUIDropDownItem_obj > PsychUIDropDownItem_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y,::hx::Null< Float >  __o_width) {
	PsychUIDropDownItem_obj *__this = (PsychUIDropDownItem_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PsychUIDropDownItem_obj), true, "backend.ui.PsychUIDropDownItem"));
	*(void **)__this = PsychUIDropDownItem_obj::_hx_vtable;
	__this->__construct(__o_x,__o_y,__o_width);
	return __this;
}

PsychUIDropDownItem_obj::PsychUIDropDownItem_obj()
{
}

void PsychUIDropDownItem_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PsychUIDropDownItem);
	HX_MARK_MEMBER_NAME(hoverStyle,"hoverStyle");
	HX_MARK_MEMBER_NAME(normalStyle,"normalStyle");
	HX_MARK_MEMBER_NAME(bg,"bg");
	HX_MARK_MEMBER_NAME(text,"text");
	HX_MARK_MEMBER_NAME(onClick,"onClick");
	HX_MARK_MEMBER_NAME(forceNextUpdate,"forceNextUpdate");
	HX_MARK_MEMBER_NAME(label,"label");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void PsychUIDropDownItem_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(hoverStyle,"hoverStyle");
	HX_VISIT_MEMBER_NAME(normalStyle,"normalStyle");
	HX_VISIT_MEMBER_NAME(bg,"bg");
	HX_VISIT_MEMBER_NAME(text,"text");
	HX_VISIT_MEMBER_NAME(onClick,"onClick");
	HX_VISIT_MEMBER_NAME(forceNextUpdate,"forceNextUpdate");
	HX_VISIT_MEMBER_NAME(label,"label");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val PsychUIDropDownItem_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"bg") ) { return ::hx::Val( bg ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"text") ) { return ::hx::Val( text ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"label") ) { return ::hx::Val( label ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"onClick") ) { return ::hx::Val( onClick ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"set_label") ) { return ::hx::Val( set_label_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"hoverStyle") ) { return ::hx::Val( hoverStyle ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"normalStyle") ) { return ::hx::Val( normalStyle ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"forceNextUpdate") ) { return ::hx::Val( forceNextUpdate ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val PsychUIDropDownItem_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"bg") ) { bg=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"text") ) { text=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"label") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_label(inValue.Cast< ::String >()) );label=inValue.Cast< ::String >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"onClick") ) { onClick=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"hoverStyle") ) { hoverStyle=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"normalStyle") ) { normalStyle=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"forceNextUpdate") ) { forceNextUpdate=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void PsychUIDropDownItem_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("hoverStyle",d5,e5,1f,06));
	outFields->push(HX_("normalStyle",8a,75,4f,11));
	outFields->push(HX_("bg",c5,55,00,00));
	outFields->push(HX_("text",ad,cc,f9,4c));
	outFields->push(HX_("forceNextUpdate",27,a1,d0,4c));
	outFields->push(HX_("label",f4,0d,af,6f));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo PsychUIDropDownItem_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(PsychUIDropDownItem_obj,hoverStyle),HX_("hoverStyle",d5,e5,1f,06)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(PsychUIDropDownItem_obj,normalStyle),HX_("normalStyle",8a,75,4f,11)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(PsychUIDropDownItem_obj,bg),HX_("bg",c5,55,00,00)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(PsychUIDropDownItem_obj,text),HX_("text",ad,cc,f9,4c)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(PsychUIDropDownItem_obj,onClick),HX_("onClick",a9,1a,9c,de)},
	{::hx::fsBool,(int)offsetof(PsychUIDropDownItem_obj,forceNextUpdate),HX_("forceNextUpdate",27,a1,d0,4c)},
	{::hx::fsString,(int)offsetof(PsychUIDropDownItem_obj,label),HX_("label",f4,0d,af,6f)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *PsychUIDropDownItem_obj_sStaticStorageInfo = 0;
#endif

static ::String PsychUIDropDownItem_obj_sMemberFields[] = {
	HX_("hoverStyle",d5,e5,1f,06),
	HX_("normalStyle",8a,75,4f,11),
	HX_("bg",c5,55,00,00),
	HX_("text",ad,cc,f9,4c),
	HX_("onClick",a9,1a,9c,de),
	HX_("forceNextUpdate",27,a1,d0,4c),
	HX_("update",09,86,05,87),
	HX_("label",f4,0d,af,6f),
	HX_("set_label",57,56,a9,96),
	::String(null()) };

::hx::Class PsychUIDropDownItem_obj::__mClass;

void PsychUIDropDownItem_obj::__register()
{
	PsychUIDropDownItem_obj _hx_dummy;
	PsychUIDropDownItem_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("backend.ui.PsychUIDropDownItem",b3,6a,a4,6e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PsychUIDropDownItem_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PsychUIDropDownItem_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PsychUIDropDownItem_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PsychUIDropDownItem_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace backend
} // end namespace ui
