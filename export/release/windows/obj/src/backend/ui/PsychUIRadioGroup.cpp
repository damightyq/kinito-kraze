// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUICheckBox
#include <backend/ui/PsychUICheckBox.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIEventHandler
#include <backend/ui/PsychUIEventHandler.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIRadioGroup
#include <backend/ui/PsychUIRadioGroup.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIRadioItem
#include <backend/ui/PsychUIRadioItem.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_dcff0badd08dd348_6_new,"backend.ui.PsychUIRadioGroup","new",0xe32135c5,"backend.ui.PsychUIRadioGroup.new","backend/ui/PsychUIRadioGroup.hx",6,0x4e47afeb)
static const int _hx_array_data_c9ffef53_1[] = {
	(int)0,
};
static const int _hx_array_data_c9ffef53_2[] = {
	(int)1,
};
static const int _hx_array_data_c9ffef53_3[] = {
	(int)0,
};
static const int _hx_array_data_c9ffef53_4[] = {
	(int)1,
};
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_53_update,"backend.ui.PsychUIRadioGroup","update",0xa7a7cdc4,"backend.ui.PsychUIRadioGroup.update","backend/ui/PsychUIRadioGroup.hx",53,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_110_draw,"backend.ui.PsychUIRadioGroup","draw",0xd35b7eff,"backend.ui.PsychUIRadioGroup.draw","backend/ui/PsychUIRadioGroup.hx",110,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_121_destroy,"backend.ui.PsychUIRadioGroup","destroy",0x91e2a8df,"backend.ui.PsychUIRadioGroup.destroy","backend/ui/PsychUIRadioGroup.hx",121,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_130_set_curScroll,"backend.ui.PsychUIRadioGroup","set_curScroll",0x9b799d35,"backend.ui.PsychUIRadioGroup.set_curScroll","backend/ui/PsychUIRadioGroup.hx",130,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_169_set_stackHorizontal,"backend.ui.PsychUIRadioGroup","set_stackHorizontal",0x987653d4,"backend.ui.PsychUIRadioGroup.set_stackHorizontal","backend/ui/PsychUIRadioGroup.hx",169,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_176_set_checked,"backend.ui.PsychUIRadioGroup","set_checked",0x1304ecaf,"backend.ui.PsychUIRadioGroup.set_checked","backend/ui/PsychUIRadioGroup.hx",176,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_188_set_labels,"backend.ui.PsychUIRadioGroup","set_labels",0x76427777,"backend.ui.PsychUIRadioGroup.set_labels","backend/ui/PsychUIRadioGroup.hx",188,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_197_set_checkedRadio,"backend.ui.PsychUIRadioGroup","set_checkedRadio",0x275d39cc,"backend.ui.PsychUIRadioGroup.set_checkedRadio","backend/ui/PsychUIRadioGroup.hx",197,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_213_set_space,"backend.ui.PsychUIRadioGroup","set_space",0x82bfd44e,"backend.ui.PsychUIRadioGroup.set_space","backend/ui/PsychUIRadioGroup.hx",213,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_228_set_textWidth,"backend.ui.PsychUIRadioGroup","set_textWidth",0x46d7f1a1,"backend.ui.PsychUIRadioGroup.set_textWidth","backend/ui/PsychUIRadioGroup.hx",228,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_237_set_maxItems,"backend.ui.PsychUIRadioGroup","set_maxItems",0x507c1c34,"backend.ui.PsychUIRadioGroup.set_maxItems","backend/ui/PsychUIRadioGroup.hx",237,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_246_updateRadioItems,"backend.ui.PsychUIRadioGroup","updateRadioItems",0xc6c0cbe9,"backend.ui.PsychUIRadioGroup.updateRadioItems","backend/ui/PsychUIRadioGroup.hx",246,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_293_set_cameras,"backend.ui.PsychUIRadioGroup","set_cameras",0xe311c3b6,"backend.ui.PsychUIRadioGroup.set_cameras","backend/ui/PsychUIRadioGroup.hx",293,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_300_set_camera,"backend.ui.PsychUIRadioGroup","set_camera",0xe451961d,"backend.ui.PsychUIRadioGroup.set_camera","backend/ui/PsychUIRadioGroup.hx",300,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_310__addNewRadio,"backend.ui.PsychUIRadioGroup","_addNewRadio",0xb9077fb8,"backend.ui.PsychUIRadioGroup._addNewRadio","backend/ui/PsychUIRadioGroup.hx",310,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_308__addNewRadio,"backend.ui.PsychUIRadioGroup","_addNewRadio",0xb9077fb8,"backend.ui.PsychUIRadioGroup._addNewRadio","backend/ui/PsychUIRadioGroup.hx",308,0x4e47afeb)
HX_LOCAL_STACK_FRAME(_hx_pos_dcff0badd08dd348_8_boot,"backend.ui.PsychUIRadioGroup","boot",0xd206d72d,"backend.ui.PsychUIRadioGroup.boot","backend/ui/PsychUIRadioGroup.hx",8,0x4e47afeb)
namespace backend{
namespace ui{

void PsychUIRadioGroup_obj::__construct(Float x,Float y,::Array< ::String > labels,::hx::Null< Float >  __o_space,::hx::Null< int >  __o_maxItems, ::Dynamic __o_isHorizontal, ::Dynamic __o_textWidth){
            		Float space = __o_space.Default(25);
            		int maxItems = __o_maxItems.Default(0);
            		 ::Dynamic isHorizontal = __o_isHorizontal;
            		if (::hx::IsNull(__o_isHorizontal)) isHorizontal = false;
            		 ::Dynamic textWidth = __o_textWidth;
            		if (::hx::IsNull(__o_textWidth)) textWidth = 100;
            	HX_GC_STACKFRAME(&_hx_pos_dcff0badd08dd348_6_new)
HXLINE( 306)		this->broadcastRadioGroupEvent = true;
HXLINE( 128)		this->curScroll = 0;
HXLINE(  19)		this->checked = -1;
HXLINE(  17)		this->stackHorizontal = false;
HXLINE(  15)		this->maxItems = 0;
HXLINE(  14)		this->textWidth = 100;
HXLINE(  13)		this->space = ((Float)25);
HXLINE(  11)		this->radios = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  10)		this->labels = ::Array_obj< ::String >::__new(0);
HXLINE(  30)		super::__construct(x,y,null());
HXLINE(  32)		this->_hitbox =  ::flixel::FlxObject_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE(  34)		 ::flixel::FlxSprite _hx_tmp =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXDLIN(  34)		this->arrowUp = _hx_tmp->loadGraphic(::backend::Paths_obj::image(HX_("psych-ui/arrow_up",5a,57,68,da),HX_("embed",d9,8d,cf,6f),null()),true,24,18,null(),null());
HXLINE(  35)		this->arrowUp->animation->add(HX_("normal",27,72,69,30),::Array_obj< int >::fromData( _hx_array_data_c9ffef53_1,1),null(),null(),null(),null());
HXLINE(  36)		this->arrowUp->animation->add(HX_("press",83,53,88,c8),::Array_obj< int >::fromData( _hx_array_data_c9ffef53_2,1),null(),null(),null(),null());
HXLINE(  37)		this->arrowUp->animation->play(HX_("normal",27,72,69,30),null(),null(),null());
HXLINE(  38)		this->arrowUp->set_visible(false);
HXLINE(  39)		 ::flixel::FlxSprite _hx_tmp1 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXDLIN(  39)		this->arrowDown = _hx_tmp1->loadGraphic(::backend::Paths_obj::image(HX_("psych-ui/arrow_down",21,67,73,7b),HX_("embed",d9,8d,cf,6f),null()),true,24,18,null(),null());
HXLINE(  40)		this->arrowDown->animation->add(HX_("normal",27,72,69,30),::Array_obj< int >::fromData( _hx_array_data_c9ffef53_3,1),null(),null(),null(),null());
HXLINE(  41)		this->arrowDown->animation->add(HX_("press",83,53,88,c8),::Array_obj< int >::fromData( _hx_array_data_c9ffef53_4,1),null(),null(),null(),null());
HXLINE(  42)		this->arrowDown->animation->play(HX_("normal",27,72,69,30),null(),null(),null());
HXLINE(  43)		this->arrowDown->set_visible(false);
HXLINE(  45)		this->set_space(space);
HXLINE(  46)		this->set_textWidth(( (int)(textWidth) ));
HXLINE(  47)		if (::hx::IsNotNull( labels )) {
HXLINE(  47)			this->labels = labels;
            		}
HXLINE(  48)		this->stackHorizontal = ( (bool)(isHorizontal) );
HXLINE(  49)		this->set_maxItems(maxItems);
            	}

Dynamic PsychUIRadioGroup_obj::__CreateEmpty() { return new PsychUIRadioGroup_obj; }

void *PsychUIRadioGroup_obj::_hx_vtable = 0;

Dynamic PsychUIRadioGroup_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PsychUIRadioGroup_obj > _hx_result = new PsychUIRadioGroup_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4],inArgs[5],inArgs[6]);
	return _hx_result;
}

bool PsychUIRadioGroup_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x74a22b2b) {
		if (inClassId<=(int)0x2c01639b) {
			if (inClassId<=(int)0x288ce903) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x288ce903;
			} else {
				return inClassId==(int)0x2c01639b;
			}
		} else {
			return inClassId==(int)0x74a22b2b;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void PsychUIRadioGroup_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_53_update)
HXLINE(  54)		this->super::update(elapsed);
HXLINE(  56)		this->_hitbox->set_x(this->x);
HXLINE(  57)		this->_hitbox->set_y(this->y);
HXLINE(  58)		 ::flixel::FlxObject _hx_tmp = this->_hitbox;
HXDLIN(  58)		_hx_tmp->set_width(this->get_width());
HXLINE(  59)		 ::flixel::FlxObject _hx_tmp1 = this->_hitbox;
HXDLIN(  59)		_hx_tmp1->set_height(this->get_height());
HXLINE(  60)		bool _hx_tmp2;
HXDLIN(  60)		bool _hx_tmp3;
HXDLIN(  60)		bool _hx_tmp4;
HXDLIN(  60)		if ((this->maxItems > 0)) {
HXLINE(  60)			_hx_tmp4 = (this->maxItems < this->labels->length);
            		}
            		else {
HXLINE(  60)			_hx_tmp4 = false;
            		}
HXDLIN(  60)		if (_hx_tmp4) {
HXLINE(  60)			_hx_tmp3 = (::flixel::FlxG_obj::mouse->wheel != 0);
            		}
            		else {
HXLINE(  60)			_hx_tmp3 = false;
            		}
HXDLIN(  60)		if (_hx_tmp3) {
HXLINE(  60)			 ::flixel::input::mouse::FlxMouse _hx_tmp5 = ::flixel::FlxG_obj::mouse;
HXDLIN(  60)			 ::flixel::FlxObject _hx_tmp6 = this->_hitbox;
HXDLIN(  60)			_hx_tmp2 = _hx_tmp5->overlaps(_hx_tmp6,this->get_camera());
            		}
            		else {
HXLINE(  60)			_hx_tmp2 = false;
            		}
HXDLIN(  60)		if (_hx_tmp2) {
HXLINE(  62)			this->set_curScroll((this->curScroll - ::flixel::FlxG_obj::mouse->wheel));
            		}
HXLINE(  66)		Float baseY = (this->y + (( (Float)(this->radios->length) ) * this->space));
HXLINE(  67)		if (this->stackHorizontal) {
HXLINE(  67)			baseY = (this->y + 25);
            		}
HXLINE(  69)		bool hasArrowUp = false;
HXLINE(  70)		bool hasArrowDown = false;
HXLINE(  71)		bool _hx_tmp7;
HXDLIN(  71)		bool _hx_tmp8;
HXDLIN(  71)		if (::hx::IsNotNull( this->arrowDown )) {
HXLINE(  71)			_hx_tmp8 = this->arrowDown->exists;
            		}
            		else {
HXLINE(  71)			_hx_tmp8 = false;
            		}
HXDLIN(  71)		if (_hx_tmp8) {
HXLINE(  71)			_hx_tmp7 = this->arrowDown->active;
            		}
            		else {
HXLINE(  71)			_hx_tmp7 = false;
            		}
HXDLIN(  71)		if (_hx_tmp7) {
HXLINE(  73)			this->arrowDown->set_x(this->x);
HXLINE(  74)			this->arrowDown->set_y(baseY);
HXLINE(  75)			hasArrowDown = true;
            		}
HXLINE(  78)		bool _hx_tmp9;
HXDLIN(  78)		bool _hx_tmp10;
HXDLIN(  78)		if (::hx::IsNotNull( this->arrowUp )) {
HXLINE(  78)			_hx_tmp10 = this->arrowUp->exists;
            		}
            		else {
HXLINE(  78)			_hx_tmp10 = false;
            		}
HXDLIN(  78)		if (_hx_tmp10) {
HXLINE(  78)			_hx_tmp9 = this->arrowUp->active;
            		}
            		else {
HXLINE(  78)			_hx_tmp9 = false;
            		}
HXDLIN(  78)		if (_hx_tmp9) {
HXLINE(  80)			this->arrowUp->set_x(this->x);
HXLINE(  81)			this->arrowUp->set_y(baseY);
HXLINE(  82)			hasArrowUp = true;
HXLINE(  83)			if (hasArrowDown) {
HXLINE(  84)				 ::flixel::FlxSprite fh = this->arrowDown;
HXDLIN(  84)				Float fh1 = fh->x;
HXDLIN(  84)				fh->set_x((fh1 + (this->arrowUp->get_width() + 8)));
            			}
            		}
HXLINE(  87)		if ((::flixel::FlxG_obj::mouse->_leftButton->current == 2)) {
HXLINE(  89)			bool _hx_tmp11;
HXDLIN(  89)			bool _hx_tmp12;
HXDLIN(  89)			bool _hx_tmp13;
HXDLIN(  89)			if (hasArrowUp) {
HXLINE(  89)				_hx_tmp13 = (this->maxItems > 0);
            			}
            			else {
HXLINE(  89)				_hx_tmp13 = false;
            			}
HXDLIN(  89)			if (_hx_tmp13) {
HXLINE(  89)				_hx_tmp12 = (this->curScroll > 0);
            			}
            			else {
HXLINE(  89)				_hx_tmp12 = false;
            			}
HXDLIN(  89)			if (_hx_tmp12) {
HXLINE(  89)				 ::flixel::input::mouse::FlxMouse _hx_tmp14 = ::flixel::FlxG_obj::mouse;
HXDLIN(  89)				 ::flixel::FlxSprite _hx_tmp15 = this->arrowUp;
HXDLIN(  89)				_hx_tmp11 = _hx_tmp14->overlaps(_hx_tmp15,this->get_camera());
            			}
            			else {
HXLINE(  89)				_hx_tmp11 = false;
            			}
HXDLIN(  89)			if (_hx_tmp11) {
HXLINE(  91)				this->set_curScroll((this->curScroll - 1));
HXLINE(  92)				this->arrowUp->animation->play(HX_("press",83,53,88,c8),null(),null(),null());
            			}
            			else {
HXLINE(  94)				bool _hx_tmp16;
HXDLIN(  94)				bool _hx_tmp17;
HXDLIN(  94)				bool _hx_tmp18;
HXDLIN(  94)				if (hasArrowDown) {
HXLINE(  94)					_hx_tmp18 = (this->maxItems > 0);
            				}
            				else {
HXLINE(  94)					_hx_tmp18 = false;
            				}
HXDLIN(  94)				if (_hx_tmp18) {
HXLINE(  94)					_hx_tmp17 = (this->curScroll < (this->labels->length - this->maxItems));
            				}
            				else {
HXLINE(  94)					_hx_tmp17 = false;
            				}
HXDLIN(  94)				if (_hx_tmp17) {
HXLINE(  94)					 ::flixel::input::mouse::FlxMouse _hx_tmp19 = ::flixel::FlxG_obj::mouse;
HXDLIN(  94)					 ::flixel::FlxSprite _hx_tmp20 = this->arrowDown;
HXDLIN(  94)					_hx_tmp16 = _hx_tmp19->overlaps(_hx_tmp20,this->get_camera());
            				}
            				else {
HXLINE(  94)					_hx_tmp16 = false;
            				}
HXDLIN(  94)				if (_hx_tmp16) {
HXLINE(  96)					this->set_curScroll((this->curScroll + 1));
HXLINE(  97)					this->arrowDown->animation->play(HX_("press",83,53,88,c8),null(),null(),null());
            				}
            			}
            		}
            		else {
HXLINE( 100)			 ::flixel::input::mouse::FlxMouseButton _this = ::flixel::FlxG_obj::mouse->_leftButton;
HXDLIN( 100)			bool _hx_tmp21;
HXDLIN( 100)			if ((_this->current != 0)) {
HXLINE( 100)				_hx_tmp21 = (_this->current == -1);
            			}
            			else {
HXLINE( 100)				_hx_tmp21 = true;
            			}
HXDLIN( 100)			if (_hx_tmp21) {
HXLINE( 102)				bool _hx_tmp22;
HXDLIN( 102)				bool _hx_tmp23;
HXDLIN( 102)				if (hasArrowUp) {
HXLINE( 102)					_hx_tmp23 = ::hx::IsNotNull( this->arrowUp->animation->_curAnim );
            				}
            				else {
HXLINE( 102)					_hx_tmp23 = false;
            				}
HXDLIN( 102)				if (_hx_tmp23) {
HXLINE( 102)					_hx_tmp22 = (this->arrowUp->animation->_curAnim->name != HX_("normal",27,72,69,30));
            				}
            				else {
HXLINE( 102)					_hx_tmp22 = false;
            				}
HXDLIN( 102)				if (_hx_tmp22) {
HXLINE( 103)					this->arrowUp->animation->play(HX_("normal",27,72,69,30),null(),null(),null());
            				}
HXLINE( 104)				bool _hx_tmp24;
HXDLIN( 104)				bool _hx_tmp25;
HXDLIN( 104)				if (hasArrowDown) {
HXLINE( 104)					_hx_tmp25 = ::hx::IsNotNull( this->arrowDown->animation->_curAnim );
            				}
            				else {
HXLINE( 104)					_hx_tmp25 = false;
            				}
HXDLIN( 104)				if (_hx_tmp25) {
HXLINE( 104)					_hx_tmp24 = (this->arrowDown->animation->_curAnim->name != HX_("normal",27,72,69,30));
            				}
            				else {
HXLINE( 104)					_hx_tmp24 = false;
            				}
HXDLIN( 104)				if (_hx_tmp24) {
HXLINE( 105)					this->arrowDown->animation->play(HX_("normal",27,72,69,30),null(),null(),null());
            				}
            			}
            		}
            	}


void PsychUIRadioGroup_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_110_draw)
HXLINE( 111)		this->super::draw();
HXLINE( 113)		bool _hx_tmp;
HXDLIN( 113)		bool _hx_tmp1;
HXDLIN( 113)		if (::hx::IsNotNull( this->arrowUp )) {
HXLINE( 113)			_hx_tmp1 = this->arrowUp->exists;
            		}
            		else {
HXLINE( 113)			_hx_tmp1 = false;
            		}
HXDLIN( 113)		if (_hx_tmp1) {
HXLINE( 113)			_hx_tmp = this->arrowUp->active;
            		}
            		else {
HXLINE( 113)			_hx_tmp = false;
            		}
HXDLIN( 113)		if (_hx_tmp) {
HXLINE( 114)			this->arrowUp->draw();
            		}
HXLINE( 116)		bool _hx_tmp2;
HXDLIN( 116)		bool _hx_tmp3;
HXDLIN( 116)		if (::hx::IsNotNull( this->arrowDown )) {
HXLINE( 116)			_hx_tmp3 = this->arrowDown->exists;
            		}
            		else {
HXLINE( 116)			_hx_tmp3 = false;
            		}
HXDLIN( 116)		if (_hx_tmp3) {
HXLINE( 116)			_hx_tmp2 = this->arrowDown->active;
            		}
            		else {
HXLINE( 116)			_hx_tmp2 = false;
            		}
HXDLIN( 116)		if (_hx_tmp2) {
HXLINE( 117)			this->arrowDown->draw();
            		}
            	}


void PsychUIRadioGroup_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_121_destroy)
HXLINE( 122)		this->_hitbox = ( ( ::flixel::FlxObject)(::flixel::util::FlxDestroyUtil_obj::destroy(this->_hitbox)) );
HXLINE( 123)		this->arrowUp = ( ( ::flixel::FlxSprite)(::flixel::util::FlxDestroyUtil_obj::destroy(this->arrowUp)) );
HXLINE( 124)		this->arrowDown = ( ( ::flixel::FlxSprite)(::flixel::util::FlxDestroyUtil_obj::destroy(this->arrowDown)) );
HXLINE( 125)		this->super::destroy();
            	}


int PsychUIRadioGroup_obj::set_curScroll(int v){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_130_set_curScroll)
HXLINE( 131)		int lastScroll = this->curScroll;
HXLINE( 132)		bool _hx_tmp;
HXDLIN( 132)		if ((this->maxItems > 0)) {
HXLINE( 132)			_hx_tmp = (this->labels->length > this->maxItems);
            		}
            		else {
HXLINE( 132)			_hx_tmp = false;
            		}
HXDLIN( 132)		if (_hx_tmp) {
HXLINE( 134)			 ::Dynamic Max = (this->labels->length - this->maxItems);
HXDLIN( 134)			Float lowerBound;
HXDLIN( 134)			if ((v < 0)) {
HXLINE( 134)				lowerBound = ( (Float)(0) );
            			}
            			else {
HXLINE( 134)				lowerBound = ( (Float)(v) );
            			}
HXDLIN( 134)			Float _hx_tmp1;
HXDLIN( 134)			bool _hx_tmp2;
HXDLIN( 134)			if (::hx::IsNotNull( Max )) {
HXLINE( 134)				_hx_tmp2 = ::hx::IsGreater( lowerBound,Max );
            			}
            			else {
HXLINE( 134)				_hx_tmp2 = false;
            			}
HXDLIN( 134)			if (_hx_tmp2) {
HXLINE( 134)				_hx_tmp1 = ( (Float)(Max) );
            			}
            			else {
HXLINE( 134)				_hx_tmp1 = lowerBound;
            			}
HXDLIN( 134)			this->curScroll = ::Std_obj::_hx_int(_hx_tmp1);
HXLINE( 135)			bool _hx_tmp3;
HXDLIN( 135)			if (::hx::IsNotNull( this->arrowUp )) {
HXLINE( 135)				_hx_tmp3 = this->arrowUp->exists;
            			}
            			else {
HXLINE( 135)				_hx_tmp3 = false;
            			}
HXDLIN( 135)			if (_hx_tmp3) {
HXLINE( 137)				 ::flixel::FlxSprite _hx_tmp4 = this->arrowUp;
HXDLIN( 137)				_hx_tmp4->set_visible(this->arrowUp->set_active(true));
HXLINE( 138)				Float _hx_tmp5;
HXDLIN( 138)				if ((this->curScroll != 0)) {
HXLINE( 138)					_hx_tmp5 = ( (Float)(1) );
            				}
            				else {
HXLINE( 138)					_hx_tmp5 = ((Float)0.4);
            				}
HXDLIN( 138)				this->arrowUp->set_alpha(_hx_tmp5);
            			}
HXLINE( 140)			bool _hx_tmp6;
HXDLIN( 140)			if (::hx::IsNotNull( this->arrowDown )) {
HXLINE( 140)				_hx_tmp6 = this->arrowDown->exists;
            			}
            			else {
HXLINE( 140)				_hx_tmp6 = false;
            			}
HXDLIN( 140)			if (_hx_tmp6) {
HXLINE( 142)				 ::flixel::FlxSprite _hx_tmp7 = this->arrowDown;
HXDLIN( 142)				_hx_tmp7->set_visible(this->arrowDown->set_active(true));
HXLINE( 143)				Float _hx_tmp8;
HXDLIN( 143)				if ((this->curScroll != (this->labels->length - this->maxItems))) {
HXLINE( 143)					_hx_tmp8 = ( (Float)(1) );
            				}
            				else {
HXLINE( 143)					_hx_tmp8 = ((Float)0.4);
            				}
HXDLIN( 143)				this->arrowDown->set_alpha(_hx_tmp8);
            			}
            		}
            		else {
HXLINE( 148)			this->curScroll = 0;
HXLINE( 149)			bool _hx_tmp9;
HXDLIN( 149)			if (::hx::IsNotNull( this->arrowUp )) {
HXLINE( 149)				_hx_tmp9 = this->arrowUp->exists;
            			}
            			else {
HXLINE( 149)				_hx_tmp9 = false;
            			}
HXDLIN( 149)			if (_hx_tmp9) {
HXLINE( 151)				 ::flixel::FlxSprite _hx_tmp10 = this->arrowUp;
HXDLIN( 151)				_hx_tmp10->set_visible(this->arrowUp->set_active(false));
HXLINE( 152)				this->arrowUp->set_alpha(( (Float)(1) ));
            			}
HXLINE( 154)			bool _hx_tmp11;
HXDLIN( 154)			if (::hx::IsNotNull( this->arrowDown )) {
HXLINE( 154)				_hx_tmp11 = this->arrowDown->exists;
            			}
            			else {
HXLINE( 154)				_hx_tmp11 = false;
            			}
HXDLIN( 154)			if (_hx_tmp11) {
HXLINE( 156)				 ::flixel::FlxSprite _hx_tmp12 = this->arrowDown;
HXDLIN( 156)				_hx_tmp12->set_visible(this->arrowDown->set_active(false));
HXLINE( 157)				this->arrowDown->set_alpha(( (Float)(1) ));
            			}
            		}
HXLINE( 160)		if ((this->curScroll != lastScroll)) {
HXLINE( 162)			this->set_checked((this->checked + (lastScroll - this->curScroll)));
HXLINE( 163)			this->updateRadioItems();
            		}
HXLINE( 165)		return this->curScroll;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIRadioGroup_obj,set_curScroll,return )

bool PsychUIRadioGroup_obj::set_stackHorizontal(bool v){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_169_set_stackHorizontal)
HXLINE( 170)		this->stackHorizontal = v;
HXLINE( 171)		this->updateRadioItems();
HXLINE( 172)		return this->stackHorizontal;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIRadioGroup_obj,set_stackHorizontal,return )

int PsychUIRadioGroup_obj::set_checked(int v){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_176_set_checked)
HXLINE( 177)		 ::Dynamic Max = ::Math_obj::min(( (Float)((this->labels->length - 1)) ),( (Float)((this->radios->length - 1)) ));
HXDLIN( 177)		Float lowerBound;
HXDLIN( 177)		if ((v < -1)) {
HXLINE( 177)			lowerBound = ( (Float)(-1) );
            		}
            		else {
HXLINE( 177)			lowerBound = ( (Float)(v) );
            		}
HXDLIN( 177)		Float _hx_tmp;
HXDLIN( 177)		bool _hx_tmp1;
HXDLIN( 177)		if (::hx::IsNotNull( Max )) {
HXLINE( 177)			_hx_tmp1 = ::hx::IsGreater( lowerBound,Max );
            		}
            		else {
HXLINE( 177)			_hx_tmp1 = false;
            		}
HXDLIN( 177)		if (_hx_tmp1) {
HXLINE( 177)			_hx_tmp = ( (Float)(Max) );
            		}
            		else {
HXLINE( 177)			_hx_tmp = lowerBound;
            		}
HXDLIN( 177)		this->checked = ::Std_obj::_hx_int(_hx_tmp);
HXLINE( 178)		this->checkedRadio = null();
HXLINE( 179)		{
HXLINE( 179)			int _g_current = 0;
HXDLIN( 179)			::Array< ::Dynamic> _g_array = this->radios;
HXDLIN( 179)			while((_g_current < _g_array->length)){
HXLINE( 179)				 ::backend::ui::PsychUIRadioItem _g_value = _g_array->__get(_g_current).StaticCast<  ::backend::ui::PsychUIRadioItem >();
HXDLIN( 179)				_g_current = (_g_current + 1);
HXDLIN( 179)				int _g_key = (_g_current - 1);
HXDLIN( 179)				int num = _g_key;
HXDLIN( 179)				 ::backend::ui::PsychUIRadioItem radio = _g_value;
HXLINE( 180)				{
HXLINE( 181)					radio->set_checked((num == this->checked));
HXLINE( 182)					if ((num == this->checked)) {
HXLINE( 182)						this->checkedRadio = radio;
            					}
            				}
            			}
            		}
HXLINE( 184)		return this->checked;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIRadioGroup_obj,set_checked,return )

::Array< ::String > PsychUIRadioGroup_obj::set_labels(::Array< ::String > v){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_188_set_labels)
HXLINE( 189)		this->labels = v;
HXLINE( 190)		this->updateRadioItems();
HXLINE( 191)		this->set_checked(this->checked);
HXLINE( 192)		this->set_curScroll(this->curScroll);
HXLINE( 193)		return this->labels;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIRadioGroup_obj,set_labels,return )

 ::backend::ui::PsychUIRadioItem PsychUIRadioGroup_obj::set_checkedRadio( ::backend::ui::PsychUIRadioItem v){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_197_set_checkedRadio)
HXLINE( 198)		this->checkedRadio = null();
HXLINE( 199)		this->checked = -1;
HXLINE( 200)		{
HXLINE( 200)			int _g_current = 0;
HXDLIN( 200)			::Array< ::Dynamic> _g_array = this->radios;
HXDLIN( 200)			while((_g_current < _g_array->length)){
HXLINE( 200)				 ::backend::ui::PsychUIRadioItem _g_value = _g_array->__get(_g_current).StaticCast<  ::backend::ui::PsychUIRadioItem >();
HXDLIN( 200)				_g_current = (_g_current + 1);
HXDLIN( 200)				int _g_key = (_g_current - 1);
HXDLIN( 200)				int num = _g_key;
HXDLIN( 200)				 ::backend::ui::PsychUIRadioItem radio = _g_value;
HXLINE( 201)				{
HXLINE( 202)					radio->set_checked(::hx::IsInstanceEq( v,radio ));
HXLINE( 203)					if (::hx::IsInstanceEq( v,radio )) {
HXLINE( 205)						this->checkedRadio = radio;
HXLINE( 206)						this->checked = num;
            					}
            				}
            			}
            		}
HXLINE( 209)		return this->checkedRadio;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIRadioGroup_obj,set_checkedRadio,return )

Float PsychUIRadioGroup_obj::set_space(Float v){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_213_set_space)
HXLINE( 214)		this->space = v;
HXLINE( 215)		{
HXLINE( 215)			int _g_current = 0;
HXDLIN( 215)			::Array< ::Dynamic> _g_array = this->radios;
HXDLIN( 215)			while((_g_current < _g_array->length)){
HXLINE( 215)				 ::backend::ui::PsychUIRadioItem _g_value = _g_array->__get(_g_current).StaticCast<  ::backend::ui::PsychUIRadioItem >();
HXDLIN( 215)				_g_current = (_g_current + 1);
HXDLIN( 215)				int _g_key = (_g_current - 1);
HXDLIN( 215)				int num = _g_key;
HXDLIN( 215)				 ::backend::ui::PsychUIRadioItem radio = _g_value;
HXLINE( 217)				if (!(this->stackHorizontal)) {
HXLINE( 218)					radio->set_y((this->y + (( (Float)(num) ) * this->space)));
            				}
            				else {
HXLINE( 220)					radio->set_x((this->x + (( (Float)(num) ) * (this->textWidth + this->space))));
            				}
            			}
            		}
HXLINE( 223)		return this->space;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIRadioGroup_obj,set_space,return )

int PsychUIRadioGroup_obj::set_textWidth(int v){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_228_set_textWidth)
HXLINE( 229)		this->textWidth = v;
HXLINE( 230)		{
HXLINE( 230)			int _g_current = 0;
HXDLIN( 230)			::Array< ::Dynamic> _g_array = this->radios;
HXDLIN( 230)			while((_g_current < _g_array->length)){
HXLINE( 230)				 ::backend::ui::PsychUIRadioItem _g_value = _g_array->__get(_g_current).StaticCast<  ::backend::ui::PsychUIRadioItem >();
HXDLIN( 230)				_g_current = (_g_current + 1);
HXDLIN( 230)				int _g_key = (_g_current - 1);
HXDLIN( 230)				int num = _g_key;
HXDLIN( 230)				 ::backend::ui::PsychUIRadioItem radio = _g_value;
HXLINE( 231)				radio->text->set_fieldWidth(( (Float)(this->textWidth) ));
            			}
            		}
HXLINE( 233)		return this->textWidth;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIRadioGroup_obj,set_textWidth,return )

int PsychUIRadioGroup_obj::set_maxItems(int v){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_237_set_maxItems)
HXLINE( 238)		this->maxItems = v;
HXLINE( 239)		this->set_curScroll(this->curScroll);
HXLINE( 241)		this->updateRadioItems();
HXLINE( 242)		return this->maxItems;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIRadioGroup_obj,set_maxItems,return )

void PsychUIRadioGroup_obj::updateRadioItems(){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_246_updateRadioItems)
HXLINE( 247)		if ((this->maxItems > 0)) {
HXLINE( 249)			{
HXLINE( 249)				int _g = 0;
HXDLIN( 249)				::Array< ::Dynamic> _g1 = this->radios;
HXDLIN( 249)				while((_g < _g1->length)){
HXLINE( 249)					 ::backend::ui::PsychUIRadioItem radio = _g1->__get(_g).StaticCast<  ::backend::ui::PsychUIRadioItem >();
HXDLIN( 249)					_g = (_g + 1);
HXLINE( 250)					radio->kill();
            				}
            			}
HXLINE( 252)			this->radios = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 253)			{
HXLINE( 253)				int _g2 = 0;
HXDLIN( 253)				int _g3 = this->maxItems;
HXDLIN( 253)				while((_g2 < _g3)){
HXLINE( 253)					_g2 = (_g2 + 1);
HXDLIN( 253)					int i = (_g2 - 1);
HXLINE( 255)					 ::flixel::FlxSprite rad = this->_addNewRadio();
HXLINE( 256)					if ((i >= this->labels->length)) {
HXLINE( 257)						rad->set_visible(rad->set_active(false));
            					}
            				}
            			}
            		}
            		else {
HXLINE( 262)			while((this->radios->length > this->labels->length)){
HXLINE( 265)				this->radios->__get((this->radios->length - 1)).StaticCast<  ::backend::ui::PsychUIRadioItem >()->kill();
HXLINE( 266)				this->radios->pop().StaticCast<  ::backend::ui::PsychUIRadioItem >();
            			}
HXLINE( 268)			while((this->radios->length < this->labels->length)){
HXLINE( 271)				this->_addNewRadio();
            			}
            		}
HXLINE( 275)		{
HXLINE( 275)			int _g_current = 0;
HXDLIN( 275)			::Array< ::Dynamic> _g_array = this->radios;
HXDLIN( 275)			while((_g_current < _g_array->length)){
HXLINE( 275)				 ::backend::ui::PsychUIRadioItem _g_value = _g_array->__get(_g_current).StaticCast<  ::backend::ui::PsychUIRadioItem >();
HXDLIN( 275)				_g_current = (_g_current + 1);
HXDLIN( 275)				int _g_key = (_g_current - 1);
HXDLIN( 275)				int num = _g_key;
HXDLIN( 275)				 ::backend::ui::PsychUIRadioItem radio1 = _g_value;
HXLINE( 276)				{
HXLINE( 277)					bool _hx_tmp;
HXDLIN( 277)					if ((num >= this->labels->length)) {
HXLINE( 277)						_hx_tmp = (this->labels->length > this->maxItems);
            					}
            					else {
HXLINE( 277)						_hx_tmp = true;
            					}
HXDLIN( 277)					radio1->set_visible(radio1->set_active(_hx_tmp));
HXLINE( 278)					::String _hx_tmp1;
HXDLIN( 278)					if (::hx::IsNotNull( this->labels->__get((num + this->curScroll)) )) {
HXLINE( 278)						_hx_tmp1 = this->labels->__get((num + this->curScroll));
            					}
            					else {
HXLINE( 278)						_hx_tmp1 = HX_("",00,00,00,00);
            					}
HXDLIN( 278)					radio1->set_label(_hx_tmp1);
HXLINE( 279)					if (!(this->stackHorizontal)) {
HXLINE( 281)						radio1->set_x(this->x);
HXLINE( 282)						radio1->set_y((this->y + (( (Float)(num) ) * this->space)));
            					}
            					else {
HXLINE( 286)						radio1->set_x((this->x + (( (Float)(num) ) * (this->textWidth + this->space))));
HXLINE( 287)						radio1->set_y(this->y);
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(PsychUIRadioGroup_obj,updateRadioItems,(void))

::Array< ::Dynamic> PsychUIRadioGroup_obj::set_cameras(::Array< ::Dynamic> v){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_293_set_cameras)
HXLINE( 294)		bool _hx_tmp;
HXDLIN( 294)		if (::hx::IsNotNull( this->arrowUp )) {
HXLINE( 294)			_hx_tmp = this->arrowUp->exists;
            		}
            		else {
HXLINE( 294)			_hx_tmp = false;
            		}
HXDLIN( 294)		if (_hx_tmp) {
HXLINE( 294)			this->arrowUp->set_cameras(v);
            		}
HXLINE( 295)		bool _hx_tmp1;
HXDLIN( 295)		if (::hx::IsNotNull( this->arrowDown )) {
HXLINE( 295)			_hx_tmp1 = this->arrowDown->exists;
            		}
            		else {
HXLINE( 295)			_hx_tmp1 = false;
            		}
HXDLIN( 295)		if (_hx_tmp1) {
HXLINE( 295)			this->arrowDown->set_cameras(v);
            		}
HXLINE( 296)		return this->super::set_cameras(v);
            	}


 ::flixel::FlxCamera PsychUIRadioGroup_obj::set_camera( ::flixel::FlxCamera v){
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_300_set_camera)
HXLINE( 301)		bool _hx_tmp;
HXDLIN( 301)		if (::hx::IsNotNull( this->arrowUp )) {
HXLINE( 301)			_hx_tmp = this->arrowUp->exists;
            		}
            		else {
HXLINE( 301)			_hx_tmp = false;
            		}
HXDLIN( 301)		if (_hx_tmp) {
HXLINE( 301)			this->arrowUp->set_camera(v);
            		}
HXLINE( 302)		bool _hx_tmp1;
HXDLIN( 302)		if (::hx::IsNotNull( this->arrowDown )) {
HXLINE( 302)			_hx_tmp1 = this->arrowDown->exists;
            		}
            		else {
HXLINE( 302)			_hx_tmp1 = false;
            		}
HXDLIN( 302)		if (_hx_tmp1) {
HXLINE( 302)			this->arrowDown->set_camera(v);
            		}
HXLINE( 303)		return this->super::set_camera(v);
            	}


 ::flixel::FlxSprite PsychUIRadioGroup_obj::_addNewRadio(){
            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0, ::backend::ui::PsychUIRadioGroup,_gthis, ::backend::ui::PsychUIRadioItem,radio) HXARGC(0)
            		void _hx_run(){
            			HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_310__addNewRadio)
HXLINE( 311)			_gthis->set_checkedRadio(radio);
HXLINE( 312)			if (::hx::IsNotNull( _gthis->onClick )) {
HXLINE( 312)				_gthis->onClick();
            			}
HXLINE( 313)			if (_gthis->broadcastRadioGroupEvent) {
HXLINE( 313)				::backend::ui::PsychUIEventHandler_obj::event(::backend::ui::PsychUIRadioGroup_obj::CLICK_EVENT,_gthis);
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_308__addNewRadio)
HXDLIN( 308)		 ::backend::ui::PsychUIRadioGroup _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 309)		 ::Dynamic ObjectFactory = null();
HXDLIN( 309)		 ::backend::ui::PsychUIRadioItem radio = ( ( ::backend::ui::PsychUIRadioItem)(this->group->recycle(::hx::ClassOf< ::backend::ui::PsychUIRadioItem >(),ObjectFactory,false,true).StaticCast<  ::flixel::FlxSprite >()) );
HXLINE( 310)		radio->onClick =  ::Dynamic(new _hx_Closure_0(_gthis,radio));
HXLINE( 315)		 ::backend::ui::PsychUIRadioItem radio1 = radio;
HXDLIN( 315)		radio1->set_visible(radio->set_active(true));
HXLINE( 316)		radio->text->set_fieldWidth(( (Float)(this->textWidth) ));
HXLINE( 317)		this->radios->push(radio);
HXLINE( 318)		return ( ( ::flixel::FlxSprite)(this->insert(0,radio)) );
            	}


HX_DEFINE_DYNAMIC_FUNC0(PsychUIRadioGroup_obj,_addNewRadio,return )

::String PsychUIRadioGroup_obj::CLICK_EVENT;


::hx::ObjectPtr< PsychUIRadioGroup_obj > PsychUIRadioGroup_obj::__new(Float x,Float y,::Array< ::String > labels,::hx::Null< Float >  __o_space,::hx::Null< int >  __o_maxItems, ::Dynamic __o_isHorizontal, ::Dynamic __o_textWidth) {
	::hx::ObjectPtr< PsychUIRadioGroup_obj > __this = new PsychUIRadioGroup_obj();
	__this->__construct(x,y,labels,__o_space,__o_maxItems,__o_isHorizontal,__o_textWidth);
	return __this;
}

::hx::ObjectPtr< PsychUIRadioGroup_obj > PsychUIRadioGroup_obj::__alloc(::hx::Ctx *_hx_ctx,Float x,Float y,::Array< ::String > labels,::hx::Null< Float >  __o_space,::hx::Null< int >  __o_maxItems, ::Dynamic __o_isHorizontal, ::Dynamic __o_textWidth) {
	PsychUIRadioGroup_obj *__this = (PsychUIRadioGroup_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PsychUIRadioGroup_obj), true, "backend.ui.PsychUIRadioGroup"));
	*(void **)__this = PsychUIRadioGroup_obj::_hx_vtable;
	__this->__construct(x,y,labels,__o_space,__o_maxItems,__o_isHorizontal,__o_textWidth);
	return __this;
}

PsychUIRadioGroup_obj::PsychUIRadioGroup_obj()
{
}

void PsychUIRadioGroup_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PsychUIRadioGroup);
	HX_MARK_MEMBER_NAME(labels,"labels");
	HX_MARK_MEMBER_NAME(radios,"radios");
	HX_MARK_MEMBER_NAME(space,"space");
	HX_MARK_MEMBER_NAME(textWidth,"textWidth");
	HX_MARK_MEMBER_NAME(maxItems,"maxItems");
	HX_MARK_MEMBER_NAME(stackHorizontal,"stackHorizontal");
	HX_MARK_MEMBER_NAME(checked,"checked");
	HX_MARK_MEMBER_NAME(checkedRadio,"checkedRadio");
	HX_MARK_MEMBER_NAME(arrowUp,"arrowUp");
	HX_MARK_MEMBER_NAME(arrowDown,"arrowDown");
	HX_MARK_MEMBER_NAME(onClick,"onClick");
	HX_MARK_MEMBER_NAME(_hitbox,"_hitbox");
	HX_MARK_MEMBER_NAME(curScroll,"curScroll");
	HX_MARK_MEMBER_NAME(broadcastRadioGroupEvent,"broadcastRadioGroupEvent");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void PsychUIRadioGroup_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(labels,"labels");
	HX_VISIT_MEMBER_NAME(radios,"radios");
	HX_VISIT_MEMBER_NAME(space,"space");
	HX_VISIT_MEMBER_NAME(textWidth,"textWidth");
	HX_VISIT_MEMBER_NAME(maxItems,"maxItems");
	HX_VISIT_MEMBER_NAME(stackHorizontal,"stackHorizontal");
	HX_VISIT_MEMBER_NAME(checked,"checked");
	HX_VISIT_MEMBER_NAME(checkedRadio,"checkedRadio");
	HX_VISIT_MEMBER_NAME(arrowUp,"arrowUp");
	HX_VISIT_MEMBER_NAME(arrowDown,"arrowDown");
	HX_VISIT_MEMBER_NAME(onClick,"onClick");
	HX_VISIT_MEMBER_NAME(_hitbox,"_hitbox");
	HX_VISIT_MEMBER_NAME(curScroll,"curScroll");
	HX_VISIT_MEMBER_NAME(broadcastRadioGroupEvent,"broadcastRadioGroupEvent");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val PsychUIRadioGroup_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"space") ) { return ::hx::Val( space ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"labels") ) { return ::hx::Val( labels ); }
		if (HX_FIELD_EQ(inName,"radios") ) { return ::hx::Val( radios ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"checked") ) { return ::hx::Val( checked ); }
		if (HX_FIELD_EQ(inName,"arrowUp") ) { return ::hx::Val( arrowUp ); }
		if (HX_FIELD_EQ(inName,"onClick") ) { return ::hx::Val( onClick ); }
		if (HX_FIELD_EQ(inName,"_hitbox") ) { return ::hx::Val( _hitbox ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"maxItems") ) { return ::hx::Val( maxItems ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"textWidth") ) { return ::hx::Val( textWidth ); }
		if (HX_FIELD_EQ(inName,"arrowDown") ) { return ::hx::Val( arrowDown ); }
		if (HX_FIELD_EQ(inName,"curScroll") ) { return ::hx::Val( curScroll ); }
		if (HX_FIELD_EQ(inName,"set_space") ) { return ::hx::Val( set_space_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"set_labels") ) { return ::hx::Val( set_labels_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_camera") ) { return ::hx::Val( set_camera_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"set_checked") ) { return ::hx::Val( set_checked_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_cameras") ) { return ::hx::Val( set_cameras_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"checkedRadio") ) { return ::hx::Val( checkedRadio ); }
		if (HX_FIELD_EQ(inName,"set_maxItems") ) { return ::hx::Val( set_maxItems_dyn() ); }
		if (HX_FIELD_EQ(inName,"_addNewRadio") ) { return ::hx::Val( _addNewRadio_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"set_curScroll") ) { return ::hx::Val( set_curScroll_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_textWidth") ) { return ::hx::Val( set_textWidth_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"stackHorizontal") ) { return ::hx::Val( stackHorizontal ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"set_checkedRadio") ) { return ::hx::Val( set_checkedRadio_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateRadioItems") ) { return ::hx::Val( updateRadioItems_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"set_stackHorizontal") ) { return ::hx::Val( set_stackHorizontal_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"broadcastRadioGroupEvent") ) { return ::hx::Val( broadcastRadioGroupEvent ); }
	}
	return super::__Field(inName,inCallProp);
}

bool PsychUIRadioGroup_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"CLICK_EVENT") ) { outValue = ( CLICK_EVENT ); return true; }
	}
	return false;
}

::hx::Val PsychUIRadioGroup_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"space") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_space(inValue.Cast< Float >()) );space=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"labels") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_labels(inValue.Cast< ::Array< ::String > >()) );labels=inValue.Cast< ::Array< ::String > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"radios") ) { radios=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"checked") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_checked(inValue.Cast< int >()) );checked=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"arrowUp") ) { arrowUp=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"onClick") ) { onClick=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_hitbox") ) { _hitbox=inValue.Cast<  ::flixel::FlxObject >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"maxItems") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_maxItems(inValue.Cast< int >()) );maxItems=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"textWidth") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_textWidth(inValue.Cast< int >()) );textWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"arrowDown") ) { arrowDown=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"curScroll") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_curScroll(inValue.Cast< int >()) );curScroll=inValue.Cast< int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"checkedRadio") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_checkedRadio(inValue.Cast<  ::backend::ui::PsychUIRadioItem >()) );checkedRadio=inValue.Cast<  ::backend::ui::PsychUIRadioItem >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"stackHorizontal") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_stackHorizontal(inValue.Cast< bool >()) );stackHorizontal=inValue.Cast< bool >(); return inValue; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"broadcastRadioGroupEvent") ) { broadcastRadioGroupEvent=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool PsychUIRadioGroup_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"CLICK_EVENT") ) { CLICK_EVENT=ioValue.Cast< ::String >(); return true; }
	}
	return false;
}

void PsychUIRadioGroup_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("labels",ff,27,7d,49));
	outFields->push(HX_("radios",18,cb,f6,b0));
	outFields->push(HX_("space",c6,8c,66,81));
	outFields->push(HX_("textWidth",19,46,50,63));
	outFields->push(HX_("maxItems",bc,fe,29,6c));
	outFields->push(HX_("stackHorizontal",4c,52,f5,e7));
	outFields->push(HX_("checked",27,b3,24,13));
	outFields->push(HX_("checkedRadio",54,00,23,fb));
	outFields->push(HX_("arrowUp",84,88,b8,43));
	outFields->push(HX_("arrowDown",cb,b6,11,fe));
	outFields->push(HX_("_hitbox",37,ff,9e,c5));
	outFields->push(HX_("curScroll",ad,f1,f1,b7));
	outFields->push(HX_("broadcastRadioGroupEvent",35,8b,12,ed));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo PsychUIRadioGroup_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(PsychUIRadioGroup_obj,labels),HX_("labels",ff,27,7d,49)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(PsychUIRadioGroup_obj,radios),HX_("radios",18,cb,f6,b0)},
	{::hx::fsFloat,(int)offsetof(PsychUIRadioGroup_obj,space),HX_("space",c6,8c,66,81)},
	{::hx::fsInt,(int)offsetof(PsychUIRadioGroup_obj,textWidth),HX_("textWidth",19,46,50,63)},
	{::hx::fsInt,(int)offsetof(PsychUIRadioGroup_obj,maxItems),HX_("maxItems",bc,fe,29,6c)},
	{::hx::fsBool,(int)offsetof(PsychUIRadioGroup_obj,stackHorizontal),HX_("stackHorizontal",4c,52,f5,e7)},
	{::hx::fsInt,(int)offsetof(PsychUIRadioGroup_obj,checked),HX_("checked",27,b3,24,13)},
	{::hx::fsObject /*  ::backend::ui::PsychUIRadioItem */ ,(int)offsetof(PsychUIRadioGroup_obj,checkedRadio),HX_("checkedRadio",54,00,23,fb)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(PsychUIRadioGroup_obj,arrowUp),HX_("arrowUp",84,88,b8,43)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(PsychUIRadioGroup_obj,arrowDown),HX_("arrowDown",cb,b6,11,fe)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(PsychUIRadioGroup_obj,onClick),HX_("onClick",a9,1a,9c,de)},
	{::hx::fsObject /*  ::flixel::FlxObject */ ,(int)offsetof(PsychUIRadioGroup_obj,_hitbox),HX_("_hitbox",37,ff,9e,c5)},
	{::hx::fsInt,(int)offsetof(PsychUIRadioGroup_obj,curScroll),HX_("curScroll",ad,f1,f1,b7)},
	{::hx::fsBool,(int)offsetof(PsychUIRadioGroup_obj,broadcastRadioGroupEvent),HX_("broadcastRadioGroupEvent",35,8b,12,ed)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo PsychUIRadioGroup_obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &PsychUIRadioGroup_obj::CLICK_EVENT,HX_("CLICK_EVENT",63,89,c0,0d)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String PsychUIRadioGroup_obj_sMemberFields[] = {
	HX_("labels",ff,27,7d,49),
	HX_("radios",18,cb,f6,b0),
	HX_("space",c6,8c,66,81),
	HX_("textWidth",19,46,50,63),
	HX_("maxItems",bc,fe,29,6c),
	HX_("stackHorizontal",4c,52,f5,e7),
	HX_("checked",27,b3,24,13),
	HX_("checkedRadio",54,00,23,fb),
	HX_("arrowUp",84,88,b8,43),
	HX_("arrowDown",cb,b6,11,fe),
	HX_("onClick",a9,1a,9c,de),
	HX_("_hitbox",37,ff,9e,c5),
	HX_("update",09,86,05,87),
	HX_("draw",04,2c,70,42),
	HX_("destroy",fa,2c,86,24),
	HX_("curScroll",ad,f1,f1,b7),
	HX_("set_curScroll",90,a7,5b,be),
	HX_("set_stackHorizontal",6f,14,9d,af),
	HX_("set_checked",4a,1a,8c,a3),
	HX_("set_labels",3c,36,82,3d),
	HX_("set_checkedRadio",51,da,03,56),
	HX_("set_space",29,d5,60,a8),
	HX_("set_textWidth",fc,fb,b9,69),
	HX_("set_maxItems",39,d6,3c,36),
	HX_("updateRadioItems",6e,6c,67,f5),
	HX_("set_cameras",51,f1,98,73),
	HX_("set_camera",e2,54,91,ab),
	HX_("broadcastRadioGroupEvent",35,8b,12,ed),
	HX_("_addNewRadio",bd,39,c8,9e),
	::String(null()) };

static void PsychUIRadioGroup_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(PsychUIRadioGroup_obj::CLICK_EVENT,"CLICK_EVENT");
};

#ifdef HXCPP_VISIT_ALLOCS
static void PsychUIRadioGroup_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(PsychUIRadioGroup_obj::CLICK_EVENT,"CLICK_EVENT");
};

#endif

::hx::Class PsychUIRadioGroup_obj::__mClass;

static ::String PsychUIRadioGroup_obj_sStaticFields[] = {
	HX_("CLICK_EVENT",63,89,c0,0d),
	::String(null())
};

void PsychUIRadioGroup_obj::__register()
{
	PsychUIRadioGroup_obj _hx_dummy;
	PsychUIRadioGroup_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("backend.ui.PsychUIRadioGroup",53,ef,ff,c9);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &PsychUIRadioGroup_obj::__GetStatic;
	__mClass->mSetStaticField = &PsychUIRadioGroup_obj::__SetStatic;
	__mClass->mMarkFunc = PsychUIRadioGroup_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(PsychUIRadioGroup_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PsychUIRadioGroup_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PsychUIRadioGroup_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = PsychUIRadioGroup_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PsychUIRadioGroup_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PsychUIRadioGroup_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void PsychUIRadioGroup_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_dcff0badd08dd348_8_boot)
HXDLIN(   8)		CLICK_EVENT = HX_("radiogroup_click",ed,5a,7d,db);
            	}
}

} // end namespace backend
} // end namespace ui
