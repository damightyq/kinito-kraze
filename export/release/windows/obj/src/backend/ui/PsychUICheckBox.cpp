// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUICheckBox
#include <backend/ui/PsychUICheckBox.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIEventHandler
#include <backend/ui/PsychUIEventHandler.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_fade0a2b5d62043e_3_new,"backend.ui.PsychUICheckBox","new",0xcfbce564,"backend.ui.PsychUICheckBox.new","backend/ui/PsychUICheckBox.hx",3,0x157b312c)
HX_LOCAL_STACK_FRAME(_hx_pos_fade0a2b5d62043e_31_boxGraphic,"backend.ui.PsychUICheckBox","boxGraphic",0x0c09bf59,"backend.ui.PsychUICheckBox.boxGraphic","backend/ui/PsychUICheckBox.hx",31,0x157b312c)
static const int _hx_array_data_b645a372_2[] = {
	(int)0,
};
static const int _hx_array_data_b645a372_3[] = {
	(int)1,
};
HX_LOCAL_STACK_FRAME(_hx_pos_fade0a2b5d62043e_40_update,"backend.ui.PsychUICheckBox","update",0x635c6b85,"backend.ui.PsychUICheckBox.update","backend/ui/PsychUICheckBox.hx",40,0x157b312c)
HX_LOCAL_STACK_FRAME(_hx_pos_fade0a2b5d62043e_58_set_checked,"backend.ui.PsychUICheckBox","set_checked",0x9d57d34e,"backend.ui.PsychUICheckBox.set_checked","backend/ui/PsychUICheckBox.hx",58,0x157b312c)
HX_LOCAL_STACK_FRAME(_hx_pos_fade0a2b5d62043e_65_get_label,"backend.ui.PsychUICheckBox","get_label",0x60951a4f,"backend.ui.PsychUICheckBox.get_label","backend/ui/PsychUICheckBox.hx",65,0x157b312c)
HX_LOCAL_STACK_FRAME(_hx_pos_fade0a2b5d62043e_68_set_label,"backend.ui.PsychUICheckBox","set_label",0x43e6065b,"backend.ui.PsychUICheckBox.set_label","backend/ui/PsychUICheckBox.hx",68,0x157b312c)
HX_LOCAL_STACK_FRAME(_hx_pos_fade0a2b5d62043e_5_boot,"backend.ui.PsychUICheckBox","boot",0xeda4d2ae,"backend.ui.PsychUICheckBox.boot","backend/ui/PsychUICheckBox.hx",5,0x157b312c)
namespace backend{
namespace ui{

void PsychUICheckBox_obj::__construct(Float x,Float y,::String label, ::Dynamic __o_textWid, ::Dynamic callback){
            		 ::Dynamic textWid = __o_textWid;
            		if (::hx::IsNull(__o_textWid)) textWid = 100;
            	HX_GC_STACKFRAME(&_hx_pos_fade0a2b5d62043e_3_new)
HXLINE(  38)		this->broadcastCheckBoxEvent = true;
HXLINE(  13)		this->onClick = null();
HXLINE(  12)		this->checked = false;
HXLINE(  17)		super::__construct(x,y,null());
HXLINE(  19)		this->box =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  20)		this->boxGraphic();
HXLINE(  21)		this->add(this->box);
HXLINE(  23)		this->text =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,(this->box->get_width() + 4),0,textWid,label,null(),null());
HXLINE(  24)		 ::flixel::text::FlxText fh = this->text;
HXDLIN(  24)		Float fh1 = fh->y;
HXDLIN(  24)		Float _hx_tmp = (this->box->get_height() / ( (Float)(2) ));
HXDLIN(  24)		fh->set_y((fh1 + (_hx_tmp - (this->text->get_height() / ( (Float)(2) )))));
HXLINE(  25)		this->add(this->text);
HXLINE(  27)		this->onClick = callback;
            	}

Dynamic PsychUICheckBox_obj::__CreateEmpty() { return new PsychUICheckBox_obj; }

void *PsychUICheckBox_obj::_hx_vtable = 0;

Dynamic PsychUICheckBox_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PsychUICheckBox_obj > _hx_result = new PsychUICheckBox_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4]);
	return _hx_result;
}

bool PsychUICheckBox_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x5e94b94a) {
		if (inClassId<=(int)0x2c01639b) {
			if (inClassId<=(int)0x288ce903) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x288ce903;
			} else {
				return inClassId==(int)0x2c01639b;
			}
		} else {
			return inClassId==(int)0x5e94b94a;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void PsychUICheckBox_obj::boxGraphic(){
            	HX_STACKFRAME(&_hx_pos_fade0a2b5d62043e_31_boxGraphic)
HXLINE(  32)		 ::flixel::FlxSprite _hx_tmp = this->box;
HXDLIN(  32)		_hx_tmp->loadGraphic(::backend::Paths_obj::image(HX_("psych-ui/checkbox",4c,a3,97,89),HX_("embed",d9,8d,cf,6f),null()),true,16,16,null(),null());
HXLINE(  33)		this->box->animation->add(HX_("false",a3,35,4f,fb),::Array_obj< int >::fromData( _hx_array_data_b645a372_2,1),null(),null(),null(),null());
HXLINE(  34)		this->box->animation->add(HX_("true",4e,a7,03,4d),::Array_obj< int >::fromData( _hx_array_data_b645a372_3,1),null(),null(),null(),null());
HXLINE(  35)		this->box->animation->play(HX_("false",a3,35,4f,fb),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(PsychUICheckBox_obj,boxGraphic,(void))

void PsychUICheckBox_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_fade0a2b5d62043e_40_update)
HXLINE(  41)		this->super::update(elapsed);
HXLINE(  43)		if ((::flixel::FlxG_obj::mouse->_leftButton->current == 2)) {
HXLINE(  45)			 ::flixel::math::FlxBasePoint screenPos = this->getScreenPosition(null(),this->get_camera());
HXLINE(  46)			 ::flixel::input::mouse::FlxMouse mousePos = ::flixel::FlxG_obj::mouse;
HXDLIN(  46)			 ::flixel::math::FlxBasePoint mousePos1 = mousePos->getPositionInCameraView(this->get_camera(),null());
HXLINE(  47)			bool _hx_tmp;
HXDLIN(  47)			bool _hx_tmp1;
HXDLIN(  47)			if ((mousePos1->x >= screenPos->x)) {
HXLINE(  47)				Float mousePos2 = mousePos1->x;
HXDLIN(  47)				Float screenPos1 = screenPos->x;
HXDLIN(  47)				_hx_tmp1 = (mousePos2 < (screenPos1 + this->get_width()));
            			}
            			else {
HXLINE(  47)				_hx_tmp1 = false;
            			}
HXDLIN(  47)			if (_hx_tmp1) {
HXLINE(  48)				if ((mousePos1->y >= screenPos->y)) {
HXLINE(  48)					Float mousePos3 = mousePos1->y;
HXDLIN(  48)					Float screenPos2 = screenPos->y;
HXLINE(  47)					_hx_tmp = (mousePos3 < (screenPos2 + this->get_height()));
            				}
            				else {
HXLINE(  47)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE(  47)				_hx_tmp = false;
            			}
HXDLIN(  47)			if (_hx_tmp) {
HXLINE(  50)				this->set_checked(!(this->checked));
HXLINE(  51)				if (::hx::IsNotNull( this->onClick )) {
HXLINE(  51)					this->onClick();
            				}
HXLINE(  52)				if (this->broadcastCheckBoxEvent) {
HXLINE(  52)					::backend::ui::PsychUIEventHandler_obj::event(::backend::ui::PsychUICheckBox_obj::CLICK_EVENT,::hx::ObjectPtr<OBJ_>(this));
            				}
            			}
            		}
            	}


bool PsychUICheckBox_obj::set_checked( ::Dynamic v){
            	HX_STACKFRAME(&_hx_pos_fade0a2b5d62043e_58_set_checked)
HXLINE(  59)		bool v1;
HXDLIN(  59)		if (::hx::IsNotNull( v )) {
HXLINE(  59)			v1 = (( (bool)(v) ) != false);
            		}
            		else {
HXLINE(  59)			v1 = false;
            		}
HXLINE(  60)		 ::flixel::animation::FlxAnimationController _hx_tmp = this->box->animation;
HXDLIN(  60)		_hx_tmp->play(::Std_obj::string(v1),null(),null(),null());
HXLINE(  61)		return (this->checked = v1);
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUICheckBox_obj,set_checked,return )

::String PsychUICheckBox_obj::get_label(){
            	HX_STACKFRAME(&_hx_pos_fade0a2b5d62043e_65_get_label)
HXDLIN(  65)		return this->text->text;
            	}


HX_DEFINE_DYNAMIC_FUNC0(PsychUICheckBox_obj,get_label,return )

::String PsychUICheckBox_obj::set_label(::String v){
            	HX_STACKFRAME(&_hx_pos_fade0a2b5d62043e_68_set_label)
HXDLIN(  68)		return this->text->set_text(v);
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUICheckBox_obj,set_label,return )

::String PsychUICheckBox_obj::CLICK_EVENT;


::hx::ObjectPtr< PsychUICheckBox_obj > PsychUICheckBox_obj::__new(Float x,Float y,::String label, ::Dynamic __o_textWid, ::Dynamic callback) {
	::hx::ObjectPtr< PsychUICheckBox_obj > __this = new PsychUICheckBox_obj();
	__this->__construct(x,y,label,__o_textWid,callback);
	return __this;
}

::hx::ObjectPtr< PsychUICheckBox_obj > PsychUICheckBox_obj::__alloc(::hx::Ctx *_hx_ctx,Float x,Float y,::String label, ::Dynamic __o_textWid, ::Dynamic callback) {
	PsychUICheckBox_obj *__this = (PsychUICheckBox_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PsychUICheckBox_obj), true, "backend.ui.PsychUICheckBox"));
	*(void **)__this = PsychUICheckBox_obj::_hx_vtable;
	__this->__construct(x,y,label,__o_textWid,callback);
	return __this;
}

PsychUICheckBox_obj::PsychUICheckBox_obj()
{
}

void PsychUICheckBox_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PsychUICheckBox);
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(box,"box");
	HX_MARK_MEMBER_NAME(text,"text");
	HX_MARK_MEMBER_NAME(checked,"checked");
	HX_MARK_MEMBER_NAME(onClick,"onClick");
	HX_MARK_MEMBER_NAME(broadcastCheckBoxEvent,"broadcastCheckBoxEvent");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void PsychUICheckBox_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(box,"box");
	HX_VISIT_MEMBER_NAME(text,"text");
	HX_VISIT_MEMBER_NAME(checked,"checked");
	HX_VISIT_MEMBER_NAME(onClick,"onClick");
	HX_VISIT_MEMBER_NAME(broadcastCheckBoxEvent,"broadcastCheckBoxEvent");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val PsychUICheckBox_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"box") ) { return ::hx::Val( box ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { return ::hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"text") ) { return ::hx::Val( text ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"label") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_label() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"checked") ) { return ::hx::Val( checked ); }
		if (HX_FIELD_EQ(inName,"onClick") ) { return ::hx::Val( onClick ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"get_label") ) { return ::hx::Val( get_label_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_label") ) { return ::hx::Val( set_label_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"boxGraphic") ) { return ::hx::Val( boxGraphic_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"set_checked") ) { return ::hx::Val( set_checked_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"broadcastCheckBoxEvent") ) { return ::hx::Val( broadcastCheckBoxEvent ); }
	}
	return super::__Field(inName,inCallProp);
}

bool PsychUICheckBox_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"CLICK_EVENT") ) { outValue = ( CLICK_EVENT ); return true; }
	}
	return false;
}

::hx::Val PsychUICheckBox_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"box") ) { box=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"text") ) { text=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"label") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_label(inValue.Cast< ::String >()) ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"checked") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_checked(inValue.Cast< bool >()) );checked=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"onClick") ) { onClick=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"broadcastCheckBoxEvent") ) { broadcastCheckBoxEvent=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool PsychUICheckBox_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"CLICK_EVENT") ) { CLICK_EVENT=ioValue.Cast< ::String >(); return true; }
	}
	return false;
}

void PsychUICheckBox_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("name",4b,72,ff,48));
	outFields->push(HX_("box",0b,be,4a,00));
	outFields->push(HX_("text",ad,cc,f9,4c));
	outFields->push(HX_("label",f4,0d,af,6f));
	outFields->push(HX_("checked",27,b3,24,13));
	outFields->push(HX_("broadcastCheckBoxEvent",36,2f,38,25));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo PsychUICheckBox_obj_sMemberStorageInfo[] = {
	{::hx::fsString,(int)offsetof(PsychUICheckBox_obj,name),HX_("name",4b,72,ff,48)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(PsychUICheckBox_obj,box),HX_("box",0b,be,4a,00)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(PsychUICheckBox_obj,text),HX_("text",ad,cc,f9,4c)},
	{::hx::fsBool,(int)offsetof(PsychUICheckBox_obj,checked),HX_("checked",27,b3,24,13)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(PsychUICheckBox_obj,onClick),HX_("onClick",a9,1a,9c,de)},
	{::hx::fsBool,(int)offsetof(PsychUICheckBox_obj,broadcastCheckBoxEvent),HX_("broadcastCheckBoxEvent",36,2f,38,25)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo PsychUICheckBox_obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &PsychUICheckBox_obj::CLICK_EVENT,HX_("CLICK_EVENT",63,89,c0,0d)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String PsychUICheckBox_obj_sMemberFields[] = {
	HX_("name",4b,72,ff,48),
	HX_("box",0b,be,4a,00),
	HX_("text",ad,cc,f9,4c),
	HX_("checked",27,b3,24,13),
	HX_("onClick",a9,1a,9c,de),
	HX_("boxGraphic",dd,6b,2c,24),
	HX_("broadcastCheckBoxEvent",36,2f,38,25),
	HX_("update",09,86,05,87),
	HX_("set_checked",4a,1a,8c,a3),
	HX_("get_label",4b,6a,58,b3),
	HX_("set_label",57,56,a9,96),
	::String(null()) };

static void PsychUICheckBox_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(PsychUICheckBox_obj::CLICK_EVENT,"CLICK_EVENT");
};

#ifdef HXCPP_VISIT_ALLOCS
static void PsychUICheckBox_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(PsychUICheckBox_obj::CLICK_EVENT,"CLICK_EVENT");
};

#endif

::hx::Class PsychUICheckBox_obj::__mClass;

static ::String PsychUICheckBox_obj_sStaticFields[] = {
	HX_("CLICK_EVENT",63,89,c0,0d),
	::String(null())
};

void PsychUICheckBox_obj::__register()
{
	PsychUICheckBox_obj _hx_dummy;
	PsychUICheckBox_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("backend.ui.PsychUICheckBox",72,a3,45,b6);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &PsychUICheckBox_obj::__GetStatic;
	__mClass->mSetStaticField = &PsychUICheckBox_obj::__SetStatic;
	__mClass->mMarkFunc = PsychUICheckBox_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(PsychUICheckBox_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PsychUICheckBox_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PsychUICheckBox_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = PsychUICheckBox_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PsychUICheckBox_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PsychUICheckBox_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void PsychUICheckBox_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_fade0a2b5d62043e_5_boot)
HXDLIN(   5)		CLICK_EVENT = HX_("checkbox_click",0c,2a,83,14);
            	}
}

} // end namespace backend
} // end namespace ui
