// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIEventHandler
#include <backend/ui/PsychUIEventHandler.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIInputText
#include <backend/ui/PsychUIInputText.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextFormat
#include <flixel/text/FlxTextFormat.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_lime_system_Clipboard
#include <lime/system/Clipboard.h>
#endif
#ifndef INCLUDED_openfl_Lib
#include <openfl/Lib.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_MovieClip
#include <openfl/display/MovieClip.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_display_Stage
#include <openfl/display/Stage.h>
#endif
#ifndef INCLUDED_openfl_errors_Error
#include <openfl/errors/Error.h>
#endif
#ifndef INCLUDED_openfl_events_Event
#include <openfl/events/Event.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_KeyboardEvent
#include <openfl/events/KeyboardEvent.h>
#endif
#ifndef INCLUDED_openfl_text_TextField
#include <openfl/text/TextField.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_35_new,"backend.ui.PsychUIInputText","new",0x254e2a9a,"backend.ui.PsychUIInputText.new","backend/ui/PsychUIInputText.hx",35,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_98_onKeyDown,"backend.ui.PsychUIInputText","onKeyDown",0x8808e3fc,"backend.ui.PsychUIInputText.onKeyDown","backend/ui/PsychUIInputText.hx",98,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_379___default_onPressEnter,"backend.ui.PsychUIInputText","__default_onPressEnter",0x8d8dfb38,"backend.ui.PsychUIInputText.__default_onPressEnter","backend/ui/PsychUIInputText.hx",379,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_393_update,"backend.ui.PsychUIInputText","update",0xddd5cc0f,"backend.ui.PsychUIInputText.update","backend/ui/PsychUIInputText.hx",393,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_464_resetCaret,"backend.ui.PsychUIInputText","resetCaret",0xa98ef23a,"backend.ui.PsychUIInputText.resetCaret","backend/ui/PsychUIInputText.hx",464,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_471_updateCaret,"backend.ui.PsychUIInputText","updateCaret",0x7f4e86f4,"backend.ui.PsychUIInputText.updateCaret","backend/ui/PsychUIInputText.hx",471,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_524_deleteSelection,"backend.ui.PsychUIInputText","deleteSelection",0xfe3503db,"backend.ui.PsychUIInputText.deleteSelection","backend/ui/PsychUIInputText.hx",524,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_541_destroy,"backend.ui.PsychUIInputText","destroy",0xc3f32c34,"backend.ui.PsychUIInputText.destroy","backend/ui/PsychUIInputText.hx",541,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_549_set_caretIndex,"backend.ui.PsychUIInputText","set_caretIndex",0x0e9fe352,"backend.ui.PsychUIInputText.set_caretIndex","backend/ui/PsychUIInputText.hx",549,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_556_setGraphicSize,"backend.ui.PsychUIInputText","setGraphicSize",0xc927930d,"backend.ui.PsychUIInputText.setGraphicSize","backend/ui/PsychUIInputText.hx",556,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_569_updateHitbox,"backend.ui.PsychUIInputText","updateHitbox",0x81b52307,"backend.ui.PsychUIInputText.updateHitbox","backend/ui/PsychUIInputText.hx",569,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_581_set_fieldWidth,"backend.ui.PsychUIInputText","set_fieldWidth",0xc9295baf,"backend.ui.PsychUIInputText.set_fieldWidth","backend/ui/PsychUIInputText.hx",581,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_590_set_maxLength,"backend.ui.PsychUIInputText","set_maxLength",0x1a8f8347,"backend.ui.PsychUIInputText.set_maxLength","backend/ui/PsychUIInputText.hx",590,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_600_set_passwordMask,"backend.ui.PsychUIInputText","set_passwordMask",0xe259dd2a,"backend.ui.PsychUIInputText.set_passwordMask","backend/ui/PsychUIInputText.hx",600,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_608_set_text,"backend.ui.PsychUIInputText","set_text",0x5b043530,"backend.ui.PsychUIInputText.set_text","backend/ui/PsychUIInputText.hx",608,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_655__typeLetter,"backend.ui.PsychUIInputText","_typeLetter",0x469fcc99,"backend.ui.PsychUIInputText._typeLetter","backend/ui/PsychUIInputText.hx",655,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_681_set_forceCase,"backend.ui.PsychUIInputText","set_forceCase",0x92fbaad8,"backend.ui.PsychUIInputText.set_forceCase","backend/ui/PsychUIInputText.hx",681,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_688_set_filterMode,"backend.ui.PsychUIInputText","set_filterMode",0x85e987fe,"backend.ui.PsychUIInputText.set_filterMode","backend/ui/PsychUIInputText.hx",688,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_695_set_customFilterPattern,"backend.ui.PsychUIInputText","set_customFilterPattern",0xd3c2a5e4,"backend.ui.PsychUIInputText.set_customFilterPattern","backend/ui/PsychUIInputText.hx",695,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_702_filter,"backend.ui.PsychUIInputText","filter",0xdc0565be,"backend.ui.PsychUIInputText.filter","backend/ui/PsychUIInputText.hx",702,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_383_set_focusOn,"backend.ui.PsychUIInputText","set_focusOn",0x2a80d674,"backend.ui.PsychUIInputText.set_focusOn","backend/ui/PsychUIInputText.hx",383,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_638_getAccentCharCode,"backend.ui.PsychUIInputText","getAccentCharCode",0x7d37c17d,"backend.ui.PsychUIInputText.getAccentCharCode","backend/ui/PsychUIInputText.hx",638,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_224_boot,"backend.ui.PsychUIInputText","boot",0x77301cb8,"backend.ui.PsychUIInputText.boot","backend/ui/PsychUIInputText.hx",224,0x7bff1376)
static const int _hx_array_data_45d295a8_30[] = {
	(int)16,(int)17,(int)27,
};
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_37_boot,"backend.ui.PsychUIInputText","boot",0x77301cb8,"backend.ui.PsychUIInputText.boot","backend/ui/PsychUIInputText.hx",37,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_39_boot,"backend.ui.PsychUIInputText","boot",0x77301cb8,"backend.ui.PsychUIInputText.boot","backend/ui/PsychUIInputText.hx",39,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_40_boot,"backend.ui.PsychUIInputText","boot",0x77301cb8,"backend.ui.PsychUIInputText.boot","backend/ui/PsychUIInputText.hx",40,0x7bff1376)
HX_LOCAL_STACK_FRAME(_hx_pos_efd7f05f5af3fa82_42_boot,"backend.ui.PsychUIInputText","boot",0x77301cb8,"backend.ui.PsychUIInputText.boot","backend/ui/PsychUIInputText.hx",42,0x7bff1376)
namespace backend{
namespace ui{

void PsychUIInputText_obj::__construct(::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y,::hx::Null< int >  __o_wid,::String __o_text,::hx::Null< int >  __o_size){
            		Float x = __o_x.Default(0);
            		Float y = __o_y.Default(0);
            		int wid = __o_wid.Default(100);
            		::String text = __o_text;
            		if (::hx::IsNull(__o_text)) text = HX_("",00,00,00,00);
            		int size = __o_size.Default(8);
            	HX_GC_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_35_new)
HXLINE( 653)		this->broadcastInputTextEvent = true;
HXLINE( 606)		this->_boundaries = ::Array_obj< Float >::__new(0);
HXLINE(  96)		this->inInsertMode = false;
HXLINE(  95)		this->_nextAccent = -1;
HXLINE(  93)		this->_caretTime = ((Float)0);
HXLINE(  92)		this->caretIndex = -1;
HXLINE(  91)		this->selectIndex = -1;
HXLINE(  61)		this->selectedFormat =  ::flixel::text::FlxTextFormat_obj::__alloc( HX_CTX ,-1,null(),null(),null(),null());
HXLINE(  58)		this->filterMode = 0;
HXLINE(  57)		this->forceCase = 0;
HXLINE(  55)		this->text = null();
HXLINE(  54)		this->passwordMask = false;
HXLINE(  53)		this->maxLength = 0;
HXLINE(  52)		this->fieldWidth = 0;
HXLINE(  65)		super::__construct(x,y,null());
HXLINE(  66)		this->bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(1,1,-16777216,null(),null());
HXLINE(  67)		this->behindText =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,1,1,null())->makeGraphic(1,1,-1,null(),null());
HXLINE(  68)		this->selection =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(1,1,-1,null(),null());
HXLINE(  69)		this->textObj =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,1,1,::Math_obj::max(( (Float)(1) ),( (Float)((wid - 2)) )),HX_("",00,00,00,00),size,null());
HXLINE(  70)		this->caret =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(1,1,-1,null(),null());
HXLINE(  71)		this->add(this->bg);
HXLINE(  72)		this->add(this->behindText);
HXLINE(  73)		this->add(this->selection);
HXLINE(  74)		this->add(this->textObj);
HXLINE(  75)		this->add(this->caret);
HXLINE(  77)		this->textObj->set_color(-16777216);
HXLINE(  78)		this->textObj->textField->set_selectable(false);
HXLINE(  79)		this->textObj->textField->set_wordWrap(false);
HXLINE(  80)		this->textObj->textField->set_multiline(false);
HXLINE(  81)		this->selection->set_color(-16776961);
HXLINE(  83)		this->fieldWidth = wid;
HXLINE(  84)		this->setGraphicSize((wid + 2),(this->textObj->get_height() + 2));
HXLINE(  85)		this->updateHitbox();
HXLINE(  86)		this->set_text(text);
HXLINE(  88)		::openfl::Lib_obj::get_current()->stage->addEventListener(HX_("keyDown",a1,69,47,9c),this->onKeyDown_dyn(),null(),null(),null());
            	}

Dynamic PsychUIInputText_obj::__CreateEmpty() { return new PsychUIInputText_obj; }

void *PsychUIInputText_obj::_hx_vtable = 0;

Dynamic PsychUIInputText_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PsychUIInputText_obj > _hx_result = new PsychUIInputText_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3],inArgs[4]);
	return _hx_result;
}

bool PsychUIInputText_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x7ccf8994) {
		if (inClassId<=(int)0x2c01639b) {
			if (inClassId<=(int)0x288ce903) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x288ce903;
			} else {
				return inClassId==(int)0x2c01639b;
			}
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	} else {
		return inClassId==(int)0x7dab0655 || inClassId==(int)0x7fb5dc94;
	}
}

void PsychUIInputText_obj::onKeyDown( ::openfl::events::KeyboardEvent e){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_98_onKeyDown)
HXLINE(  99)		if (::hx::IsInstanceNotEq( ::backend::ui::PsychUIInputText_obj::focusOn,::hx::ObjectPtr<OBJ_>(this) )) {
HXLINE(  99)			return;
            		}
HXLINE( 101)		int keyCode = e->keyCode;
HXLINE( 102)		int charCode = e->charCode;
HXLINE( 103)		int flxKey = keyCode;
HXLINE( 106)		if ((keyCode == 231)) {
HXLINE( 109)			if (e->shiftKey) {
HXLINE( 109)				charCode = 199;
            			}
            			else {
HXLINE( 109)				charCode = 231;
            			}
            		}
HXLINE( 113)		if (e->controlKey) {
HXLINE( 115)			switch((int)(flxKey)){
            				case (int)8: {
HXLINE( 142)					bool _hx_tmp;
HXDLIN( 142)					if ((this->selectIndex >= 0)) {
HXLINE( 142)						_hx_tmp = (this->selectIndex == this->caretIndex);
            					}
            					else {
HXLINE( 142)						_hx_tmp = true;
            					}
HXDLIN( 142)					if (_hx_tmp) {
HXLINE( 144)						::String lastText = this->text;
HXLINE( 145)						::String deletedText = this->text;
HXDLIN( 145)						::String deletedText1 = deletedText.substr(0,::Std_obj::_hx_int(::Math_obj::max(( (Float)(0) ),( (Float)((this->caretIndex - 1)) ))));
HXLINE( 146)						int space = deletedText1.lastIndexOf(HX_(" ",20,00,00,00),null());
HXLINE( 147)						bool _hx_tmp1;
HXDLIN( 147)						if ((space > -1)) {
HXLINE( 147)							_hx_tmp1 = (space != (this->caretIndex - 1));
            						}
            						else {
HXLINE( 147)							_hx_tmp1 = false;
            						}
HXDLIN( 147)						if (_hx_tmp1) {
HXLINE( 149)							::String start = deletedText1.substring(0,(space + 1));
HXLINE( 150)							::String end = this->text.substring(this->caretIndex,null());
HXLINE( 151)							int _hx_tmp2 = this->caretIndex;
HXDLIN( 151)							this->set_caretIndex((_hx_tmp2 - ::Std_obj::_hx_int(::Math_obj::max(( (Float)(0) ),( (Float)((this->text.length - (start.length + end.length))) )))));
HXLINE( 152)							this->set_text((start + end));
            						}
            						else {
HXLINE( 156)							this->set_text(this->text.substring(this->caretIndex,null()));
HXLINE( 157)							this->set_caretIndex(0);
            						}
HXLINE( 159)						this->selectIndex = -1;
HXLINE( 160)						if (::hx::IsNotNull( this->onChange )) {
HXLINE( 160)							this->onChange(lastText,this->text);
            						}
HXLINE( 161)						if (this->broadcastInputTextEvent) {
HXLINE( 161)							::backend::ui::PsychUIEventHandler_obj::event(::backend::ui::PsychUIInputText_obj::CHANGE_EVENT,::hx::ObjectPtr<OBJ_>(this));
            						}
            					}
            					else {
HXLINE( 163)						this->deleteSelection();
            					}
            				}
            				break;
            				case (int)37: {
HXLINE( 191)					if ((this->caretIndex > 0)) {
HXLINE( 193)						do {
HXLINE( 195)							this->set_caretIndex((this->caretIndex - 1));
HXLINE( 196)							::String a = this->text.substr((this->caretIndex - 1),1);
HXLINE( 197)							::String b = this->text.substr(this->caretIndex,1);
HXLINE( 199)							bool _hx_tmp3;
HXDLIN( 199)							if ((a == HX_(" ",20,00,00,00))) {
HXLINE( 199)								_hx_tmp3 = (b != HX_(" ",20,00,00,00));
            							}
            							else {
HXLINE( 199)								_hx_tmp3 = false;
            							}
HXDLIN( 199)							if (_hx_tmp3) {
HXLINE( 199)								goto _hx_goto_1;
            							}
            						} while((this->caretIndex > 0));
            						_hx_goto_1:;
            					}
            				}
            				break;
            				case (int)39: {
HXLINE( 205)					if ((this->caretIndex < this->text.length)) {
HXLINE( 207)						do {
HXLINE( 209)							this->set_caretIndex((this->caretIndex + 1));
HXLINE( 210)							::String a1 = this->text.substr((this->caretIndex - 1),1);
HXLINE( 211)							::String b1 = this->text.substr(this->caretIndex,1);
HXLINE( 213)							bool _hx_tmp4;
HXDLIN( 213)							if ((a1 != HX_(" ",20,00,00,00))) {
HXLINE( 213)								_hx_tmp4 = (b1 == HX_(" ",20,00,00,00));
            							}
            							else {
HXLINE( 213)								_hx_tmp4 = false;
            							}
HXDLIN( 213)							if (_hx_tmp4) {
HXLINE( 213)								goto _hx_goto_2;
            							}
            						} while((this->caretIndex < this->text.length));
            						_hx_goto_2:;
            					}
            				}
            				break;
            				case (int)46: {
HXLINE( 166)					bool _hx_tmp5;
HXDLIN( 166)					if ((this->selectIndex >= 0)) {
HXLINE( 166)						_hx_tmp5 = (this->selectIndex == this->caretIndex);
            					}
            					else {
HXLINE( 166)						_hx_tmp5 = true;
            					}
HXDLIN( 166)					if (_hx_tmp5) {
HXLINE( 170)						::String deletedText2 = this->text.substring(this->caretIndex,null());
HXLINE( 171)						int spc = 0;
HXLINE( 172)						int space1 = deletedText2.indexOf(HX_(" ",20,00,00,00),null());
HXLINE( 173)						while((deletedText2.substr(spc,1) == HX_(" ",20,00,00,00))){
HXLINE( 175)							spc = (spc + 1);
HXLINE( 176)							space1 = deletedText2.substr(spc,null()).indexOf(HX_(" ",20,00,00,00),null());
            						}
HXLINE( 179)						::String lastText1 = this->text;
HXLINE( 180)						if ((space1 > -1)) {
HXLINE( 182)							::String _hx_tmp6 = this->text.substr(0,this->caretIndex);
HXDLIN( 182)							this->set_text((_hx_tmp6 + this->text.substring(((this->caretIndex + space1) + spc),null())));
            						}
            						else {
HXLINE( 184)							this->set_text(this->text.substr(0,this->caretIndex));
            						}
HXLINE( 185)						if (::hx::IsNotNull( this->onChange )) {
HXLINE( 185)							this->onChange(lastText1,this->text);
            						}
HXLINE( 186)						if (this->broadcastInputTextEvent) {
HXLINE( 186)							::backend::ui::PsychUIEventHandler_obj::event(::backend::ui::PsychUIInputText_obj::CHANGE_EVENT,::hx::ObjectPtr<OBJ_>(this));
            						}
            					}
            					else {
HXLINE( 188)						this->deleteSelection();
            					}
            				}
            				break;
            				case (int)65: {
HXLINE( 118)					this->selectIndex = ::Std_obj::_hx_int(::Math_obj::min(( (Float)(0) ),( (Float)((this->text.length - 1)) )));
HXLINE( 119)					this->set_caretIndex(this->text.length);
            				}
            				break;
            				case (int)67: case (int)88: {
HXLINE( 122)					bool _hx_tmp7;
HXDLIN( 122)					bool _hx_tmp8;
HXDLIN( 122)					if ((this->caretIndex >= 0)) {
HXLINE( 122)						_hx_tmp8 = (this->selectIndex != 0);
            					}
            					else {
HXLINE( 122)						_hx_tmp8 = false;
            					}
HXDLIN( 122)					if (_hx_tmp8) {
HXLINE( 122)						_hx_tmp7 = (this->caretIndex != this->selectIndex);
            					}
            					else {
HXLINE( 122)						_hx_tmp7 = false;
            					}
HXDLIN( 122)					if (_hx_tmp7) {
HXLINE( 124)						::lime::_hx_system::Clipboard_obj::set_text(this->text.substring(this->caretIndex,this->selectIndex));
HXLINE( 125)						if ((flxKey == 88)) {
HXLINE( 126)							this->deleteSelection();
            						}
            					}
            				}
            				break;
            				case (int)86: {
HXLINE( 130)					if (::hx::IsNull( ::lime::_hx_system::Clipboard_obj::get_text() )) {
HXLINE( 130)						return;
            					}
HXLINE( 132)					bool _hx_tmp9;
HXDLIN( 132)					if ((this->selectIndex > -1)) {
HXLINE( 132)						_hx_tmp9 = (this->selectIndex != this->caretIndex);
            					}
            					else {
HXLINE( 132)						_hx_tmp9 = false;
            					}
HXDLIN( 132)					if (_hx_tmp9) {
HXLINE( 133)						this->deleteSelection();
            					}
HXLINE( 135)					::String lastText2 = this->text;
HXLINE( 136)					::String _hx_tmp10 = this->text.substring(0,this->caretIndex);
HXDLIN( 136)					::String _hx_tmp11 = (_hx_tmp10 + ::lime::_hx_system::Clipboard_obj::get_text());
HXDLIN( 136)					this->set_text((_hx_tmp11 + this->text.substring(this->caretIndex,null())));
HXLINE( 137)					int _hx_tmp12 = this->caretIndex;
HXDLIN( 137)					this->set_caretIndex((_hx_tmp12 + ::lime::_hx_system::Clipboard_obj::get_text().length));
HXLINE( 138)					if (::hx::IsNotNull( this->onChange )) {
HXLINE( 138)						this->onChange(lastText2,this->text);
            					}
HXLINE( 139)					if (this->broadcastInputTextEvent) {
HXLINE( 139)						::backend::ui::PsychUIEventHandler_obj::event(::backend::ui::PsychUIInputText_obj::CHANGE_EVENT,::hx::ObjectPtr<OBJ_>(this));
            					}
            				}
            				break;
            				default:{
            				}
            			}
HXLINE( 220)			this->updateCaret();
HXLINE( 221)			return;
            		}
HXLINE( 225)		if (::backend::ui::PsychUIInputText_obj::onKeyDown_ignored->contains(flxKey)) {
HXLINE( 225)			return;
            		}
HXLINE( 227)		int lastAccent = this->_nextAccent;
HXLINE( 228)		int _hx_switch_0 = keyCode;
            		if (  (_hx_switch_0==::backend::ui::PsychUIInputText_obj::KEY_ACUTE) ){
HXLINE( 234)			int _hx_tmp13;
HXDLIN( 234)			if (!(e->shiftKey)) {
HXLINE( 234)				_hx_tmp13 = 1;
            			}
            			else {
HXLINE( 234)				_hx_tmp13 = 0;
            			}
HXDLIN( 234)			this->_nextAccent = _hx_tmp13;
HXLINE( 235)			if ((lastAccent == -1)) {
HXLINE( 235)				return;
            			}
HXLINE( 233)			goto _hx_goto_4;
            		}
            		if (  (_hx_switch_0==::backend::ui::PsychUIInputText_obj::KEY_TILDE) ){
HXLINE( 231)			int _hx_tmp14;
HXDLIN( 231)			if (!(e->shiftKey)) {
HXLINE( 231)				_hx_tmp14 = 3;
            			}
            			else {
HXLINE( 231)				_hx_tmp14 = 2;
            			}
HXDLIN( 231)			this->_nextAccent = _hx_tmp14;
HXLINE( 232)			if ((lastAccent == -1)) {
HXLINE( 232)				return;
            			}
HXLINE( 230)			goto _hx_goto_4;
            		}
            		/* default */{
HXLINE( 237)			lastAccent = -1;
            		}
            		_hx_goto_4:;
HXLINE( 241)		switch((int)(flxKey)){
            			case (int)8: {
HXLINE( 267)				if ((this->caretIndex <= 0)) {
HXLINE( 267)					return;
            				}
HXLINE( 269)				bool _hx_tmp15;
HXDLIN( 269)				if ((this->selectIndex > -1)) {
HXLINE( 269)					_hx_tmp15 = (this->selectIndex != this->caretIndex);
            				}
            				else {
HXLINE( 269)					_hx_tmp15 = false;
            				}
HXDLIN( 269)				if (_hx_tmp15) {
HXLINE( 270)					this->deleteSelection();
            				}
            				else {
HXLINE( 273)					::String lastText3 = this->text;
HXLINE( 274)					::String _hx_tmp16 = this->text.substring(0,(this->caretIndex - 1));
HXDLIN( 274)					this->set_text((_hx_tmp16 + this->text.substring(this->caretIndex,null())));
HXLINE( 275)					this->set_caretIndex((this->caretIndex - 1));
HXLINE( 276)					if (::hx::IsNotNull( this->onChange )) {
HXLINE( 276)						this->onChange(lastText3,this->text);
            					}
HXLINE( 277)					if (this->broadcastInputTextEvent) {
HXLINE( 277)						::backend::ui::PsychUIEventHandler_obj::event(::backend::ui::PsychUIInputText_obj::CHANGE_EVENT,::hx::ObjectPtr<OBJ_>(this));
            					}
            				}
HXLINE( 279)				this->_nextAccent = -1;
            			}
            			break;
            			case (int)13: {
HXLINE( 363)				this->onPressEnter(e);
            			}
            			break;
            			case (int)27: {
HXLINE( 360)				::backend::ui::PsychUIInputText_obj::set_focusOn(null());
            			}
            			break;
            			case (int)32: {
HXLINE( 303)				if ((this->_nextAccent != -1)) {
HXLINE( 303)					this->_typeLetter(::backend::ui::PsychUIInputText_obj::getAccentCharCode(this->_nextAccent));
            				}
            				else {
HXLINE( 304)					this->_typeLetter(charCode);
            				}
HXLINE( 305)				this->_nextAccent = -1;
            			}
            			break;
            			case (int)35: {
HXLINE( 259)				 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 259)				if (!(_this->keyManager->checkStatusUnsafe(16,_this->status))) {
HXLINE( 259)					this->selectIndex = -1;
            				}
            				else {
HXLINE( 260)					if ((this->selectIndex == -1)) {
HXLINE( 260)						this->selectIndex = this->caretIndex;
            					}
            				}
HXLINE( 261)				this->set_caretIndex(this->text.length);
            			}
            			break;
            			case (int)36: {
HXLINE( 254)				 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 254)				if (!(_this1->keyManager->checkStatusUnsafe(16,_this1->status))) {
HXLINE( 254)					this->selectIndex = -1;
            				}
            				else {
HXLINE( 255)					if ((this->selectIndex == -1)) {
HXLINE( 255)						this->selectIndex = this->caretIndex;
            					}
            				}
HXLINE( 256)				this->set_caretIndex(0);
            			}
            			break;
            			case (int)37: {
HXLINE( 244)				 ::flixel::input::keyboard::FlxKeyList _this2 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 244)				if (!(_this2->keyManager->checkStatusUnsafe(16,_this2->status))) {
HXLINE( 244)					this->selectIndex = -1;
            				}
            				else {
HXLINE( 245)					if ((this->selectIndex == -1)) {
HXLINE( 245)						this->selectIndex = this->caretIndex;
            					}
            				}
HXLINE( 246)				this->set_caretIndex(::Std_obj::_hx_int(::Math_obj::max(( (Float)(0) ),( (Float)((this->caretIndex - 1)) ))));
            			}
            			break;
            			case (int)39: {
HXLINE( 249)				 ::flixel::input::keyboard::FlxKeyList _this3 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 249)				if (!(_this3->keyManager->checkStatusUnsafe(16,_this3->status))) {
HXLINE( 249)					this->selectIndex = -1;
            				}
            				else {
HXLINE( 250)					if ((this->selectIndex == -1)) {
HXLINE( 250)						this->selectIndex = this->caretIndex;
            					}
            				}
HXLINE( 251)				this->set_caretIndex(::Std_obj::_hx_int(::Math_obj::min(( (Float)(this->text.length) ),( (Float)((this->caretIndex + 1)) ))));
            			}
            			break;
            			case (int)45: {
HXLINE( 264)				this->inInsertMode = !(this->inInsertMode);
            			}
            			break;
            			case (int)46: {
HXLINE( 282)				bool _hx_tmp17;
HXDLIN( 282)				if ((this->selectIndex > -1)) {
HXLINE( 282)					_hx_tmp17 = (this->selectIndex != this->caretIndex);
            				}
            				else {
HXLINE( 282)					_hx_tmp17 = false;
            				}
HXDLIN( 282)				if (_hx_tmp17) {
HXLINE( 284)					this->deleteSelection();
HXLINE( 285)					this->updateCaret();
HXLINE( 286)					return;
            				}
HXLINE( 289)				if ((this->caretIndex >= this->text.length)) {
HXLINE( 289)					return;
            				}
HXLINE( 291)				::String lastText4 = this->text;
HXLINE( 292)				if ((this->caretIndex < 1)) {
HXLINE( 293)					this->set_text(this->text.substr(1,null()));
            				}
            				else {
HXLINE( 295)					::String _hx_tmp18 = this->text.substring(0,this->caretIndex);
HXDLIN( 295)					this->set_text((_hx_tmp18 + this->text.substring((this->caretIndex + 1),null())));
            				}
HXLINE( 297)				if ((this->caretIndex >= this->text.length)) {
HXLINE( 297)					this->set_caretIndex(this->text.length);
            				}
HXLINE( 299)				if (::hx::IsNotNull( this->onChange )) {
HXLINE( 299)					this->onChange(lastText4,this->text);
            				}
HXLINE( 300)				if (this->broadcastInputTextEvent) {
HXLINE( 300)					::backend::ui::PsychUIEventHandler_obj::event(::backend::ui::PsychUIInputText_obj::CHANGE_EVENT,::hx::ObjectPtr<OBJ_>(this));
            				}
            			}
            			break;
            			case (int)78: {
HXLINE( 351)				if ((this->_nextAccent == 3)) {
HXLINE( 352)					charCode = (charCode + 131);
            				}
            				else {
HXLINE( 354)					this->_typeLetter(::backend::ui::PsychUIInputText_obj::getAccentCharCode(this->_nextAccent));
            				}
HXLINE( 356)				this->_typeLetter(charCode);
HXLINE( 357)				this->_nextAccent = -1;
            			}
            			break;
            			case (int)65: case (int)79: {
HXLINE( 308)				int grave = 0;
HXLINE( 309)				int capital = 0;
HXLINE( 310)				switch((int)(flxKey)){
            					case (int)65: {
HXLINE( 313)						grave = 192;
HXLINE( 314)						capital = 65;
            					}
            					break;
            					case (int)79: {
HXLINE( 316)						grave = 210;
HXLINE( 317)						capital = 79;
            					}
            					break;
            					default:{
            					}
            				}
HXLINE( 320)				if ((this->_nextAccent != -1)) {
HXLINE( 321)					charCode = (charCode + ((grave - capital) + this->_nextAccent));
            				}
HXLINE( 323)				this->_typeLetter(charCode);
HXLINE( 324)				this->_nextAccent = -1;
            			}
            			break;
            			case (int)69: case (int)73: case (int)85: {
HXLINE( 327)				int grave1 = 0;
HXLINE( 328)				int capital1 = 0;
HXLINE( 329)				switch((int)(flxKey)){
            					case (int)69: {
HXLINE( 332)						grave1 = 200;
HXLINE( 333)						capital1 = 69;
            					}
            					break;
            					case (int)73: {
HXLINE( 335)						grave1 = 204;
HXLINE( 336)						capital1 = 73;
            					}
            					break;
            					case (int)85: {
HXLINE( 338)						grave1 = 217;
HXLINE( 339)						capital1 = 85;
            					}
            					break;
            					default:{
            					}
            				}
HXLINE( 342)				bool _hx_tmp19;
HXDLIN( 342)				bool _hx_tmp20;
HXDLIN( 342)				if ((this->_nextAccent != 0)) {
HXLINE( 342)					_hx_tmp20 = (this->_nextAccent == 1);
            				}
            				else {
HXLINE( 342)					_hx_tmp20 = true;
            				}
HXDLIN( 342)				if (!(_hx_tmp20)) {
HXLINE( 342)					_hx_tmp19 = (this->_nextAccent == 2);
            				}
            				else {
HXLINE( 342)					_hx_tmp19 = true;
            				}
HXDLIN( 342)				if (_hx_tmp19) {
HXLINE( 343)					charCode = (charCode + ((grave1 - capital1) + this->_nextAccent));
            				}
            				else {
HXLINE( 344)					if ((this->_nextAccent == 3)) {
HXLINE( 345)						this->_typeLetter(::backend::ui::PsychUIInputText_obj::getAccentCharCode(this->_nextAccent));
            					}
            				}
HXLINE( 347)				this->_typeLetter(charCode);
HXLINE( 348)				this->_nextAccent = -1;
            			}
            			break;
            			default:{
HXLINE( 366)				if ((charCode < 1)) {
HXLINE( 367)					charCode = ::backend::ui::PsychUIInputText_obj::getAccentCharCode(this->_nextAccent);
HXDLIN( 367)					if ((charCode < 1)) {
HXLINE( 368)						return;
            					}
            				}
HXLINE( 370)				if ((lastAccent != -1)) {
HXLINE( 370)					this->_typeLetter(::backend::ui::PsychUIInputText_obj::getAccentCharCode(lastAccent));
            				}
            				else {
HXLINE( 371)					if ((this->_nextAccent != -1)) {
HXLINE( 371)						this->_typeLetter(::backend::ui::PsychUIInputText_obj::getAccentCharCode(this->_nextAccent));
            					}
            				}
HXLINE( 372)				this->_typeLetter(charCode);
HXLINE( 373)				this->_nextAccent = -1;
            			}
            		}
HXLINE( 375)		this->updateCaret();
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,onKeyDown,(void))

HX_BEGIN_DEFAULT_FUNC(__default_onPressEnter,PsychUIInputText_obj)
void _hx_run( ::openfl::events::KeyboardEvent e){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_379___default_onPressEnter)
HXDLIN( 379)		::backend::ui::PsychUIInputText_obj::set_focusOn(null());
            	}
HX_END_LOCAL_FUNC1((void))
HX_END_DEFAULT_FUNC

void PsychUIInputText_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_393_update)
HXLINE( 394)		this->super::update(elapsed);
HXLINE( 396)		if ((::flixel::FlxG_obj::mouse->_leftButton->current == 2)) {
HXLINE( 398)			 ::flixel::input::mouse::FlxMouse _hx_tmp = ::flixel::FlxG_obj::mouse;
HXDLIN( 398)			 ::flixel::FlxSprite _hx_tmp1 = this->behindText;
HXDLIN( 398)			if (_hx_tmp->overlaps(_hx_tmp1,this->get_camera())) {
HXLINE( 400)				 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 400)				if (!(_this->keyManager->checkStatusUnsafe(16,_this->status))) {
HXLINE( 400)					this->selectIndex = -1;
            				}
            				else {
HXLINE( 401)					if ((this->selectIndex == -1)) {
HXLINE( 401)						this->selectIndex = this->caretIndex;
            					}
            				}
HXLINE( 402)				::backend::ui::PsychUIInputText_obj::set_focusOn(::hx::ObjectPtr<OBJ_>(this));
HXLINE( 403)				this->set_caretIndex(0);
HXLINE( 404)				Float lastBound = ( (Float)(0) );
HXLINE( 405)				 ::flixel::text::FlxText this1 = this->textObj;
HXDLIN( 405)				Float textObjX = this1->getScreenPosition(null(),this->get_camera())->x;
HXLINE( 406)				 ::flixel::input::mouse::FlxMouse this2 = ::flixel::FlxG_obj::mouse;
HXDLIN( 406)				Float mousePosX = this2->getScreenPosition(this->get_camera(),null())->x;
HXLINE( 407)				Float txtX = (textObjX - ( (Float)(this->textObj->textField->get_scrollH()) ));
HXLINE( 409)				{
HXLINE( 409)					int _g_current = 0;
HXDLIN( 409)					::Array< Float > _g_array = this->_boundaries;
HXDLIN( 409)					while((_g_current < _g_array->length)){
HXLINE( 409)						Float _g_value = _g_array->__get(_g_current);
HXDLIN( 409)						_g_current = (_g_current + 1);
HXDLIN( 409)						int _g_key = (_g_current - 1);
HXDLIN( 409)						int i = _g_key;
HXDLIN( 409)						Float bound = _g_value;
HXLINE( 411)						if ((mousePosX >= (txtX + ((bound - lastBound) / ( (Float)(2) ))))) {
HXLINE( 413)							this->set_caretIndex((i + 1));
HXLINE( 414)							txtX = (txtX + (bound - lastBound));
HXLINE( 415)							lastBound = bound;
            						}
            						else {
HXLINE( 417)							goto _hx_goto_7;
            						}
            					}
            					_hx_goto_7:;
            				}
HXLINE( 419)				this->updateCaret();
            			}
            			else {
HXLINE( 421)				if (::hx::IsInstanceEq( ::backend::ui::PsychUIInputText_obj::focusOn,::hx::ObjectPtr<OBJ_>(this) )) {
HXLINE( 422)					::backend::ui::PsychUIInputText_obj::set_focusOn(null());
            				}
            			}
            		}
HXLINE( 427)		if (::hx::IsInstanceEq( ::backend::ui::PsychUIInputText_obj::focusOn,::hx::ObjectPtr<OBJ_>(this) )) {
HXLINE( 429)			this->_caretTime = ::hx::Mod((this->_caretTime + elapsed),1);
HXLINE( 430)			bool _hx_tmp2;
HXDLIN( 430)			if (::hx::IsNotNull( this->textObj )) {
HXLINE( 430)				_hx_tmp2 = this->textObj->exists;
            			}
            			else {
HXLINE( 430)				_hx_tmp2 = false;
            			}
HXDLIN( 430)			if (_hx_tmp2) {
HXLINE( 432)				bool drewSelection = false;
HXLINE( 433)				bool _hx_tmp3;
HXDLIN( 433)				if (::hx::IsNotNull( this->selection )) {
HXLINE( 433)					_hx_tmp3 = this->selection->exists;
            				}
            				else {
HXLINE( 433)					_hx_tmp3 = false;
            				}
HXDLIN( 433)				if (_hx_tmp3) {
HXLINE( 435)					bool _hx_tmp4;
HXDLIN( 435)					if ((this->selectIndex != -1)) {
HXLINE( 435)						_hx_tmp4 = (this->selectIndex != this->caretIndex);
            					}
            					else {
HXLINE( 435)						_hx_tmp4 = false;
            					}
HXDLIN( 435)					if (_hx_tmp4) {
HXLINE( 437)						this->selection->set_visible(true);
HXLINE( 438)						drewSelection = true;
            					}
            					else {
HXLINE( 440)						this->selection->set_visible(false);
            					}
            				}
HXLINE( 443)				bool _hx_tmp5;
HXDLIN( 443)				if (::hx::IsNotNull( this->caret )) {
HXLINE( 443)					_hx_tmp5 = this->caret->exists;
            				}
            				else {
HXLINE( 443)					_hx_tmp5 = false;
            				}
HXDLIN( 443)				if (_hx_tmp5) {
HXLINE( 445)					bool _hx_tmp6;
HXDLIN( 445)					bool _hx_tmp7;
HXDLIN( 445)					if (!(drewSelection)) {
HXLINE( 445)						_hx_tmp7 = (this->_caretTime < ((Float)0.5));
            					}
            					else {
HXLINE( 445)						_hx_tmp7 = false;
            					}
HXDLIN( 445)					if (_hx_tmp7) {
HXLINE( 445)						_hx_tmp6 = (this->caret->x >= this->textObj->x);
            					}
            					else {
HXLINE( 445)						_hx_tmp6 = false;
            					}
HXDLIN( 445)					if (_hx_tmp6) {
HXLINE( 447)						this->caret->set_visible(true);
HXLINE( 448)						this->caret->set_color(this->textObj->color);
            					}
            					else {
HXLINE( 450)						this->caret->set_visible(false);
            					}
            				}
            			}
            		}
            		else {
HXLINE( 456)			this->_caretTime = ( (Float)(0) );
HXLINE( 457)			this->inInsertMode = false;
HXLINE( 458)			bool _hx_tmp8;
HXDLIN( 458)			if (::hx::IsNotNull( this->selection )) {
HXLINE( 458)				_hx_tmp8 = this->selection->exists;
            			}
            			else {
HXLINE( 458)				_hx_tmp8 = false;
            			}
HXDLIN( 458)			if (_hx_tmp8) {
HXLINE( 458)				this->selection->set_visible(false);
            			}
HXLINE( 459)			bool _hx_tmp9;
HXDLIN( 459)			if (::hx::IsNotNull( this->caret )) {
HXLINE( 459)				_hx_tmp9 = this->caret->exists;
            			}
            			else {
HXLINE( 459)				_hx_tmp9 = false;
            			}
HXDLIN( 459)			if (_hx_tmp9) {
HXLINE( 459)				this->caret->set_visible(false);
            			}
            		}
            	}


void PsychUIInputText_obj::resetCaret(){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_464_resetCaret)
HXLINE( 465)		this->selectIndex = -1;
HXLINE( 466)		this->set_caretIndex(0);
HXLINE( 467)		this->updateCaret();
            	}


HX_DEFINE_DYNAMIC_FUNC0(PsychUIInputText_obj,resetCaret,(void))

void PsychUIInputText_obj::updateCaret(){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_471_updateCaret)
HXLINE( 472)		bool _hx_tmp;
HXDLIN( 472)		if (::hx::IsNotNull( this->textObj )) {
HXLINE( 472)			_hx_tmp = !(this->textObj->exists);
            		}
            		else {
HXLINE( 472)			_hx_tmp = true;
            		}
HXDLIN( 472)		if (_hx_tmp) {
HXLINE( 472)			return;
            		}
HXLINE( 474)		 ::openfl::text::TextField textField = this->textObj->textField;
HXLINE( 475)		textField->setSelection(this->caretIndex,this->caretIndex);
HXLINE( 476)		this->_caretTime = ( (Float)(0) );
HXLINE( 477)		bool _hx_tmp1;
HXDLIN( 477)		if (::hx::IsNotNull( this->caret )) {
HXLINE( 477)			_hx_tmp1 = this->caret->exists;
            		}
            		else {
HXLINE( 477)			_hx_tmp1 = false;
            		}
HXDLIN( 477)		if (_hx_tmp1) {
HXLINE( 479)			this->caret->set_y((this->textObj->y + 2));
HXLINE( 480)			 ::flixel::FlxSprite _hx_tmp2 = this->caret;
HXDLIN( 480)			Float _hx_tmp3 = (this->textObj->x + 1);
HXDLIN( 480)			_hx_tmp2->set_x((_hx_tmp3 - ( (Float)(this->textObj->textField->get_scrollH()) )));
HXLINE( 481)			if ((this->caretIndex > 0)) {
HXLINE( 482)				 ::flixel::FlxSprite fh = this->caret;
HXDLIN( 482)				Float fh1 = fh->x;
HXDLIN( 482)				fh->set_x((fh1 + this->_boundaries->__get(::Std_obj::_hx_int(::Math_obj::max(( (Float)(0) ),::Math_obj::min(( (Float)((this->_boundaries->length - 1)) ),( (Float)((this->caretIndex - 1)) )))))));
            			}
            		}
HXLINE( 485)		bool _hx_tmp4;
HXDLIN( 485)		if (::hx::IsNotNull( this->selection )) {
HXLINE( 485)			_hx_tmp4 = this->selection->exists;
            		}
            		else {
HXLINE( 485)			_hx_tmp4 = false;
            		}
HXDLIN( 485)		if (_hx_tmp4) {
HXLINE( 487)			this->selection->set_y((this->textObj->y + 2));
HXLINE( 488)			 ::flixel::FlxSprite _hx_tmp5 = this->selection;
HXDLIN( 488)			Float _hx_tmp6 = (this->textObj->x + 1);
HXDLIN( 488)			_hx_tmp5->set_x((_hx_tmp6 - ( (Float)(this->textObj->textField->get_scrollH()) )));
HXLINE( 489)			if ((this->selectIndex > 0)) {
HXLINE( 490)				 ::flixel::FlxSprite fh2 = this->selection;
HXDLIN( 490)				Float fh3 = fh2->x;
HXDLIN( 490)				fh2->set_x((fh3 + this->_boundaries->__get(::Std_obj::_hx_int(::Math_obj::max(( (Float)(0) ),::Math_obj::min(( (Float)((this->_boundaries->length - 1)) ),( (Float)((this->selectIndex - 1)) )))))));
            			}
HXLINE( 492)			{
HXLINE( 492)				 ::flixel::math::FlxBasePoint this1 = this->selection->scale;
HXDLIN( 492)				this1->set_y(textField->get_textHeight());
            			}
HXLINE( 493)			this->selection->scale->set_x((this->caret->x - this->selection->x));
HXLINE( 494)			if ((this->selection->scale->x < 0)) {
HXLINE( 496)				this->selection->scale->set_x(::Math_obj::abs(this->selection->scale->x));
HXLINE( 497)				 ::flixel::FlxSprite fh4 = this->selection;
HXDLIN( 497)				fh4->set_x((fh4->x - this->selection->scale->x));
            			}
HXLINE( 500)			if ((this->selection->x < this->textObj->x)) {
HXLINE( 502)				Float diff = (this->textObj->x - this->selection->x);
HXLINE( 503)				 ::flixel::FlxSprite fh5 = this->selection;
HXDLIN( 503)				fh5->set_x((fh5->x + diff));
HXLINE( 504)				 ::flixel::FlxSprite fh6 = this->selection;
HXDLIN( 504)				fh6->scale->set_x((fh6->scale->x - diff));
            			}
HXLINE( 506)			Float _hx_tmp7 = (this->selection->x + this->selection->scale->x);
HXDLIN( 506)			Float _hx_tmp8 = this->textObj->x;
HXDLIN( 506)			if ((_hx_tmp7 > (_hx_tmp8 + this->textObj->get_width()))) {
HXLINE( 507)				 ::flixel::FlxSprite fh7 = this->selection;
HXDLIN( 507)				{
HXLINE( 507)					 ::flixel::math::FlxBasePoint this2 = fh7->scale;
HXDLIN( 507)					Float fh8 = fh7->scale->x;
HXDLIN( 507)					Float x = this->textObj->x;
HXDLIN( 507)					Float x1 = (x + this->textObj->get_width());
HXDLIN( 507)					this2->set_x((fh8 + ((x1 - this->selection->x) - this->selection->scale->x)));
            				}
            			}
HXLINE( 509)			this->selection->updateHitbox();
HXLINE( 511)			if ((this->text.length > 0)) {
HXLINE( 513)				this->textObj->removeFormat(this->selectedFormat,null(),null());
HXLINE( 514)				bool _hx_tmp9;
HXDLIN( 514)				if ((this->selectIndex != -1)) {
HXLINE( 514)					_hx_tmp9 = (this->selectIndex != this->caretIndex);
            				}
            				else {
HXLINE( 514)					_hx_tmp9 = false;
            				}
HXDLIN( 514)				if (_hx_tmp9) {
HXLINE( 516)					int _hx_tmp10;
HXDLIN( 516)					if ((this->caretIndex < this->selectIndex)) {
HXLINE( 516)						_hx_tmp10 = this->caretIndex;
            					}
            					else {
HXLINE( 516)						_hx_tmp10 = this->selectIndex;
            					}
HXDLIN( 516)					int _hx_tmp11;
HXDLIN( 516)					if ((this->caretIndex < this->selectIndex)) {
HXLINE( 516)						_hx_tmp11 = this->selectIndex;
            					}
            					else {
HXLINE( 516)						_hx_tmp11 = this->caretIndex;
            					}
HXDLIN( 516)					this->textObj->addFormat(this->selectedFormat,_hx_tmp10,_hx_tmp11);
            				}
            			}
            		}
            		else {
HXLINE( 520)			if ((this->text.length > 0)) {
HXLINE( 520)				this->textObj->removeFormat(this->selectedFormat,null(),null());
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(PsychUIInputText_obj,updateCaret,(void))

void PsychUIInputText_obj::deleteSelection(){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_524_deleteSelection)
HXLINE( 525)		::String lastText = this->text;
HXLINE( 526)		if ((this->selectIndex > this->caretIndex)) {
HXLINE( 528)			::String _hx_tmp = this->text.substring(0,this->caretIndex);
HXDLIN( 528)			this->set_text((_hx_tmp + this->text.substring(this->selectIndex,null())));
            		}
            		else {
HXLINE( 532)			::String _hx_tmp1 = this->text.substring(0,this->selectIndex);
HXDLIN( 532)			this->set_text((_hx_tmp1 + this->text.substring(this->caretIndex,null())));
HXLINE( 533)			this->set_caretIndex(this->selectIndex);
            		}
HXLINE( 535)		this->selectIndex = -1;
HXLINE( 536)		if (::hx::IsNotNull( this->onChange )) {
HXLINE( 536)			this->onChange(lastText,this->text);
            		}
HXLINE( 537)		if (this->broadcastInputTextEvent) {
HXLINE( 537)			::backend::ui::PsychUIEventHandler_obj::event(::backend::ui::PsychUIInputText_obj::CHANGE_EVENT,::hx::ObjectPtr<OBJ_>(this));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(PsychUIInputText_obj,deleteSelection,(void))

void PsychUIInputText_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_541_destroy)
HXLINE( 542)		this->_boundaries = null();
HXLINE( 543)		if (::hx::IsInstanceEq( ::backend::ui::PsychUIInputText_obj::focusOn,::hx::ObjectPtr<OBJ_>(this) )) {
HXLINE( 543)			::backend::ui::PsychUIInputText_obj::set_focusOn(null());
            		}
HXLINE( 544)		::openfl::Lib_obj::get_current()->stage->removeEventListener(HX_("keyDown",a1,69,47,9c),this->onKeyDown_dyn(),null());
HXLINE( 545)		this->super::destroy();
            	}


int PsychUIInputText_obj::set_caretIndex(int v){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_549_set_caretIndex)
HXLINE( 550)		this->caretIndex = v;
HXLINE( 551)		this->updateCaret();
HXLINE( 552)		return v;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,set_caretIndex,return )

void PsychUIInputText_obj::setGraphicSize(::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height){
            		Float width = __o_width.Default(0);
            		Float height = __o_height.Default(0);
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_556_setGraphicSize)
HXLINE( 557)		this->super::setGraphicSize(width,height);
HXLINE( 558)		this->bg->setGraphicSize(width,height);
HXLINE( 559)		this->behindText->setGraphicSize((width - ( (Float)(2) )),(height - ( (Float)(2) )));
HXLINE( 560)		bool _hx_tmp;
HXDLIN( 560)		if (::hx::IsNotNull( this->textObj )) {
HXLINE( 560)			_hx_tmp = this->textObj->exists;
            		}
            		else {
HXLINE( 560)			_hx_tmp = false;
            		}
HXDLIN( 560)		if (_hx_tmp) {
HXLINE( 562)			this->textObj->scale->set_x(( (Float)(1) ));
HXLINE( 563)			this->textObj->scale->set_y(( (Float)(1) ));
HXLINE( 564)			bool _hx_tmp1;
HXDLIN( 564)			if (::hx::IsNotNull( this->caret )) {
HXLINE( 564)				_hx_tmp1 = this->caret->exists;
            			}
            			else {
HXLINE( 564)				_hx_tmp1 = false;
            			}
HXDLIN( 564)			if (_hx_tmp1) {
HXLINE( 564)				 ::flixel::FlxSprite _hx_tmp2 = this->caret;
HXDLIN( 564)				_hx_tmp2->setGraphicSize(1,(this->textObj->get_height() - ( (Float)(4) )));
            			}
            		}
            	}


void PsychUIInputText_obj::updateHitbox(){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_569_updateHitbox)
HXLINE( 570)		this->super::updateHitbox();
HXLINE( 571)		this->bg->updateHitbox();
HXLINE( 572)		this->behindText->updateHitbox();
HXLINE( 573)		bool _hx_tmp;
HXDLIN( 573)		if (::hx::IsNotNull( this->textObj )) {
HXLINE( 573)			_hx_tmp = this->textObj->exists;
            		}
            		else {
HXLINE( 573)			_hx_tmp = false;
            		}
HXDLIN( 573)		if (_hx_tmp) {
HXLINE( 575)			this->textObj->updateHitbox();
HXLINE( 576)			bool _hx_tmp1;
HXDLIN( 576)			if (::hx::IsNotNull( this->caret )) {
HXLINE( 576)				_hx_tmp1 = this->caret->exists;
            			}
            			else {
HXLINE( 576)				_hx_tmp1 = false;
            			}
HXDLIN( 576)			if (_hx_tmp1) {
HXLINE( 576)				this->caret->updateHitbox();
            			}
            		}
            	}


int PsychUIInputText_obj::set_fieldWidth(int v){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_581_set_fieldWidth)
HXLINE( 582)		this->textObj->set_fieldWidth(::Math_obj::max(( (Float)(1) ),( (Float)((v - 2)) )));
HXLINE( 583)		this->textObj->textField->set_selectable(false);
HXLINE( 584)		this->textObj->textField->set_wordWrap(false);
HXLINE( 585)		this->textObj->textField->set_multiline(false);
HXLINE( 586)		return (this->fieldWidth = v);
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,set_fieldWidth,return )

int PsychUIInputText_obj::set_maxLength(int v){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_590_set_maxLength)
HXLINE( 591)		::String lastText = this->text;
HXLINE( 592)		v = ::Std_obj::_hx_int(::Math_obj::max(( (Float)(0) ),( (Float)(v) )));
HXLINE( 593)		bool _hx_tmp;
HXDLIN( 593)		if ((v > 0)) {
HXLINE( 593)			_hx_tmp = (this->text.length > v);
            		}
            		else {
HXLINE( 593)			_hx_tmp = false;
            		}
HXDLIN( 593)		if (_hx_tmp) {
HXLINE( 593)			this->set_text(this->text.substr(0,v));
            		}
HXLINE( 594)		if (::hx::IsNotNull( this->onChange )) {
HXLINE( 594)			this->onChange(lastText,this->text);
            		}
HXLINE( 595)		if (this->broadcastInputTextEvent) {
HXLINE( 595)			::backend::ui::PsychUIEventHandler_obj::event(::backend::ui::PsychUIInputText_obj::CHANGE_EVENT,::hx::ObjectPtr<OBJ_>(this));
            		}
HXLINE( 596)		return (this->maxLength = v);
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,set_maxLength,return )

bool PsychUIInputText_obj::set_passwordMask(bool v){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_600_set_passwordMask)
HXLINE( 601)		this->passwordMask = v;
HXLINE( 602)		this->set_text(this->text);
HXLINE( 603)		return this->passwordMask;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,set_passwordMask,return )

::String PsychUIInputText_obj::set_text(::String v){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_608_set_text)
HXLINE( 609)		{
HXLINE( 609)			int _g = 0;
HXDLIN( 609)			int _g1 = this->_boundaries->length;
HXDLIN( 609)			while((_g < _g1)){
HXLINE( 609)				_g = (_g + 1);
HXDLIN( 609)				int i = (_g - 1);
HXDLIN( 609)				this->_boundaries->pop();
            			}
            		}
HXLINE( 610)		v = this->filter(v);
HXLINE( 612)		this->textObj->set_text(HX_("",00,00,00,00));
HXLINE( 613)		bool _hx_tmp;
HXDLIN( 613)		if (::hx::IsNotNull( v )) {
HXLINE( 613)			_hx_tmp = (v.length > 0);
            		}
            		else {
HXLINE( 613)			_hx_tmp = false;
            		}
HXDLIN( 613)		if (_hx_tmp) {
HXLINE( 615)			if ((v.length > 1)) {
HXLINE( 617)				int _g2 = 0;
HXDLIN( 617)				int _g3 = v.length;
HXDLIN( 617)				while((_g2 < _g3)){
HXLINE( 617)					_g2 = (_g2 + 1);
HXDLIN( 617)					int i1 = (_g2 - 1);
HXLINE( 619)					::String toPrint = v.substr(i1,1);
HXLINE( 620)					if ((toPrint == HX_("\n",0a,00,00,00))) {
HXLINE( 620)						toPrint = HX_(" ",20,00,00,00);
            					}
HXLINE( 621)					::String _hx_tmp1;
HXDLIN( 621)					if (!(this->passwordMask)) {
HXLINE( 621)						_hx_tmp1 = toPrint;
            					}
            					else {
HXLINE( 621)						_hx_tmp1 = HX_("*",2a,00,00,00);
            					}
HXDLIN( 621)					this->textObj->textField->appendText(_hx_tmp1);
HXLINE( 622)					::Array< Float > _hx_tmp2 = this->_boundaries;
HXDLIN( 622)					_hx_tmp2->push(this->textObj->textField->get_textWidth());
            				}
            			}
            			else {
HXLINE( 627)				::String _hx_tmp3;
HXDLIN( 627)				if (!(this->passwordMask)) {
HXLINE( 627)					_hx_tmp3 = v;
            				}
            				else {
HXLINE( 627)					_hx_tmp3 = HX_("*",2a,00,00,00);
            				}
HXDLIN( 627)				this->textObj->set_text(_hx_tmp3);
HXLINE( 628)				::Array< Float > _hx_tmp4 = this->_boundaries;
HXDLIN( 628)				_hx_tmp4->push(this->textObj->textField->get_textWidth());
            			}
            		}
HXLINE( 631)		this->text = v;
HXLINE( 632)		this->updateCaret();
HXLINE( 633)		return v;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,set_text,return )

void PsychUIInputText_obj::_typeLetter(int charCode){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_655__typeLetter)
HXLINE( 656)		if ((charCode < 1)) {
HXLINE( 656)			return;
            		}
HXLINE( 658)		bool _hx_tmp;
HXDLIN( 658)		if ((this->selectIndex > -1)) {
HXLINE( 658)			_hx_tmp = (this->selectIndex != this->caretIndex);
            		}
            		else {
HXLINE( 658)			_hx_tmp = false;
            		}
HXDLIN( 658)		if (_hx_tmp) {
HXLINE( 659)			this->deleteSelection();
            		}
HXLINE( 661)		::String letter = ::String::fromCharCode(charCode);
HXLINE( 662)		letter = this->filter(letter);
HXLINE( 663)		bool _hx_tmp1;
HXDLIN( 663)		if ((letter.length > 0)) {
HXLINE( 663)			if ((this->maxLength != 0)) {
HXLINE( 663)				_hx_tmp1 = ((this->text.length + letter.length) <= this->maxLength);
            			}
            			else {
HXLINE( 663)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXLINE( 663)			_hx_tmp1 = false;
            		}
HXDLIN( 663)		if (_hx_tmp1) {
HXLINE( 665)			::String lastText = this->text;
HXLINE( 667)			if (!(this->inInsertMode)) {
HXLINE( 668)				::String _hx_tmp2 = (this->text.substring(0,this->caretIndex) + letter);
HXDLIN( 668)				this->set_text((_hx_tmp2 + this->text.substring(this->caretIndex,null())));
            			}
            			else {
HXLINE( 670)				::String _hx_tmp3 = (this->text.substring(0,this->caretIndex) + letter);
HXDLIN( 670)				this->set_text((_hx_tmp3 + this->text.substring((this->caretIndex + 1),null())));
            			}
HXLINE( 672)			this->set_caretIndex((this->caretIndex + letter.length));
HXLINE( 673)			if (::hx::IsNotNull( this->onChange )) {
HXLINE( 673)				this->onChange(lastText,this->text);
            			}
HXLINE( 674)			if (this->broadcastInputTextEvent) {
HXLINE( 674)				::backend::ui::PsychUIEventHandler_obj::event(::backend::ui::PsychUIInputText_obj::CHANGE_EVENT,::hx::ObjectPtr<OBJ_>(this));
            			}
            		}
HXLINE( 676)		this->_caretTime = ( (Float)(0) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,_typeLetter,(void))

int PsychUIInputText_obj::set_forceCase(int v){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_681_set_forceCase)
HXLINE( 682)		this->forceCase = v;
HXLINE( 683)		this->set_text(this->filter(this->text));
HXLINE( 684)		return this->forceCase;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,set_forceCase,return )

int PsychUIInputText_obj::set_filterMode(int v){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_688_set_filterMode)
HXLINE( 689)		this->filterMode = v;
HXLINE( 690)		this->set_text(this->filter(this->text));
HXLINE( 691)		return this->filterMode;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,set_filterMode,return )

 ::EReg PsychUIInputText_obj::set_customFilterPattern( ::EReg cfp){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_695_set_customFilterPattern)
HXLINE( 696)		this->customFilterPattern = cfp;
HXLINE( 697)		this->set_filterMode(5);
HXLINE( 698)		return this->customFilterPattern;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,set_customFilterPattern,return )

::String PsychUIInputText_obj::filter(::String text){
            	HX_GC_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_702_filter)
HXLINE( 703)		switch((int)(this->forceCase)){
            			case (int)1: {
HXLINE( 706)				text = text.toUpperCase();
            			}
            			break;
            			case (int)2: {
HXLINE( 708)				text = text.toLowerCase();
            			}
            			break;
            			default:{
            			}
            		}
HXLINE( 711)		if ((this->forceCase == 1)) {
HXLINE( 712)			text = text.toUpperCase();
            		}
            		else {
HXLINE( 713)			if ((this->forceCase == 2)) {
HXLINE( 714)				text = text.toLowerCase();
            			}
            		}
HXLINE( 716)		if ((this->filterMode != 0)) {
HXLINE( 718)			 ::EReg pattern;
HXLINE( 719)			switch((int)(this->filterMode)){
            				case (int)1: {
HXLINE( 722)					pattern =  ::EReg_obj::__alloc( HX_CTX ,HX_("[^a-zA-Z]*",50,38,19,1d),HX_("g",67,00,00,00));
            				}
            				break;
            				case (int)2: {
HXLINE( 724)					pattern =  ::EReg_obj::__alloc( HX_CTX ,HX_("[^0-9]*",46,25,d3,1e),HX_("g",67,00,00,00));
            				}
            				break;
            				case (int)3: {
HXLINE( 726)					pattern =  ::EReg_obj::__alloc( HX_CTX ,HX_("[^a-zA-Z0-9]*",86,f4,79,aa),HX_("g",67,00,00,00));
            				}
            				break;
            				case (int)4: {
HXLINE( 728)					pattern =  ::EReg_obj::__alloc( HX_CTX ,HX_("[^a-fA-F0-9]*",06,89,7a,30),HX_("g",67,00,00,00));
            				}
            				break;
            				case (int)5: {
HXLINE( 730)					pattern = this->customFilterPattern;
            				}
            				break;
            				default:{
HXLINE( 732)					HX_STACK_DO_THROW( ::openfl::errors::Error_obj::__alloc( HX_CTX ,((HX_("FlxInputText: Unknown filterMode (",04,c7,17,56) + this->filterMode) + HX_(")",29,00,00,00)),null()));
            				}
            			}
HXLINE( 734)			text = pattern->replace(text,HX_("",00,00,00,00));
            		}
HXLINE( 736)		return text;
            	}


HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,filter,return )

::Array< int > PsychUIInputText_obj::onKeyDown_ignored;

::String PsychUIInputText_obj::CHANGE_EVENT;

int PsychUIInputText_obj::KEY_TILDE;

int PsychUIInputText_obj::KEY_ACUTE;

 ::backend::ui::PsychUIInputText PsychUIInputText_obj::focusOn;

 ::backend::ui::PsychUIInputText PsychUIInputText_obj::set_focusOn( ::backend::ui::PsychUIInputText v){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_383_set_focusOn)
HXLINE( 384)		bool _hx_tmp;
HXDLIN( 384)		bool _hx_tmp1;
HXDLIN( 384)		if (::hx::IsNotNull( ::backend::ui::PsychUIInputText_obj::focusOn )) {
HXLINE( 384)			_hx_tmp1 = ::hx::IsInstanceNotEq( ::backend::ui::PsychUIInputText_obj::focusOn,v );
            		}
            		else {
HXLINE( 384)			_hx_tmp1 = false;
            		}
HXDLIN( 384)		if (_hx_tmp1) {
HXLINE( 384)			_hx_tmp = ::backend::ui::PsychUIInputText_obj::focusOn->exists;
            		}
            		else {
HXLINE( 384)			_hx_tmp = false;
            		}
HXDLIN( 384)		if (_hx_tmp) {
HXLINE( 386)			if (::hx::IsNotNull( ::backend::ui::PsychUIInputText_obj::focusOn->unfocus )) {
HXLINE( 386)				::backend::ui::PsychUIInputText_obj::focusOn->unfocus();
            			}
HXLINE( 387)			::backend::ui::PsychUIInputText_obj::focusOn->resetCaret();
            		}
HXLINE( 389)		return (::backend::ui::PsychUIInputText_obj::focusOn = v);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,set_focusOn,return )

int PsychUIInputText_obj::getAccentCharCode(int accent){
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_638_getAccentCharCode)
HXDLIN( 638)		switch((int)(accent)){
            			case (int)0: {
HXLINE( 647)				return 96;
            			}
            			break;
            			case (int)1: {
HXLINE( 645)				return 180;
            			}
            			break;
            			case (int)2: {
HXLINE( 643)				return 94;
            			}
            			break;
            			case (int)3: {
HXLINE( 641)				return 126;
            			}
            			break;
            			default:{
HXLINE( 649)				return 0;
            			}
            		}
HXLINE( 638)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(PsychUIInputText_obj,getAccentCharCode,return )


void PsychUIInputText_obj::__alloc_dynamic_functions(::hx::Ctx *_hx_ctx,PsychUIInputText_obj *_hx_obj) {
	if (!_hx_obj->onPressEnter.mPtr) _hx_obj->onPressEnter = new __default_onPressEnter(_hx_obj);
}
::hx::ObjectPtr< PsychUIInputText_obj > PsychUIInputText_obj::__new(::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y,::hx::Null< int >  __o_wid,::String __o_text,::hx::Null< int >  __o_size) {
	::hx::ObjectPtr< PsychUIInputText_obj > __this = new PsychUIInputText_obj();
	__this->__construct(__o_x,__o_y,__o_wid,__o_text,__o_size);
	return __this;
}

::hx::ObjectPtr< PsychUIInputText_obj > PsychUIInputText_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y,::hx::Null< int >  __o_wid,::String __o_text,::hx::Null< int >  __o_size) {
	PsychUIInputText_obj *__this = (PsychUIInputText_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PsychUIInputText_obj), true, "backend.ui.PsychUIInputText"));
	*(void **)__this = PsychUIInputText_obj::_hx_vtable;
	backend::ui::PsychUIInputText_obj::__alloc_dynamic_functions(_hx_ctx,__this);
	__this->__construct(__o_x,__o_y,__o_wid,__o_text,__o_size);
	return __this;
}

PsychUIInputText_obj::PsychUIInputText_obj()
{
	onPressEnter = new __default_onPressEnter(this);
}

void PsychUIInputText_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(PsychUIInputText);
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(bg,"bg");
	HX_MARK_MEMBER_NAME(behindText,"behindText");
	HX_MARK_MEMBER_NAME(selection,"selection");
	HX_MARK_MEMBER_NAME(textObj,"textObj");
	HX_MARK_MEMBER_NAME(caret,"caret");
	HX_MARK_MEMBER_NAME(onChange,"onChange");
	HX_MARK_MEMBER_NAME(fieldWidth,"fieldWidth");
	HX_MARK_MEMBER_NAME(maxLength,"maxLength");
	HX_MARK_MEMBER_NAME(passwordMask,"passwordMask");
	HX_MARK_MEMBER_NAME(text,"text");
	HX_MARK_MEMBER_NAME(forceCase,"forceCase");
	HX_MARK_MEMBER_NAME(filterMode,"filterMode");
	HX_MARK_MEMBER_NAME(customFilterPattern,"customFilterPattern");
	HX_MARK_MEMBER_NAME(selectedFormat,"selectedFormat");
	HX_MARK_MEMBER_NAME(selectIndex,"selectIndex");
	HX_MARK_MEMBER_NAME(caretIndex,"caretIndex");
	HX_MARK_MEMBER_NAME(_caretTime,"_caretTime");
	HX_MARK_MEMBER_NAME(_nextAccent,"_nextAccent");
	HX_MARK_MEMBER_NAME(inInsertMode,"inInsertMode");
	HX_MARK_MEMBER_NAME(onPressEnter,"onPressEnter");
	HX_MARK_MEMBER_NAME(unfocus,"unfocus");
	HX_MARK_MEMBER_NAME(_boundaries,"_boundaries");
	HX_MARK_MEMBER_NAME(broadcastInputTextEvent,"broadcastInputTextEvent");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void PsychUIInputText_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(bg,"bg");
	HX_VISIT_MEMBER_NAME(behindText,"behindText");
	HX_VISIT_MEMBER_NAME(selection,"selection");
	HX_VISIT_MEMBER_NAME(textObj,"textObj");
	HX_VISIT_MEMBER_NAME(caret,"caret");
	HX_VISIT_MEMBER_NAME(onChange,"onChange");
	HX_VISIT_MEMBER_NAME(fieldWidth,"fieldWidth");
	HX_VISIT_MEMBER_NAME(maxLength,"maxLength");
	HX_VISIT_MEMBER_NAME(passwordMask,"passwordMask");
	HX_VISIT_MEMBER_NAME(text,"text");
	HX_VISIT_MEMBER_NAME(forceCase,"forceCase");
	HX_VISIT_MEMBER_NAME(filterMode,"filterMode");
	HX_VISIT_MEMBER_NAME(customFilterPattern,"customFilterPattern");
	HX_VISIT_MEMBER_NAME(selectedFormat,"selectedFormat");
	HX_VISIT_MEMBER_NAME(selectIndex,"selectIndex");
	HX_VISIT_MEMBER_NAME(caretIndex,"caretIndex");
	HX_VISIT_MEMBER_NAME(_caretTime,"_caretTime");
	HX_VISIT_MEMBER_NAME(_nextAccent,"_nextAccent");
	HX_VISIT_MEMBER_NAME(inInsertMode,"inInsertMode");
	HX_VISIT_MEMBER_NAME(onPressEnter,"onPressEnter");
	HX_VISIT_MEMBER_NAME(unfocus,"unfocus");
	HX_VISIT_MEMBER_NAME(_boundaries,"_boundaries");
	HX_VISIT_MEMBER_NAME(broadcastInputTextEvent,"broadcastInputTextEvent");
	 ::flixel::group::FlxTypedSpriteGroup_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val PsychUIInputText_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"bg") ) { return ::hx::Val( bg ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { return ::hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"text") ) { return ::hx::Val( text ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"caret") ) { return ::hx::Val( caret ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"filter") ) { return ::hx::Val( filter_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"textObj") ) { return ::hx::Val( textObj ); }
		if (HX_FIELD_EQ(inName,"unfocus") ) { return ::hx::Val( unfocus ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"onChange") ) { return ::hx::Val( onChange ); }
		if (HX_FIELD_EQ(inName,"set_text") ) { return ::hx::Val( set_text_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"selection") ) { return ::hx::Val( selection ); }
		if (HX_FIELD_EQ(inName,"maxLength") ) { return ::hx::Val( maxLength ); }
		if (HX_FIELD_EQ(inName,"forceCase") ) { return ::hx::Val( forceCase ); }
		if (HX_FIELD_EQ(inName,"onKeyDown") ) { return ::hx::Val( onKeyDown_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"behindText") ) { return ::hx::Val( behindText ); }
		if (HX_FIELD_EQ(inName,"fieldWidth") ) { return ::hx::Val( fieldWidth ); }
		if (HX_FIELD_EQ(inName,"filterMode") ) { return ::hx::Val( filterMode ); }
		if (HX_FIELD_EQ(inName,"caretIndex") ) { return ::hx::Val( caretIndex ); }
		if (HX_FIELD_EQ(inName,"_caretTime") ) { return ::hx::Val( _caretTime ); }
		if (HX_FIELD_EQ(inName,"resetCaret") ) { return ::hx::Val( resetCaret_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"selectIndex") ) { return ::hx::Val( selectIndex ); }
		if (HX_FIELD_EQ(inName,"_nextAccent") ) { return ::hx::Val( _nextAccent ); }
		if (HX_FIELD_EQ(inName,"updateCaret") ) { return ::hx::Val( updateCaret_dyn() ); }
		if (HX_FIELD_EQ(inName,"_boundaries") ) { return ::hx::Val( _boundaries ); }
		if (HX_FIELD_EQ(inName,"_typeLetter") ) { return ::hx::Val( _typeLetter_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"passwordMask") ) { return ::hx::Val( passwordMask ); }
		if (HX_FIELD_EQ(inName,"inInsertMode") ) { return ::hx::Val( inInsertMode ); }
		if (HX_FIELD_EQ(inName,"onPressEnter") ) { return ::hx::Val( onPressEnter ); }
		if (HX_FIELD_EQ(inName,"updateHitbox") ) { return ::hx::Val( updateHitbox_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"set_maxLength") ) { return ::hx::Val( set_maxLength_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_forceCase") ) { return ::hx::Val( set_forceCase_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"selectedFormat") ) { return ::hx::Val( selectedFormat ); }
		if (HX_FIELD_EQ(inName,"set_caretIndex") ) { return ::hx::Val( set_caretIndex_dyn() ); }
		if (HX_FIELD_EQ(inName,"setGraphicSize") ) { return ::hx::Val( setGraphicSize_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_fieldWidth") ) { return ::hx::Val( set_fieldWidth_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_filterMode") ) { return ::hx::Val( set_filterMode_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"deleteSelection") ) { return ::hx::Val( deleteSelection_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"set_passwordMask") ) { return ::hx::Val( set_passwordMask_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"customFilterPattern") ) { return ::hx::Val( customFilterPattern ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"broadcastInputTextEvent") ) { return ::hx::Val( broadcastInputTextEvent ); }
		if (HX_FIELD_EQ(inName,"set_customFilterPattern") ) { return ::hx::Val( set_customFilterPattern_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool PsychUIInputText_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"focusOn") ) { outValue = ( focusOn ); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"KEY_TILDE") ) { outValue = ( KEY_TILDE ); return true; }
		if (HX_FIELD_EQ(inName,"KEY_ACUTE") ) { outValue = ( KEY_ACUTE ); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"set_focusOn") ) { outValue = set_focusOn_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"CHANGE_EVENT") ) { outValue = ( CHANGE_EVENT ); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"onKeyDown_ignored") ) { outValue = ( onKeyDown_ignored ); return true; }
		if (HX_FIELD_EQ(inName,"getAccentCharCode") ) { outValue = getAccentCharCode_dyn(); return true; }
	}
	return false;
}

::hx::Val PsychUIInputText_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"bg") ) { bg=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"text") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_text(inValue.Cast< ::String >()) );text=inValue.Cast< ::String >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"caret") ) { caret=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"textObj") ) { textObj=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"unfocus") ) { unfocus=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"onChange") ) { onChange=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"selection") ) { selection=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxLength") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_maxLength(inValue.Cast< int >()) );maxLength=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"forceCase") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_forceCase(inValue.Cast< int >()) );forceCase=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"behindText") ) { behindText=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fieldWidth") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_fieldWidth(inValue.Cast< int >()) );fieldWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"filterMode") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_filterMode(inValue.Cast< int >()) );filterMode=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"caretIndex") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_caretIndex(inValue.Cast< int >()) );caretIndex=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_caretTime") ) { _caretTime=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"selectIndex") ) { selectIndex=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_nextAccent") ) { _nextAccent=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_boundaries") ) { _boundaries=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"passwordMask") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_passwordMask(inValue.Cast< bool >()) );passwordMask=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"inInsertMode") ) { inInsertMode=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"onPressEnter") ) { onPressEnter=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"selectedFormat") ) { selectedFormat=inValue.Cast<  ::flixel::text::FlxTextFormat >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"customFilterPattern") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_customFilterPattern(inValue.Cast<  ::EReg >()) );customFilterPattern=inValue.Cast<  ::EReg >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"broadcastInputTextEvent") ) { broadcastInputTextEvent=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool PsychUIInputText_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"focusOn") ) { if (inCallProp == ::hx::paccAlways)  ioValue = ( set_focusOn(ioValue.Cast<  ::backend::ui::PsychUIInputText >()) ); else focusOn=ioValue.Cast<  ::backend::ui::PsychUIInputText >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"KEY_TILDE") ) { KEY_TILDE=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"KEY_ACUTE") ) { KEY_ACUTE=ioValue.Cast< int >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"CHANGE_EVENT") ) { CHANGE_EVENT=ioValue.Cast< ::String >(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"onKeyDown_ignored") ) { onKeyDown_ignored=ioValue.Cast< ::Array< int > >(); return true; }
	}
	return false;
}

void PsychUIInputText_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("name",4b,72,ff,48));
	outFields->push(HX_("bg",c5,55,00,00));
	outFields->push(HX_("behindText",87,0e,b3,e7));
	outFields->push(HX_("selection",4c,f8,1a,8e));
	outFields->push(HX_("textObj",4a,e5,c3,9e));
	outFields->push(HX_("caret",83,f9,1f,41));
	outFields->push(HX_("fieldWidth",ec,2e,e5,97));
	outFields->push(HX_("maxLength",aa,a6,92,ce));
	outFields->push(HX_("passwordMask",a7,b9,1e,b6));
	outFields->push(HX_("text",ad,cc,f9,4c));
	outFields->push(HX_("forceCase",3b,ce,fe,46));
	outFields->push(HX_("filterMode",3b,5b,a5,54));
	outFields->push(HX_("customFilterPattern",07,03,33,08));
	outFields->push(HX_("selectedFormat",f2,e3,ec,80));
	outFields->push(HX_("selectIndex",76,9e,7f,17));
	outFields->push(HX_("caretIndex",8f,b6,5b,dd));
	outFields->push(HX_("_caretTime",f1,ea,06,84));
	outFields->push(HX_("_nextAccent",bc,0f,c2,92));
	outFields->push(HX_("inInsertMode",81,e3,12,7c));
	outFields->push(HX_("_boundaries",e7,18,38,09));
	outFields->push(HX_("broadcastInputTextEvent",a4,b9,59,7c));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo PsychUIInputText_obj_sMemberStorageInfo[] = {
	{::hx::fsString,(int)offsetof(PsychUIInputText_obj,name),HX_("name",4b,72,ff,48)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(PsychUIInputText_obj,bg),HX_("bg",c5,55,00,00)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(PsychUIInputText_obj,behindText),HX_("behindText",87,0e,b3,e7)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(PsychUIInputText_obj,selection),HX_("selection",4c,f8,1a,8e)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(PsychUIInputText_obj,textObj),HX_("textObj",4a,e5,c3,9e)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(PsychUIInputText_obj,caret),HX_("caret",83,f9,1f,41)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(PsychUIInputText_obj,onChange),HX_("onChange",ef,87,1f,97)},
	{::hx::fsInt,(int)offsetof(PsychUIInputText_obj,fieldWidth),HX_("fieldWidth",ec,2e,e5,97)},
	{::hx::fsInt,(int)offsetof(PsychUIInputText_obj,maxLength),HX_("maxLength",aa,a6,92,ce)},
	{::hx::fsBool,(int)offsetof(PsychUIInputText_obj,passwordMask),HX_("passwordMask",a7,b9,1e,b6)},
	{::hx::fsString,(int)offsetof(PsychUIInputText_obj,text),HX_("text",ad,cc,f9,4c)},
	{::hx::fsInt,(int)offsetof(PsychUIInputText_obj,forceCase),HX_("forceCase",3b,ce,fe,46)},
	{::hx::fsInt,(int)offsetof(PsychUIInputText_obj,filterMode),HX_("filterMode",3b,5b,a5,54)},
	{::hx::fsObject /*  ::EReg */ ,(int)offsetof(PsychUIInputText_obj,customFilterPattern),HX_("customFilterPattern",07,03,33,08)},
	{::hx::fsObject /*  ::flixel::text::FlxTextFormat */ ,(int)offsetof(PsychUIInputText_obj,selectedFormat),HX_("selectedFormat",f2,e3,ec,80)},
	{::hx::fsInt,(int)offsetof(PsychUIInputText_obj,selectIndex),HX_("selectIndex",76,9e,7f,17)},
	{::hx::fsInt,(int)offsetof(PsychUIInputText_obj,caretIndex),HX_("caretIndex",8f,b6,5b,dd)},
	{::hx::fsFloat,(int)offsetof(PsychUIInputText_obj,_caretTime),HX_("_caretTime",f1,ea,06,84)},
	{::hx::fsInt,(int)offsetof(PsychUIInputText_obj,_nextAccent),HX_("_nextAccent",bc,0f,c2,92)},
	{::hx::fsBool,(int)offsetof(PsychUIInputText_obj,inInsertMode),HX_("inInsertMode",81,e3,12,7c)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(PsychUIInputText_obj,onPressEnter),HX_("onPressEnter",94,90,22,26)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(PsychUIInputText_obj,unfocus),HX_("unfocus",df,56,1a,01)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(PsychUIInputText_obj,_boundaries),HX_("_boundaries",e7,18,38,09)},
	{::hx::fsBool,(int)offsetof(PsychUIInputText_obj,broadcastInputTextEvent),HX_("broadcastInputTextEvent",a4,b9,59,7c)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo PsychUIInputText_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /* ::Array< int > */ ,(void *) &PsychUIInputText_obj::onKeyDown_ignored,HX_("onKeyDown_ignored",d5,c4,b2,3e)},
	{::hx::fsString,(void *) &PsychUIInputText_obj::CHANGE_EVENT,HX_("CHANGE_EVENT",ab,38,ff,8d)},
	{::hx::fsInt,(void *) &PsychUIInputText_obj::KEY_TILDE,HX_("KEY_TILDE",78,4a,53,36)},
	{::hx::fsInt,(void *) &PsychUIInputText_obj::KEY_ACUTE,HX_("KEY_ACUTE",64,df,c5,41)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(void *) &PsychUIInputText_obj::focusOn,HX_("focusOn",17,4b,83,41)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String PsychUIInputText_obj_sMemberFields[] = {
	HX_("name",4b,72,ff,48),
	HX_("bg",c5,55,00,00),
	HX_("behindText",87,0e,b3,e7),
	HX_("selection",4c,f8,1a,8e),
	HX_("textObj",4a,e5,c3,9e),
	HX_("caret",83,f9,1f,41),
	HX_("onChange",ef,87,1f,97),
	HX_("fieldWidth",ec,2e,e5,97),
	HX_("maxLength",aa,a6,92,ce),
	HX_("passwordMask",a7,b9,1e,b6),
	HX_("text",ad,cc,f9,4c),
	HX_("forceCase",3b,ce,fe,46),
	HX_("filterMode",3b,5b,a5,54),
	HX_("customFilterPattern",07,03,33,08),
	HX_("selectedFormat",f2,e3,ec,80),
	HX_("selectIndex",76,9e,7f,17),
	HX_("caretIndex",8f,b6,5b,dd),
	HX_("_caretTime",f1,ea,06,84),
	HX_("_nextAccent",bc,0f,c2,92),
	HX_("inInsertMode",81,e3,12,7c),
	HX_("onKeyDown",42,22,f2,73),
	HX_("onPressEnter",94,90,22,26),
	HX_("unfocus",df,56,1a,01),
	HX_("update",09,86,05,87),
	HX_("resetCaret",34,31,bc,29),
	HX_("updateCaret",ba,62,b8,26),
	HX_("deleteSelection",a1,3a,7f,d0),
	HX_("destroy",fa,2c,86,24),
	HX_("set_caretIndex",4c,27,71,73),
	HX_("setGraphicSize",07,d7,f8,2d),
	HX_("updateHitbox",81,94,eb,56),
	HX_("set_fieldWidth",a9,9f,fa,2d),
	HX_("set_maxLength",8d,5c,fc,d4),
	HX_("set_passwordMask",a4,93,ff,10),
	HX_("_boundaries",e7,18,38,09),
	HX_("set_text",aa,e1,11,7b),
	HX_("broadcastInputTextEvent",a4,b9,59,7c),
	HX_("_typeLetter",5f,a8,09,ee),
	HX_("set_forceCase",1e,84,68,4d),
	HX_("set_filterMode",f8,cb,ba,ea),
	HX_("set_customFilterPattern",aa,12,ea,12),
	HX_("filter",b8,1f,35,85),
	::String(null()) };

static void PsychUIInputText_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(PsychUIInputText_obj::onKeyDown_ignored,"onKeyDown_ignored");
	HX_MARK_MEMBER_NAME(PsychUIInputText_obj::CHANGE_EVENT,"CHANGE_EVENT");
	HX_MARK_MEMBER_NAME(PsychUIInputText_obj::KEY_TILDE,"KEY_TILDE");
	HX_MARK_MEMBER_NAME(PsychUIInputText_obj::KEY_ACUTE,"KEY_ACUTE");
	HX_MARK_MEMBER_NAME(PsychUIInputText_obj::focusOn,"focusOn");
};

#ifdef HXCPP_VISIT_ALLOCS
static void PsychUIInputText_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(PsychUIInputText_obj::onKeyDown_ignored,"onKeyDown_ignored");
	HX_VISIT_MEMBER_NAME(PsychUIInputText_obj::CHANGE_EVENT,"CHANGE_EVENT");
	HX_VISIT_MEMBER_NAME(PsychUIInputText_obj::KEY_TILDE,"KEY_TILDE");
	HX_VISIT_MEMBER_NAME(PsychUIInputText_obj::KEY_ACUTE,"KEY_ACUTE");
	HX_VISIT_MEMBER_NAME(PsychUIInputText_obj::focusOn,"focusOn");
};

#endif

::hx::Class PsychUIInputText_obj::__mClass;

static ::String PsychUIInputText_obj_sStaticFields[] = {
	HX_("onKeyDown_ignored",d5,c4,b2,3e),
	HX_("CHANGE_EVENT",ab,38,ff,8d),
	HX_("KEY_TILDE",78,4a,53,36),
	HX_("KEY_ACUTE",64,df,c5,41),
	HX_("focusOn",17,4b,83,41),
	HX_("set_focusOn",3a,b2,ea,d1),
	HX_("getAccentCharCode",c3,b5,91,1f),
	::String(null())
};

void PsychUIInputText_obj::__register()
{
	PsychUIInputText_obj _hx_dummy;
	PsychUIInputText_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("backend.ui.PsychUIInputText",a8,95,d2,45);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &PsychUIInputText_obj::__GetStatic;
	__mClass->mSetStaticField = &PsychUIInputText_obj::__SetStatic;
	__mClass->mMarkFunc = PsychUIInputText_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(PsychUIInputText_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PsychUIInputText_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PsychUIInputText_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = PsychUIInputText_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PsychUIInputText_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PsychUIInputText_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void PsychUIInputText_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_224_boot)
HXDLIN( 224)		onKeyDown_ignored = ::Array_obj< int >::fromData( _hx_array_data_45d295a8_30,3);
            	}
{
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_37_boot)
HXDLIN(  37)		CHANGE_EVENT = HX_("inputtext_change",38,7a,83,c2);
            	}
{
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_39_boot)
HXDLIN(  39)		KEY_TILDE = 126;
            	}
{
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_40_boot)
HXDLIN(  40)		KEY_ACUTE = 180;
            	}
{
            	HX_STACKFRAME(&_hx_pos_efd7f05f5af3fa82_42_boot)
HXDLIN(  42)		focusOn = null();
            	}
}

} // end namespace backend
} // end namespace ui
