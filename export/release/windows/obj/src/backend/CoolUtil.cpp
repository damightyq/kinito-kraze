// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_backend_ClientPrefs
#include <backend/ClientPrefs.h>
#endif
#ifndef INCLUDED_backend_CoolUtil
#include <backend/CoolUtil.h>
#endif
#ifndef INCLUDED_backend_MusicBeatState
#include <backend/MusicBeatState.h>
#endif
#ifndef INCLUDED_backend_SaveVariables
#include <backend/SaveVariables.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSave
#include <flixel/util/FlxSave.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_http_HttpBase
#include <haxe/http/HttpBase.h>
#endif
#ifndef INCLUDED_lime_app_Application
#include <lime/app/Application.h>
#endif
#ifndef INCLUDED_lime_app_IModule
#include <lime/app/IModule.h>
#endif
#ifndef INCLUDED_lime_app_Module
#include <lime/app/Module.h>
#endif
#ifndef INCLUDED_openfl_Lib
#include <openfl/Lib.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_MovieClip
#include <openfl/display/MovieClip.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_display_Stage
#include <openfl/display/Stage.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_net_URLRequest
#include <openfl/net/URLRequest.h>
#endif
#ifndef INCLUDED_states_MainMenuState
#include <states/MainMenuState.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif
#ifndef INCLUDED_sys_Http
#include <sys/Http.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_8_checkForUpdates,"backend.CoolUtil","checkForUpdates",0xed04bde0,"backend.CoolUtil.checkForUpdates","backend/CoolUtil.hx",8,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_16_checkForUpdates,"backend.CoolUtil","checkForUpdates",0xed04bde0,"backend.CoolUtil.checkForUpdates","backend/CoolUtil.hx",16,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_28_checkForUpdates,"backend.CoolUtil","checkForUpdates",0xed04bde0,"backend.CoolUtil.checkForUpdates","backend/CoolUtil.hx",28,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_34_quantize,"backend.CoolUtil","quantize",0x96fb8b1a,"backend.CoolUtil.quantize","backend/CoolUtil.hx",34,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_42_capitalize,"backend.CoolUtil","capitalize",0xdbf07455,"backend.CoolUtil.capitalize","backend/CoolUtil.hx",42,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_45_coolTextFile,"backend.CoolUtil","coolTextFile",0x5446309b,"backend.CoolUtil.coolTextFile","backend/CoolUtil.hx",45,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_56_colorFromString,"backend.CoolUtil","colorFromString",0x1f97add5,"backend.CoolUtil.colorFromString","backend/CoolUtil.hx",56,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_67_listFromString,"backend.CoolUtil","listFromString",0x72882302,"backend.CoolUtil.listFromString","backend/CoolUtil.hx",67,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_78_floorDecimal,"backend.CoolUtil","floorDecimal",0x1bf0430e,"backend.CoolUtil.floorDecimal","backend/CoolUtil.hx",78,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_86_dominantColor,"backend.CoolUtil","dominantColor",0x9df067da,"backend.CoolUtil.dominantColor","backend/CoolUtil.hx",86,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_118_numberArray,"backend.CoolUtil","numberArray",0xbca10747,"backend.CoolUtil.numberArray","backend/CoolUtil.hx",118,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_129_browserLoad,"backend.CoolUtil","browserLoad",0xf9659f25,"backend.CoolUtil.browserLoad","backend/CoolUtil.hx",129,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_133_openFolder,"backend.CoolUtil","openFolder",0x41814cc1,"backend.CoolUtil.openFolder","backend/CoolUtil.hx",133,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_162_getSavePath,"backend.CoolUtil","getSavePath",0x33882b6f,"backend.CoolUtil.getSavePath","backend/CoolUtil.hx",162,0x2a74e258)
HX_LOCAL_STACK_FRAME(_hx_pos_2eed4b4541010048_171_setTextBorderFromString,"backend.CoolUtil","setTextBorderFromString",0x8499b52d,"backend.CoolUtil.setTextBorderFromString","backend/CoolUtil.hx",171,0x2a74e258)
namespace backend{

void CoolUtil_obj::__construct() { }

Dynamic CoolUtil_obj::__CreateEmpty() { return new CoolUtil_obj; }

void *CoolUtil_obj::_hx_vtable = 0;

Dynamic CoolUtil_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< CoolUtil_obj > _hx_result = new CoolUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool CoolUtil_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2704589f;
}

::String CoolUtil_obj::checkForUpdates(::String url){
            	HX_GC_STACKFRAME(&_hx_pos_2eed4b4541010048_8_checkForUpdates)
HXLINE(   9)		bool _hx_tmp;
HXDLIN(   9)		if (::hx::IsNotNull( url )) {
HXLINE(   9)			_hx_tmp = (url.length == 0);
            		}
            		else {
HXLINE(   9)			_hx_tmp = true;
            		}
HXDLIN(   9)		if (_hx_tmp) {
HXLINE(  10)			url = HX_("https://raw.githubusercontent.com/ShadowMario/FNF-PsychEngine/main/gitVersion.txt",8c,16,f1,a1);
            		}
HXLINE(  11)		::Array< ::String > version = ::Array_obj< ::String >::__new(1)->init(0,::StringTools_obj::trim(::states::MainMenuState_obj::psychEngineVersion));
HXLINE(  12)		if (::backend::ClientPrefs_obj::data->checkForUpdates) {
            			HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0,::Array< ::Dynamic>,http,::Array< ::String >,version) HXARGC(1)
            			void _hx_run(::String data){
            				HX_GC_STACKFRAME(&_hx_pos_2eed4b4541010048_16_checkForUpdates)
HXLINE(  17)				::String newVersion = ::StringTools_obj::trim(data.split(HX_("\n",0a,00,00,00))->__get(0));
HXLINE(  18)				::haxe::Log_obj::trace((((HX_("version online: ",01,48,fa,0b) + newVersion) + HX_(", your version: ",85,c4,81,a1)) + version->__get(0)),::hx::SourceInfo(HX_("source/backend/CoolUtil.hx",e4,7b,b9,1b),18,HX_("backend.CoolUtil",25,93,40,42),HX_("checkForUpdates",29,6d,49,71)));
HXLINE(  19)				if ((newVersion != version->__get(0))) {
HXLINE(  20)					::haxe::Log_obj::trace(HX_("versions arent matching! please update",18,3e,bb,f9),::hx::SourceInfo(HX_("source/backend/CoolUtil.hx",e4,7b,b9,1b),20,HX_("backend.CoolUtil",25,93,40,42),HX_("checkForUpdates",29,6d,49,71)));
HXLINE(  21)					version[0] = newVersion;
HXLINE(  22)					http->__get(0).StaticCast<  ::sys::Http >()->onData = null();
HXLINE(  23)					http->__get(0).StaticCast<  ::sys::Http >()->onError = null();
HXLINE(  24)					http[0] = null();
            				}
            			}
            			HX_END_LOCAL_FUNC1((void))

            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(1)
            			void _hx_run(::String error){
            				HX_GC_STACKFRAME(&_hx_pos_2eed4b4541010048_28_checkForUpdates)
HXLINE(  28)				::haxe::Log_obj::trace((HX_("error: ",6e,80,0a,ea) + error),::hx::SourceInfo(HX_("source/backend/CoolUtil.hx",e4,7b,b9,1b),28,HX_("backend.CoolUtil",25,93,40,42),HX_("checkForUpdates",29,6d,49,71)));
            			}
            			HX_END_LOCAL_FUNC1((void))

HXLINE(  13)			::haxe::Log_obj::trace(HX_("checking for updates...",e1,57,9e,81),::hx::SourceInfo(HX_("source/backend/CoolUtil.hx",e4,7b,b9,1b),13,HX_("backend.CoolUtil",25,93,40,42),HX_("checkForUpdates",29,6d,49,71)));
HXLINE(  14)			::Array< ::Dynamic> http = ::Array_obj< ::Dynamic>::__new(1)->init(0, ::sys::Http_obj::__alloc( HX_CTX ,url));
HXLINE(  15)			http->__get(0).StaticCast<  ::sys::Http >()->onData =  ::Dynamic(new _hx_Closure_0(http,version));
HXLINE(  27)			http->__get(0).StaticCast<  ::sys::Http >()->onError =  ::Dynamic(new _hx_Closure_1());
HXLINE(  30)			http->__get(0).StaticCast<  ::sys::Http >()->request(null());
            		}
HXLINE(  32)		return version->__get(0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(CoolUtil_obj,checkForUpdates,return )

Float CoolUtil_obj::quantize(Float f,Float snap){
            	HX_STACKFRAME(&_hx_pos_2eed4b4541010048_34_quantize)
HXLINE(  36)		Float m = ::Math_obj::fround((f * snap));
HXLINE(  38)		return (m / snap);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(CoolUtil_obj,quantize,return )

::String CoolUtil_obj::capitalize(::String text){
            	HX_STACKFRAME(&_hx_pos_2eed4b4541010048_42_capitalize)
HXDLIN(  42)		::String _hx_tmp = text.charAt(0).toUpperCase();
HXDLIN(  42)		return (_hx_tmp + text.substr(1,null()).toLowerCase());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(CoolUtil_obj,capitalize,return )

::Array< ::String > CoolUtil_obj::coolTextFile(::String path){
            	HX_STACKFRAME(&_hx_pos_2eed4b4541010048_45_coolTextFile)
HXLINE(  46)		::String daList = null();
HXLINE(  48)		if (::sys::FileSystem_obj::exists(path)) {
HXLINE(  48)			daList = ::sys::io::File_obj::getContent(path);
            		}
HXLINE(  52)		if (::hx::IsNotNull( daList )) {
HXLINE(  52)			::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXDLIN(  52)			daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXDLIN(  52)			{
HXLINE(  52)				int _g = 0;
HXDLIN(  52)				int _g1 = daList1->length;
HXDLIN(  52)				while((_g < _g1)){
HXLINE(  52)					_g = (_g + 1);
HXDLIN(  52)					int i = (_g - 1);
HXDLIN(  52)					daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            				}
            			}
HXDLIN(  52)			return daList1;
            		}
            		else {
HXLINE(  52)			return ::Array_obj< ::String >::__new(0);
            		}
HXDLIN(  52)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(CoolUtil_obj,coolTextFile,return )

int CoolUtil_obj::colorFromString(::String color){
            	HX_GC_STACKFRAME(&_hx_pos_2eed4b4541010048_56_colorFromString)
HXLINE(  57)		 ::EReg hideChars =  ::EReg_obj::__alloc( HX_CTX ,HX_("[\t\n\r]",ac,57,71,6b),HX_("",00,00,00,00));
HXLINE(  58)		::String color1 = ::StringTools_obj::trim(hideChars->split(color)->join(HX_("",00,00,00,00)));
HXLINE(  59)		if (::StringTools_obj::startsWith(color1,HX_("0x",48,2a,00,00))) {
HXLINE(  59)			color1 = color1.substring((color1.length - 6),null());
            		}
HXLINE(  61)		 ::Dynamic colorNum = ::flixel::util::_FlxColor::FlxColor_Impl__obj::fromString(color1);
HXLINE(  62)		if (::hx::IsNull( colorNum )) {
HXLINE(  62)			colorNum = ::flixel::util::_FlxColor::FlxColor_Impl__obj::fromString((HX_("#",23,00,00,00) + color1));
            		}
HXLINE(  63)		if (::hx::IsNotNull( colorNum )) {
HXLINE(  63)			return ( (int)(colorNum) );
            		}
            		else {
HXLINE(  63)			return -1;
            		}
HXDLIN(  63)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(CoolUtil_obj,colorFromString,return )

::Array< ::String > CoolUtil_obj::listFromString(::String string){
            	HX_STACKFRAME(&_hx_pos_2eed4b4541010048_67_listFromString)
HXLINE(  68)		::Array< ::String > daList = ::Array_obj< ::String >::__new(0);
HXLINE(  69)		daList = ::StringTools_obj::trim(string).split(HX_("\n",0a,00,00,00));
HXLINE(  71)		{
HXLINE(  71)			int _g = 0;
HXDLIN(  71)			int _g1 = daList->length;
HXDLIN(  71)			while((_g < _g1)){
HXLINE(  71)				_g = (_g + 1);
HXDLIN(  71)				int i = (_g - 1);
HXLINE(  72)				daList[i] = ::StringTools_obj::trim(daList->__get(i));
            			}
            		}
HXLINE(  74)		return daList;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(CoolUtil_obj,listFromString,return )

Float CoolUtil_obj::floorDecimal(Float value,int decimals){
            	HX_STACKFRAME(&_hx_pos_2eed4b4541010048_78_floorDecimal)
HXLINE(  79)		if ((decimals < 1)) {
HXLINE(  80)			return ( (Float)(::Math_obj::floor(value)) );
            		}
HXLINE(  82)		return (( (Float)(::Math_obj::floor((value * ::Math_obj::pow(( (Float)(10) ),( (Float)(decimals) ))))) ) / ::Math_obj::pow(( (Float)(10) ),( (Float)(decimals) )));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(CoolUtil_obj,floorDecimal,return )

int CoolUtil_obj::dominantColor( ::flixel::FlxSprite sprite){
            	HX_GC_STACKFRAME(&_hx_pos_2eed4b4541010048_86_dominantColor)
HXLINE(  87)		 ::haxe::ds::IntMap countByColor =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  88)		{
HXLINE(  88)			int _g = 0;
HXDLIN(  88)			int _g1 = sprite->frameWidth;
HXDLIN(  88)			while((_g < _g1)){
HXLINE(  88)				_g = (_g + 1);
HXDLIN(  88)				int col = (_g - 1);
HXLINE(  90)				{
HXLINE(  90)					int _g2 = 0;
HXDLIN(  90)					int _g3 = sprite->frameHeight;
HXDLIN(  90)					while((_g2 < _g3)){
HXLINE(  90)						_g2 = (_g2 + 1);
HXDLIN(  90)						int row = (_g2 - 1);
HXLINE(  92)						int colorOfThisPixel = sprite->get_pixels()->getPixel32(col,row);
HXLINE(  93)						if (((( (Float)(((colorOfThisPixel >> 24) & 255)) ) / ( (Float)(255) )) > ((Float)0.05))) {
HXLINE(  95)							int Red = ((colorOfThisPixel >> 16) & 255);
HXDLIN(  95)							int Green = ((colorOfThisPixel >> 8) & 255);
HXDLIN(  95)							int Blue = (colorOfThisPixel & 255);
HXDLIN(  95)							int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN(  95)							{
HXLINE(  95)								color = (color & -16711681);
HXDLIN(  95)								int color1;
HXDLIN(  95)								if ((Red > 255)) {
HXLINE(  95)									color1 = 255;
            								}
            								else {
HXLINE(  95)									if ((Red < 0)) {
HXLINE(  95)										color1 = 0;
            									}
            									else {
HXLINE(  95)										color1 = Red;
            									}
            								}
HXDLIN(  95)								color = (color | (color1 << 16));
            							}
HXDLIN(  95)							{
HXLINE(  95)								color = (color & -65281);
HXDLIN(  95)								int color2;
HXDLIN(  95)								if ((Green > 255)) {
HXLINE(  95)									color2 = 255;
            								}
            								else {
HXLINE(  95)									if ((Green < 0)) {
HXLINE(  95)										color2 = 0;
            									}
            									else {
HXLINE(  95)										color2 = Green;
            									}
            								}
HXDLIN(  95)								color = (color | (color2 << 8));
            							}
HXDLIN(  95)							{
HXLINE(  95)								color = (color & -256);
HXDLIN(  95)								int color3;
HXDLIN(  95)								if ((Blue > 255)) {
HXLINE(  95)									color3 = 255;
            								}
            								else {
HXLINE(  95)									if ((Blue < 0)) {
HXLINE(  95)										color3 = 0;
            									}
            									else {
HXLINE(  95)										color3 = Blue;
            									}
            								}
HXDLIN(  95)								color = (color | color3);
            							}
HXDLIN(  95)							{
HXLINE(  95)								color = (color & 16777215);
HXDLIN(  95)								color = (color | -16777216);
            							}
HXDLIN(  95)							colorOfThisPixel = color;
HXLINE(  96)							int count;
HXDLIN(  96)							if (countByColor->exists(colorOfThisPixel)) {
HXLINE(  96)								count = ( (int)(countByColor->get(colorOfThisPixel)) );
            							}
            							else {
HXLINE(  96)								count = 0;
            							}
HXLINE(  97)							{
HXLINE(  97)								int v = (count + 1);
HXDLIN(  97)								countByColor->set(colorOfThisPixel,v);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 102)		int maxCount = 0;
HXLINE( 103)		int maxKey = 0;
HXLINE( 104)		countByColor->set(-16777216,0);
HXLINE( 105)		{
HXLINE( 105)			::Dynamic map = countByColor;
HXDLIN( 105)			::Dynamic _g_map = map;
HXDLIN( 105)			 ::Dynamic _g_keys = ::haxe::IMap_obj::keys(map);
HXDLIN( 105)			while(( (bool)(_g_keys->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 105)				int key = ( (int)(_g_keys->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 105)				int _g_value = ( (int)(::haxe::IMap_obj::get(_g_map,key)) );
HXDLIN( 105)				int _g_key = key;
HXDLIN( 105)				int key1 = _g_key;
HXDLIN( 105)				int count1 = _g_value;
HXLINE( 107)				if ((count1 >= maxCount)) {
HXLINE( 109)					maxCount = count1;
HXLINE( 110)					maxKey = key1;
            				}
            			}
            		}
HXLINE( 113)		countByColor =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 114)		return maxKey;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(CoolUtil_obj,dominantColor,return )

::Array< int > CoolUtil_obj::numberArray(int max, ::Dynamic __o_min){
            		 ::Dynamic min = __o_min;
            		if (::hx::IsNull(__o_min)) min = 0;
            	HX_STACKFRAME(&_hx_pos_2eed4b4541010048_118_numberArray)
HXLINE( 119)		::Array< int > dumbArray = ::Array_obj< int >::__new(0);
HXLINE( 120)		{
HXLINE( 120)			int _g = ( (int)(min) );
HXDLIN( 120)			int _g1 = max;
HXDLIN( 120)			while((_g < _g1)){
HXLINE( 120)				_g = (_g + 1);
HXDLIN( 120)				int i = (_g - 1);
HXDLIN( 120)				dumbArray->push(i);
            			}
            		}
HXLINE( 122)		return dumbArray;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(CoolUtil_obj,numberArray,return )

void CoolUtil_obj::browserLoad(::String site){
            	HX_GC_STACKFRAME(&_hx_pos_2eed4b4541010048_129_browserLoad)
HXDLIN( 129)		::String url = site;
HXDLIN( 129)		if (!( ::EReg_obj::__alloc( HX_CTX ,HX_("^.\\w+?:/*",16,3c,ef,2d),HX_("",00,00,00,00))->match(url))) {
HXDLIN( 129)			url = (HX_("https://",cf,b4,ae,3e) + url);
            		}
HXDLIN( 129)		::openfl::Lib_obj::getURL( ::openfl::net::URLRequest_obj::__alloc( HX_CTX ,url),HX_("_blank",95,26,d9,b0));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(CoolUtil_obj,browserLoad,(void))

void CoolUtil_obj::openFolder(::String folder,::hx::Null< bool >  __o_absolute){
            		bool absolute = __o_absolute.Default(false);
            	HX_STACKFRAME(&_hx_pos_2eed4b4541010048_133_openFolder)
HXLINE( 135)		if (!(absolute)) {
HXLINE( 135)			folder = (::Sys_obj::getCwd() + (HX_("",00,00,00,00) + folder));
            		}
HXLINE( 137)		folder = ::StringTools_obj::replace(folder,HX_("/",2f,00,00,00),HX_("\\",5c,00,00,00));
HXLINE( 138)		if (::StringTools_obj::endsWith(folder,HX_("/",2f,00,00,00))) {
HXLINE( 138)			folder.substr(0,(folder.length - 1));
            		}
HXLINE( 143)		::String command = HX_("explorer.exe",a3,11,12,ed);
HXLINE( 145)		::Sys_obj::command(command,::Array_obj< ::String >::__new(1)->init(0,folder));
HXLINE( 146)		::haxe::Log_obj::trace((((HX_("",00,00,00,00) + command) + HX_(" ",20,00,00,00)) + folder),::hx::SourceInfo(HX_("source/backend/CoolUtil.hx",e4,7b,b9,1b),146,HX_("backend.CoolUtil",25,93,40,42),HX_("openFolder",18,e2,2c,47)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(CoolUtil_obj,openFolder,(void))

::String CoolUtil_obj::getSavePath(){
            	HX_STACKFRAME(&_hx_pos_2eed4b4541010048_162_getSavePath)
HXLINE( 163)		::String company = ::openfl::Lib_obj::get_current()->stage->application->meta->get_string(HX_("company",3d,15,69,83));
HXLINE( 165)		return (((HX_("",00,00,00,00) + company) + HX_("/",2f,00,00,00)) + ::flixel::util::FlxSave_obj::validate(::openfl::Lib_obj::get_current()->stage->application->meta->get_string(HX_("file",7c,ce,bb,43))));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(CoolUtil_obj,getSavePath,return )

void CoolUtil_obj::setTextBorderFromString( ::flixel::text::FlxText text,::String border){
            	HX_STACKFRAME(&_hx_pos_2eed4b4541010048_171_setTextBorderFromString)
HXDLIN( 171)		::String _hx_switch_0 = ::StringTools_obj::trim(border.toLowerCase());
            		if (  (_hx_switch_0==HX_("outline",82,17,be,e1)) ){
HXLINE( 176)			text->set_borderStyle(::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn());
HXDLIN( 176)			goto _hx_goto_20;
            		}
            		if (  (_hx_switch_0==HX_("outline_fast",b9,4f,fa,33)) ||  (_hx_switch_0==HX_("outlinefast",1e,c3,e2,ed)) ){
HXLINE( 178)			text->set_borderStyle(::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn());
HXDLIN( 178)			goto _hx_goto_20;
            		}
            		if (  (_hx_switch_0==HX_("shadow",e0,c7,20,1d)) ){
HXLINE( 174)			text->set_borderStyle(::flixel::text::FlxTextBorderStyle_obj::SHADOW_dyn());
HXDLIN( 174)			goto _hx_goto_20;
            		}
            		/* default */{
HXLINE( 180)			text->set_borderStyle(::flixel::text::FlxTextBorderStyle_obj::NONE_dyn());
            		}
            		_hx_goto_20:;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(CoolUtil_obj,setTextBorderFromString,(void))


CoolUtil_obj::CoolUtil_obj()
{
}

bool CoolUtil_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"quantize") ) { outValue = quantize_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"capitalize") ) { outValue = capitalize_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"openFolder") ) { outValue = openFolder_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"numberArray") ) { outValue = numberArray_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"browserLoad") ) { outValue = browserLoad_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getSavePath") ) { outValue = getSavePath_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"coolTextFile") ) { outValue = coolTextFile_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"floorDecimal") ) { outValue = floorDecimal_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"dominantColor") ) { outValue = dominantColor_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"listFromString") ) { outValue = listFromString_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"checkForUpdates") ) { outValue = checkForUpdates_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"colorFromString") ) { outValue = colorFromString_dyn(); return true; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"setTextBorderFromString") ) { outValue = setTextBorderFromString_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *CoolUtil_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *CoolUtil_obj_sStaticStorageInfo = 0;
#endif

::hx::Class CoolUtil_obj::__mClass;

static ::String CoolUtil_obj_sStaticFields[] = {
	HX_("checkForUpdates",29,6d,49,71),
	HX_("quantize",b1,4c,42,ac),
	HX_("capitalize",ac,09,9c,e1),
	HX_("coolTextFile",b2,09,03,cc),
	HX_("colorFromString",1e,5d,dc,a3),
	HX_("listFromString",d9,af,fe,f5),
	HX_("floorDecimal",25,1c,ad,93),
	HX_("dominantColor",e3,82,71,eb),
	HX_("numberArray",10,1e,18,ad),
	HX_("browserLoad",ee,b5,dc,e9),
	HX_("openFolder",18,e2,2c,47),
	HX_("getSavePath",38,42,ff,23),
	HX_("setTextBorderFromString",76,55,7c,1a),
	::String(null())
};

void CoolUtil_obj::__register()
{
	CoolUtil_obj _hx_dummy;
	CoolUtil_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("backend.CoolUtil",25,93,40,42);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &CoolUtil_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(CoolUtil_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< CoolUtil_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = CoolUtil_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = CoolUtil_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace backend
