// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_Mods
#include <backend/Mods.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_io_Path
#include <haxe/io/Path.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif
#ifndef INCLUDED_tjson_TJSON
#include <tjson/TJSON.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_37_getGlobalMods,"backend.Mods","getGlobalMods",0x282f7527,"backend.Mods.getGlobalMods","backend/Mods.hx",37,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_40_pushGlobalMods,"backend.Mods","pushGlobalMods",0xbafefbd1,"backend.Mods.pushGlobalMods","backend/Mods.hx",40,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_51_getModDirectories,"backend.Mods","getModDirectories",0xf7b0dc9c,"backend.Mods.getModDirectories","backend/Mods.hx",51,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_68_mergeAllTextsNamed,"backend.Mods","mergeAllTextsNamed",0x6b29d5bf,"backend.Mods.mergeAllTextsNamed","backend/Mods.hx",68,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_95_directoriesWithFile,"backend.Mods","directoriesWithFile",0x5a0cfd0a,"backend.Mods.directoriesWithFile","backend/Mods.hx",95,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_135_getPack,"backend.Mods","getPack",0x0de6554c,"backend.Mods.getPack","backend/Mods.hx",135,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_157_parseList,"backend.Mods","parseList",0x838a262e,"backend.Mods.parseList","backend/Mods.hx",157,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_183_updateModList,"backend.Mods","updateModList",0x350647b4,"backend.Mods.updateModList","backend/Mods.hx",183,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_230_loadTopMod,"backend.Mods","loadTopMod",0x40be6756,"backend.Mods.loadTopMod","backend/Mods.hx",230,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_15_boot,"backend.Mods","boot",0x763fcd55,"backend.Mods.boot","backend/Mods.hx",15,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_16_boot,"backend.Mods","boot",0x763fcd55,"backend.Mods.boot","backend/Mods.hx",16,0x628d7792)
static const ::String _hx_array_data_a1baaa2b_29[] = {
	HX_("characters",aa,58,ce,55),HX_("custom_events",27,a1,9e,e1),HX_("custom_notetypes",f9,35,37,af),HX_("data",2a,56,63,42),HX_("songs",fe,36,c7,80),HX_("music",a5,d0,5a,10),HX_("sounds",c4,a8,2e,32),HX_("shaders",ae,81,86,5f),HX_("videos",98,d7,95,e5),HX_("images",b8,50,92,fe),HX_("stages",f5,fb,f1,05),HX_("weeks",ff,95,be,c7),HX_("fonts",c4,b7,91,04),HX_("scripts",08,fc,e3,2c),HX_("achievements",24,a1,6b,86),
};
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_34_boot,"backend.Mods","boot",0x763fcd55,"backend.Mods.boot","backend/Mods.hx",34,0x628d7792)
HX_LOCAL_STACK_FRAME(_hx_pos_9e01c1b3771b993c_156_boot,"backend.Mods","boot",0x763fcd55,"backend.Mods.boot","backend/Mods.hx",156,0x628d7792)
namespace backend{

void Mods_obj::__construct() { }

Dynamic Mods_obj::__CreateEmpty() { return new Mods_obj; }

void *Mods_obj::_hx_vtable = 0;

Dynamic Mods_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Mods_obj > _hx_result = new Mods_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Mods_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x51ebbac1;
}

::String Mods_obj::currentModDirectory;

::Array< ::String > Mods_obj::ignoreModFolders;

::Array< ::String > Mods_obj::globalMods;

::Array< ::String > Mods_obj::getGlobalMods(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_37_getGlobalMods)
HXDLIN(  37)		return ::backend::Mods_obj::globalMods;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,getGlobalMods,return )

::Array< ::String > Mods_obj::pushGlobalMods(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_40_pushGlobalMods)
HXLINE(  41)		::backend::Mods_obj::globalMods = ::Array_obj< ::String >::__new(0);
HXLINE(  42)		{
HXLINE(  42)			int _g = 0;
HXDLIN(  42)			if (!(::backend::Mods_obj::updatedOnState)) {
HXLINE(  42)				::backend::Mods_obj::updateModList();
            			}
HXDLIN(  42)			::Array< ::String > list_enabled = ::Array_obj< ::String >::__new(0);
HXDLIN(  42)			::Array< ::String > list_disabled = ::Array_obj< ::String >::__new(0);
HXDLIN(  42)			::Array< ::String > list_all = ::Array_obj< ::String >::__new(0);
HXDLIN(  42)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  42)				int _g1 = 0;
HXDLIN(  42)				::String daList = null();
HXDLIN(  42)				if (::sys::FileSystem_obj::exists(HX_("modsList.txt",f1,ca,08,ac))) {
HXLINE(  48)					daList = ::sys::io::File_obj::getContent(HX_("modsList.txt",f1,ca,08,ac));
            				}
HXLINE(  42)				::Array< ::String > _g2;
HXDLIN(  42)				if (::hx::IsNotNull( daList )) {
HXLINE(  42)					::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXLINE(  69)					daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXLINE(  42)					{
HXLINE(  42)						int _g3 = 0;
HXDLIN(  42)						int _g4 = daList1->length;
HXDLIN(  42)						while((_g3 < _g4)){
HXLINE(  42)							_g3 = (_g3 + 1);
HXDLIN(  42)							int i = (_g3 - 1);
HXDLIN(  42)							daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            						}
            					}
HXDLIN(  42)					_g2 = daList1;
            				}
            				else {
HXLINE(  42)					_g2 = ::Array_obj< ::String >::__new(0);
            				}
HXDLIN(  42)				while((_g1 < _g2->length)){
HXLINE(  42)					::String mod = _g2->__get(_g1);
HXDLIN(  42)					_g1 = (_g1 + 1);
HXDLIN(  42)					if ((::StringTools_obj::trim(mod).length < 1)) {
HXLINE(  42)						continue;
            					}
HXDLIN(  42)					::Array< ::String > dat = mod.split(HX_("|",7c,00,00,00));
HXDLIN(  42)					list_all->push(dat->__get(0));
HXDLIN(  42)					if ((dat->__get(1) == HX_("1",31,00,00,00))) {
HXLINE(  42)						list_enabled->push(dat->__get(0));
            					}
            					else {
HXLINE(  42)						list_disabled->push(dat->__get(0));
            					}
            				}
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g5 = _hx_e;
HXLINE( 175)					 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g5);
HXLINE(  42)					::haxe::Log_obj::trace(e,::hx::SourceInfo(HX_("source/backend/Mods.hx",1e,5b,8b,ff),176,HX_("backend.Mods",2b,aa,ba,a1),HX_("parseList",31,6e,59,cf)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
HXDLIN(  42)			::Array< ::String > _g6 = list_enabled;
HXDLIN(  42)			while((_g < _g6->length)){
HXLINE(  42)				::String mod1 = _g6->__get(_g);
HXDLIN(  42)				_g = (_g + 1);
HXLINE(  44)				 ::Dynamic pack = ::backend::Mods_obj::getPack(mod1);
HXLINE(  45)				bool _hx_tmp;
HXDLIN(  45)				if (::hx::IsNotNull( pack )) {
HXLINE(  45)					_hx_tmp = ( (bool)(pack->__Field(HX_("runsGlobally",98,2d,b5,06),::hx::paccDynamic)) );
            				}
            				else {
HXLINE(  45)					_hx_tmp = false;
            				}
HXDLIN(  45)				if (_hx_tmp) {
HXLINE(  45)					::backend::Mods_obj::globalMods->push(mod1);
            				}
            			}
            		}
HXLINE(  47)		return ::backend::Mods_obj::globalMods;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,pushGlobalMods,return )

::Array< ::String > Mods_obj::getModDirectories(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_51_getModDirectories)
HXLINE(  52)		::Array< ::String > list = ::Array_obj< ::String >::__new(0);
HXLINE(  54)		::String modsFolder = HX_("mods/",9e,2f,58,0c);
HXLINE(  55)		if (::sys::FileSystem_obj::exists(modsFolder)) {
HXLINE(  56)			int _g = 0;
HXDLIN(  56)			::Array< ::String > _g1 = ::sys::FileSystem_obj::readDirectory(modsFolder);
HXDLIN(  56)			while((_g < _g1->length)){
HXLINE(  56)				::String folder = _g1->__get(_g);
HXDLIN(  56)				_g = (_g + 1);
HXLINE(  58)				::String path = ::haxe::io::Path_obj::join(::Array_obj< ::String >::__new(2)->init(0,modsFolder)->init(1,folder));
HXLINE(  59)				bool _hx_tmp;
HXDLIN(  59)				bool _hx_tmp1;
HXDLIN(  59)				if (::sys::FileSystem_obj::isDirectory(path)) {
HXLINE(  59)					_hx_tmp1 = !(::backend::Mods_obj::ignoreModFolders->contains(folder.toLowerCase()));
            				}
            				else {
HXLINE(  59)					_hx_tmp1 = false;
            				}
HXDLIN(  59)				if (_hx_tmp1) {
HXLINE(  59)					_hx_tmp = !(list->contains(folder));
            				}
            				else {
HXLINE(  59)					_hx_tmp = false;
            				}
HXDLIN(  59)				if (_hx_tmp) {
HXLINE(  60)					list->push(folder);
            				}
            			}
            		}
HXLINE(  64)		return list;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,getModDirectories,return )

::Array< ::String > Mods_obj::mergeAllTextsNamed(::String path,::String defaultDirectory,::hx::Null< bool >  __o_allowDuplicates){
            		bool allowDuplicates = __o_allowDuplicates.Default(false);
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_68_mergeAllTextsNamed)
HXLINE(  69)		if (::hx::IsNull( defaultDirectory )) {
HXLINE(  69)			defaultDirectory = HX_("assets/shared/",1e,69,1e,47);
            		}
HXLINE(  70)		defaultDirectory = ::StringTools_obj::trim(defaultDirectory);
HXLINE(  71)		if (!(::StringTools_obj::endsWith(defaultDirectory,HX_("/",2f,00,00,00)))) {
HXLINE(  71)			defaultDirectory = (defaultDirectory + HX_("/",2f,00,00,00));
            		}
HXLINE(  72)		if (!(::StringTools_obj::startsWith(defaultDirectory,HX_("assets/",4c,2a,dc,36)))) {
HXLINE(  72)			defaultDirectory = (HX_("assets/",4c,2a,dc,36) + defaultDirectory);
            		}
HXLINE(  74)		::Array< ::String > mergedList = ::Array_obj< ::String >::__new(0);
HXLINE(  75)		::Array< ::String > foldersToCheck = ::Array_obj< ::String >::__new(0);
HXDLIN(  75)		if (::sys::FileSystem_obj::exists((defaultDirectory + path))) {
HXLINE(  75)			foldersToCheck->push((defaultDirectory + path));
            		}
HXDLIN(  75)		bool _hx_tmp;
HXDLIN(  75)		if (::hx::IsNotNull( ::backend::Paths_obj::currentLevel )) {
HXLINE(  75)			_hx_tmp = (::backend::Paths_obj::currentLevel != defaultDirectory);
            		}
            		else {
HXLINE(  75)			_hx_tmp = false;
            		}
HXDLIN(  75)		if (_hx_tmp) {
HXLINE(  75)			::String folder = ::backend::Paths_obj::currentLevel;
HXDLIN(  75)			if (::hx::IsNull( folder )) {
HXLINE(  75)				folder = HX_("shared",a5,5e,2b,1d);
            			}
HXDLIN(  75)			::String pth = (((HX_("assets/",4c,2a,dc,36) + folder) + HX_("/",2f,00,00,00)) + path);
HXDLIN(  75)			bool _hx_tmp1;
HXDLIN(  75)			if (!(foldersToCheck->contains(pth))) {
HXLINE(  75)				_hx_tmp1 = ::sys::FileSystem_obj::exists(pth);
            			}
            			else {
HXLINE(  75)				_hx_tmp1 = false;
            			}
HXDLIN(  75)			if (_hx_tmp1) {
HXLINE(  75)				foldersToCheck->push(pth);
            			}
            		}
HXDLIN(  75)		{
HXLINE(  75)			{
HXLINE(  75)				int _g = 0;
HXDLIN(  75)				::Array< ::String > _g1 = ::backend::Mods_obj::globalMods;
HXDLIN(  75)				while((_g < _g1->length)){
HXLINE(  75)					::String mod = _g1->__get(_g);
HXDLIN(  75)					_g = (_g + 1);
HXDLIN(  75)					::String key = ((mod + HX_("/",2f,00,00,00)) + path);
HXDLIN(  75)					if (::hx::IsNull( key )) {
HXLINE(  75)						key = HX_("",00,00,00,00);
            					}
HXDLIN(  75)					::String folder1 = (HX_("mods/",9e,2f,58,0c) + key);
HXDLIN(  75)					bool _hx_tmp2;
HXDLIN(  75)					if (::sys::FileSystem_obj::exists(folder1)) {
HXLINE(  75)						_hx_tmp2 = !(foldersToCheck->contains(folder1));
            					}
            					else {
HXLINE(  75)						_hx_tmp2 = false;
            					}
HXDLIN(  75)					if (_hx_tmp2) {
HXLINE(  75)						foldersToCheck->push(folder1);
            					}
            				}
            			}
HXDLIN(  75)			::String key1 = path;
HXDLIN(  75)			if (::hx::IsNull( key1 )) {
HXLINE(  75)				key1 = HX_("",00,00,00,00);
            			}
HXDLIN(  75)			::String folder2 = (HX_("mods/",9e,2f,58,0c) + key1);
HXDLIN(  75)			bool _hx_tmp3;
HXDLIN(  75)			if (::sys::FileSystem_obj::exists(folder2)) {
HXLINE(  75)				_hx_tmp3 = !(foldersToCheck->contains(folder2));
            			}
            			else {
HXLINE(  75)				_hx_tmp3 = false;
            			}
HXDLIN(  75)			if (_hx_tmp3) {
HXLINE(  75)				::String key2 = path;
HXDLIN(  75)				if (::hx::IsNull( key2 )) {
HXLINE(  75)					key2 = HX_("",00,00,00,00);
            				}
HXDLIN(  75)				foldersToCheck->push((HX_("mods/",9e,2f,58,0c) + key2));
            			}
HXDLIN(  75)			bool _hx_tmp4;
HXDLIN(  75)			if (::hx::IsNotNull( ::backend::Mods_obj::currentModDirectory )) {
HXLINE(  75)				_hx_tmp4 = (::backend::Mods_obj::currentModDirectory.length > 0);
            			}
            			else {
HXLINE(  75)				_hx_tmp4 = false;
            			}
HXDLIN(  75)			if (_hx_tmp4) {
HXLINE(  75)				::String key3 = ((::backend::Mods_obj::currentModDirectory + HX_("/",2f,00,00,00)) + path);
HXDLIN(  75)				if (::hx::IsNull( key3 )) {
HXLINE(  75)					key3 = HX_("",00,00,00,00);
            				}
HXDLIN(  75)				::String folder3 = (HX_("mods/",9e,2f,58,0c) + key3);
HXDLIN(  75)				bool _hx_tmp5;
HXDLIN(  75)				if (::sys::FileSystem_obj::exists(folder3)) {
HXLINE(  75)					_hx_tmp5 = !(foldersToCheck->contains(folder3));
            				}
            				else {
HXLINE(  75)					_hx_tmp5 = false;
            				}
HXDLIN(  75)				if (_hx_tmp5) {
HXLINE(  75)					foldersToCheck->push(folder3);
            				}
            			}
            		}
HXDLIN(  75)		::Array< ::String > paths = foldersToCheck;
HXLINE(  77)		::String defaultPath = (defaultDirectory + path);
HXLINE(  78)		if (paths->contains(defaultPath)) {
HXLINE(  80)			paths->remove(defaultPath);
HXLINE(  81)			paths->insert(0,defaultPath);
            		}
HXLINE(  84)		{
HXLINE(  84)			int _g2 = 0;
HXDLIN(  84)			while((_g2 < paths->length)){
HXLINE(  84)				::String file = paths->__get(_g2);
HXDLIN(  84)				_g2 = (_g2 + 1);
HXLINE(  86)				::String daList = null();
HXDLIN(  86)				if (::sys::FileSystem_obj::exists(file)) {
HXLINE(  86)					daList = ::sys::io::File_obj::getContent(file);
            				}
HXDLIN(  86)				::Array< ::String > list;
HXDLIN(  86)				if (::hx::IsNotNull( daList )) {
HXLINE(  86)					::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXDLIN(  86)					daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXDLIN(  86)					{
HXLINE(  86)						int _g3 = 0;
HXDLIN(  86)						int _g4 = daList1->length;
HXDLIN(  86)						while((_g3 < _g4)){
HXLINE(  86)							_g3 = (_g3 + 1);
HXDLIN(  86)							int i = (_g3 - 1);
HXDLIN(  86)							daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            						}
            					}
HXDLIN(  86)					list = daList1;
            				}
            				else {
HXLINE(  86)					list = ::Array_obj< ::String >::__new(0);
            				}
HXLINE(  87)				{
HXLINE(  87)					int _g5 = 0;
HXDLIN(  87)					while((_g5 < list->length)){
HXLINE(  87)						::String value = list->__get(_g5);
HXDLIN(  87)						_g5 = (_g5 + 1);
HXLINE(  88)						bool _hx_tmp6;
HXDLIN(  88)						bool _hx_tmp7;
HXDLIN(  88)						if (!(allowDuplicates)) {
HXLINE(  88)							_hx_tmp7 = !(mergedList->contains(value));
            						}
            						else {
HXLINE(  88)							_hx_tmp7 = true;
            						}
HXDLIN(  88)						if (_hx_tmp7) {
HXLINE(  88)							_hx_tmp6 = (value.length > 0);
            						}
            						else {
HXLINE(  88)							_hx_tmp6 = false;
            						}
HXDLIN(  88)						if (_hx_tmp6) {
HXLINE(  89)							mergedList->push(value);
            						}
            					}
            				}
            			}
            		}
HXLINE(  91)		return mergedList;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Mods_obj,mergeAllTextsNamed,return )

::Array< ::String > Mods_obj::directoriesWithFile(::String path,::String fileToFind,::hx::Null< bool >  __o_mods){
            		bool mods = __o_mods.Default(true);
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_95_directoriesWithFile)
HXLINE(  96)		::Array< ::String > foldersToCheck = ::Array_obj< ::String >::__new(0);
HXLINE(  98)		if (::sys::FileSystem_obj::exists((path + fileToFind))) {
HXLINE(  99)			foldersToCheck->push((path + fileToFind));
            		}
HXLINE( 102)		bool _hx_tmp;
HXDLIN( 102)		if (::hx::IsNotNull( ::backend::Paths_obj::currentLevel )) {
HXLINE( 102)			_hx_tmp = (::backend::Paths_obj::currentLevel != path);
            		}
            		else {
HXLINE( 102)			_hx_tmp = false;
            		}
HXDLIN( 102)		if (_hx_tmp) {
HXLINE( 104)			::String folder = ::backend::Paths_obj::currentLevel;
HXDLIN( 104)			if (::hx::IsNull( folder )) {
HXLINE( 104)				folder = HX_("shared",a5,5e,2b,1d);
            			}
HXDLIN( 104)			::String pth = (((HX_("assets/",4c,2a,dc,36) + folder) + HX_("/",2f,00,00,00)) + fileToFind);
HXLINE( 105)			bool _hx_tmp1;
HXDLIN( 105)			if (!(foldersToCheck->contains(pth))) {
HXLINE( 105)				_hx_tmp1 = ::sys::FileSystem_obj::exists(pth);
            			}
            			else {
HXLINE( 105)				_hx_tmp1 = false;
            			}
HXDLIN( 105)			if (_hx_tmp1) {
HXLINE( 106)				foldersToCheck->push(pth);
            			}
            		}
HXLINE( 110)		if (mods) {
HXLINE( 113)			{
HXLINE( 113)				int _g = 0;
HXDLIN( 113)				::Array< ::String > _g1 = ::backend::Mods_obj::globalMods;
HXDLIN( 113)				while((_g < _g1->length)){
HXLINE( 113)					::String mod = _g1->__get(_g);
HXDLIN( 113)					_g = (_g + 1);
HXLINE( 115)					::String key = ((mod + HX_("/",2f,00,00,00)) + fileToFind);
HXDLIN( 115)					if (::hx::IsNull( key )) {
HXLINE( 115)						key = HX_("",00,00,00,00);
            					}
HXDLIN( 115)					::String folder1 = (HX_("mods/",9e,2f,58,0c) + key);
HXLINE( 116)					bool _hx_tmp2;
HXDLIN( 116)					if (::sys::FileSystem_obj::exists(folder1)) {
HXLINE( 116)						_hx_tmp2 = !(foldersToCheck->contains(folder1));
            					}
            					else {
HXLINE( 116)						_hx_tmp2 = false;
            					}
HXDLIN( 116)					if (_hx_tmp2) {
HXLINE( 116)						foldersToCheck->push(folder1);
            					}
            				}
            			}
HXLINE( 120)			::String key1 = fileToFind;
HXDLIN( 120)			if (::hx::IsNull( key1 )) {
HXLINE( 120)				key1 = HX_("",00,00,00,00);
            			}
HXDLIN( 120)			::String folder2 = (HX_("mods/",9e,2f,58,0c) + key1);
HXLINE( 121)			bool _hx_tmp3;
HXDLIN( 121)			if (::sys::FileSystem_obj::exists(folder2)) {
HXLINE( 121)				_hx_tmp3 = !(foldersToCheck->contains(folder2));
            			}
            			else {
HXLINE( 121)				_hx_tmp3 = false;
            			}
HXDLIN( 121)			if (_hx_tmp3) {
HXLINE( 121)				::String key2 = fileToFind;
HXDLIN( 121)				if (::hx::IsNull( key2 )) {
HXLINE( 121)					key2 = HX_("",00,00,00,00);
            				}
HXDLIN( 121)				foldersToCheck->push((HX_("mods/",9e,2f,58,0c) + key2));
            			}
HXLINE( 124)			bool _hx_tmp4;
HXDLIN( 124)			if (::hx::IsNotNull( ::backend::Mods_obj::currentModDirectory )) {
HXLINE( 124)				_hx_tmp4 = (::backend::Mods_obj::currentModDirectory.length > 0);
            			}
            			else {
HXLINE( 124)				_hx_tmp4 = false;
            			}
HXDLIN( 124)			if (_hx_tmp4) {
HXLINE( 126)				::String key3 = ((::backend::Mods_obj::currentModDirectory + HX_("/",2f,00,00,00)) + fileToFind);
HXDLIN( 126)				if (::hx::IsNull( key3 )) {
HXLINE( 126)					key3 = HX_("",00,00,00,00);
            				}
HXDLIN( 126)				::String folder3 = (HX_("mods/",9e,2f,58,0c) + key3);
HXLINE( 127)				bool _hx_tmp5;
HXDLIN( 127)				if (::sys::FileSystem_obj::exists(folder3)) {
HXLINE( 127)					_hx_tmp5 = !(foldersToCheck->contains(folder3));
            				}
            				else {
HXLINE( 127)					_hx_tmp5 = false;
            				}
HXDLIN( 127)				if (_hx_tmp5) {
HXLINE( 127)					foldersToCheck->push(folder3);
            				}
            			}
            		}
HXLINE( 131)		return foldersToCheck;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Mods_obj,directoriesWithFile,return )

 ::Dynamic Mods_obj::getPack(::String folder){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_135_getPack)
HXLINE( 137)		if (::hx::IsNull( folder )) {
HXLINE( 137)			folder = ::backend::Mods_obj::currentModDirectory;
            		}
HXLINE( 139)		::String key = (folder + HX_("/pack.json",ce,a9,3a,e3));
HXDLIN( 139)		if (::hx::IsNull( key )) {
HXLINE( 139)			key = HX_("",00,00,00,00);
            		}
HXDLIN( 139)		::String path = (HX_("mods/",9e,2f,58,0c) + key);
HXLINE( 140)		if (::sys::FileSystem_obj::exists(path)) {
HXLINE( 141)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 143)				::String rawJson = ::sys::io::File_obj::getContent(path);
HXLINE( 147)				bool _hx_tmp;
HXDLIN( 147)				if (::hx::IsNotNull( rawJson )) {
HXLINE( 147)					_hx_tmp = (rawJson.length > 0);
            				}
            				else {
HXLINE( 147)					_hx_tmp = false;
            				}
HXDLIN( 147)				if (_hx_tmp) {
HXLINE( 147)					return ::tjson::TJSON_obj::parse(rawJson,null(),null());
            				}
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g = _hx_e;
HXLINE( 148)					{
HXLINE( 148)						null();
            					}
HXDLIN( 148)					 ::Dynamic e = _g;
HXLINE( 149)					::haxe::Log_obj::trace(e,::hx::SourceInfo(HX_("source/backend/Mods.hx",1e,5b,8b,ff),149,HX_("backend.Mods",2b,aa,ba,a1),HX_("getPack",8f,86,d4,1c)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
            		}
HXLINE( 153)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Mods_obj,getPack,return )

bool Mods_obj::updatedOnState;

 ::Dynamic Mods_obj::parseList(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_157_parseList)
HXLINE( 158)		if (!(::backend::Mods_obj::updatedOnState)) {
HXLINE( 158)			::backend::Mods_obj::updateModList();
            		}
HXLINE( 159)		 ::Dynamic list =  ::Dynamic(::hx::Anon_obj::Create(3)
            			->setFixed(0,HX_("all",21,f9,49,00),::Array_obj< ::String >::__new(0))
            			->setFixed(1,HX_("disabled",7c,41,04,7c),::Array_obj< ::String >::__new(0))
            			->setFixed(2,HX_("enabled",81,04,31,7e),::Array_obj< ::String >::__new(0)));
HXLINE( 162)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 163)			int _g = 0;
HXDLIN( 163)			::String daList = null();
HXDLIN( 163)			if (::sys::FileSystem_obj::exists(HX_("modsList.txt",f1,ca,08,ac))) {
HXLINE( 163)				daList = ::sys::io::File_obj::getContent(HX_("modsList.txt",f1,ca,08,ac));
            			}
HXDLIN( 163)			::Array< ::String > _g1;
HXDLIN( 163)			if (::hx::IsNotNull( daList )) {
HXLINE( 163)				::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXDLIN( 163)				daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXDLIN( 163)				{
HXLINE( 163)					int _g2 = 0;
HXDLIN( 163)					int _g3 = daList1->length;
HXDLIN( 163)					while((_g2 < _g3)){
HXLINE( 163)						_g2 = (_g2 + 1);
HXDLIN( 163)						int i = (_g2 - 1);
HXDLIN( 163)						daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            					}
            				}
HXDLIN( 163)				_g1 = daList1;
            			}
            			else {
HXLINE( 163)				_g1 = ::Array_obj< ::String >::__new(0);
            			}
HXDLIN( 163)			while((_g < _g1->length)){
HXLINE( 163)				::String mod = _g1->__get(_g);
HXDLIN( 163)				_g = (_g + 1);
HXLINE( 166)				if ((::StringTools_obj::trim(mod).length < 1)) {
HXLINE( 166)					continue;
            				}
HXLINE( 168)				::Array< ::String > dat = mod.split(HX_("|",7c,00,00,00));
HXLINE( 169)				( (::Array< ::String >)(list->__Field(HX_("all",21,f9,49,00),::hx::paccDynamic)) )->push(dat->__get(0));
HXLINE( 170)				if ((dat->__get(1) == HX_("1",31,00,00,00))) {
HXLINE( 171)					( (::Array< ::String >)(list->__Field(HX_("enabled",81,04,31,7e),::hx::paccDynamic)) )->push(dat->__get(0));
            				}
            				else {
HXLINE( 173)					( (::Array< ::String >)(list->__Field(HX_("disabled",7c,41,04,7c),::hx::paccDynamic)) )->push(dat->__get(0));
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g4 = _hx_e;
HXLINE( 175)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g4);
HXLINE( 176)				::haxe::Log_obj::trace(e,::hx::SourceInfo(HX_("source/backend/Mods.hx",1e,5b,8b,ff),176,HX_("backend.Mods",2b,aa,ba,a1),HX_("parseList",31,6e,59,cf)));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 179)		return list;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,parseList,return )

void Mods_obj::updateModList(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_183_updateModList)
HXLINE( 186)		::Array< ::Dynamic> list = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 187)		::Array< ::String > added = ::Array_obj< ::String >::__new(0);
HXLINE( 188)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 189)			int _g = 0;
HXDLIN( 189)			::String daList = null();
HXDLIN( 189)			if (::sys::FileSystem_obj::exists(HX_("modsList.txt",f1,ca,08,ac))) {
HXLINE( 189)				daList = ::sys::io::File_obj::getContent(HX_("modsList.txt",f1,ca,08,ac));
            			}
HXDLIN( 189)			::Array< ::String > _g1;
HXDLIN( 189)			if (::hx::IsNotNull( daList )) {
HXLINE( 189)				::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXDLIN( 189)				daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXDLIN( 189)				{
HXLINE( 189)					int _g2 = 0;
HXDLIN( 189)					int _g3 = daList1->length;
HXDLIN( 189)					while((_g2 < _g3)){
HXLINE( 189)						_g2 = (_g2 + 1);
HXDLIN( 189)						int i = (_g2 - 1);
HXDLIN( 189)						daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            					}
            				}
HXDLIN( 189)				_g1 = daList1;
            			}
            			else {
HXLINE( 189)				_g1 = ::Array_obj< ::String >::__new(0);
            			}
HXDLIN( 189)			while((_g < _g1->length)){
HXLINE( 189)				::String mod = _g1->__get(_g);
HXDLIN( 189)				_g = (_g + 1);
HXLINE( 191)				::Array< ::String > dat = mod.split(HX_("|",7c,00,00,00));
HXLINE( 192)				::String folder = dat->__get(0);
HXLINE( 193)				bool _hx_tmp;
HXDLIN( 193)				bool _hx_tmp1;
HXDLIN( 193)				bool _hx_tmp2;
HXDLIN( 193)				if ((::StringTools_obj::trim(folder).length > 0)) {
HXLINE( 193)					::String key = folder;
HXDLIN( 193)					if (::hx::IsNull( key )) {
HXLINE( 193)						key = HX_("",00,00,00,00);
            					}
HXDLIN( 193)					_hx_tmp2 = ::sys::FileSystem_obj::exists((HX_("mods/",9e,2f,58,0c) + key));
            				}
            				else {
HXLINE( 193)					_hx_tmp2 = false;
            				}
HXDLIN( 193)				if (_hx_tmp2) {
HXLINE( 193)					::String key1 = folder;
HXDLIN( 193)					if (::hx::IsNull( key1 )) {
HXLINE( 193)						key1 = HX_("",00,00,00,00);
            					}
HXDLIN( 193)					_hx_tmp1 = ::sys::FileSystem_obj::isDirectory((HX_("mods/",9e,2f,58,0c) + key1));
            				}
            				else {
HXLINE( 193)					_hx_tmp1 = false;
            				}
HXDLIN( 193)				if (_hx_tmp1) {
HXLINE( 193)					_hx_tmp = !(added->contains(folder));
            				}
            				else {
HXLINE( 193)					_hx_tmp = false;
            				}
HXDLIN( 193)				if (_hx_tmp) {
HXLINE( 195)					added->push(folder);
HXLINE( 196)					list->push(::cpp::VirtualArray_obj::__new(2)->init(0,folder)->init(1,(dat->__get(1) == HX_("1",31,00,00,00))));
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g4 = _hx_e;
HXLINE( 199)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g4);
HXLINE( 200)				::haxe::Log_obj::trace(e,::hx::SourceInfo(HX_("source/backend/Mods.hx",1e,5b,8b,ff),200,HX_("backend.Mods",2b,aa,ba,a1),HX_("updateModList",37,4d,4d,a8)));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 204)		{
HXLINE( 204)			int _g5 = 0;
HXDLIN( 204)			::Array< ::String > list1 = ::Array_obj< ::String >::__new(0);
HXDLIN( 204)			::String modsFolder = HX_("mods/",9e,2f,58,0c);
HXDLIN( 204)			if (::sys::FileSystem_obj::exists(modsFolder)) {
HXLINE( 204)				int _g6 = 0;
HXDLIN( 204)				::Array< ::String > _g7 = ::sys::FileSystem_obj::readDirectory(modsFolder);
HXDLIN( 204)				while((_g6 < _g7->length)){
HXLINE( 204)					::String folder1 = _g7->__get(_g6);
HXDLIN( 204)					_g6 = (_g6 + 1);
HXDLIN( 204)					::String path = ::haxe::io::Path_obj::join(::Array_obj< ::String >::__new(2)->init(0,modsFolder)->init(1,folder1));
HXDLIN( 204)					bool _hx_tmp3;
HXDLIN( 204)					bool _hx_tmp4;
HXDLIN( 204)					if (::sys::FileSystem_obj::isDirectory(path)) {
HXLINE( 204)						_hx_tmp4 = !(::backend::Mods_obj::ignoreModFolders->contains(folder1.toLowerCase()));
            					}
            					else {
HXLINE( 204)						_hx_tmp4 = false;
            					}
HXDLIN( 204)					if (_hx_tmp4) {
HXLINE( 204)						_hx_tmp3 = !(list1->contains(folder1));
            					}
            					else {
HXLINE( 204)						_hx_tmp3 = false;
            					}
HXDLIN( 204)					if (_hx_tmp3) {
HXLINE( 204)						list1->push(folder1);
            					}
            				}
            			}
HXDLIN( 204)			::Array< ::String > _g8 = list1;
HXDLIN( 204)			while((_g5 < _g8->length)){
HXLINE( 204)				::String folder2 = _g8->__get(_g5);
HXDLIN( 204)				_g5 = (_g5 + 1);
HXLINE( 206)				bool _hx_tmp5;
HXDLIN( 206)				bool _hx_tmp6;
HXDLIN( 206)				bool _hx_tmp7;
HXDLIN( 206)				bool _hx_tmp8;
HXDLIN( 206)				if ((::StringTools_obj::trim(folder2).length > 0)) {
HXLINE( 206)					::String key2 = folder2;
HXDLIN( 206)					if (::hx::IsNull( key2 )) {
HXLINE( 206)						key2 = HX_("",00,00,00,00);
            					}
HXDLIN( 206)					_hx_tmp8 = ::sys::FileSystem_obj::exists((HX_("mods/",9e,2f,58,0c) + key2));
            				}
            				else {
HXLINE( 206)					_hx_tmp8 = false;
            				}
HXDLIN( 206)				if (_hx_tmp8) {
HXLINE( 206)					::String key3 = folder2;
HXDLIN( 206)					if (::hx::IsNull( key3 )) {
HXLINE( 206)						key3 = HX_("",00,00,00,00);
            					}
HXDLIN( 206)					_hx_tmp7 = ::sys::FileSystem_obj::isDirectory((HX_("mods/",9e,2f,58,0c) + key3));
            				}
            				else {
HXLINE( 206)					_hx_tmp7 = false;
            				}
HXDLIN( 206)				if (_hx_tmp7) {
HXLINE( 206)					_hx_tmp6 = !(::backend::Mods_obj::ignoreModFolders->contains(folder2.toLowerCase()));
            				}
            				else {
HXLINE( 206)					_hx_tmp6 = false;
            				}
HXDLIN( 206)				if (_hx_tmp6) {
HXLINE( 206)					_hx_tmp5 = !(added->contains(folder2));
            				}
            				else {
HXLINE( 206)					_hx_tmp5 = false;
            				}
HXDLIN( 206)				if (_hx_tmp5) {
HXLINE( 209)					added->push(folder2);
HXLINE( 210)					list->push(::cpp::VirtualArray_obj::__new(2)->init(0,folder2)->init(1,true));
            				}
            			}
            		}
HXLINE( 216)		::String fileStr = HX_("",00,00,00,00);
HXLINE( 217)		{
HXLINE( 217)			int _g9 = 0;
HXDLIN( 217)			while((_g9 < list->length)){
HXLINE( 217)				::cpp::VirtualArray values = ::cpp::VirtualArray( list->__get(_g9));
HXDLIN( 217)				_g9 = (_g9 + 1);
HXLINE( 219)				if ((fileStr.length > 0)) {
HXLINE( 219)					fileStr = (fileStr + HX_("\n",0a,00,00,00));
            				}
HXLINE( 220)				::String fileStr1 = (::Std_obj::string(values->__get(0)) + HX_("|",7c,00,00,00));
HXDLIN( 220)				::String fileStr2;
HXDLIN( 220)				if (( (bool)(values->__get(1)) )) {
HXLINE( 220)					fileStr2 = HX_("1",31,00,00,00);
            				}
            				else {
HXLINE( 220)					fileStr2 = HX_("0",30,00,00,00);
            				}
HXDLIN( 220)				fileStr = (fileStr + (fileStr1 + fileStr2));
            			}
            		}
HXLINE( 223)		::sys::io::File_obj::saveContent(HX_("modsList.txt",f1,ca,08,ac),fileStr);
HXLINE( 224)		::backend::Mods_obj::updatedOnState = true;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,updateModList,(void))

void Mods_obj::loadTopMod(){
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_230_loadTopMod)
HXLINE( 231)		::backend::Mods_obj::currentModDirectory = HX_("",00,00,00,00);
HXLINE( 234)		if (!(::backend::Mods_obj::updatedOnState)) {
HXLINE( 234)			::backend::Mods_obj::updateModList();
            		}
HXDLIN( 234)		::Array< ::String > list_enabled = ::Array_obj< ::String >::__new(0);
HXDLIN( 234)		::Array< ::String > list_disabled = ::Array_obj< ::String >::__new(0);
HXDLIN( 234)		::Array< ::String > list_all = ::Array_obj< ::String >::__new(0);
HXDLIN( 234)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 234)			int _g = 0;
HXDLIN( 234)			::String daList = null();
HXDLIN( 234)			if (::sys::FileSystem_obj::exists(HX_("modsList.txt",f1,ca,08,ac))) {
HXLINE(  48)				daList = ::sys::io::File_obj::getContent(HX_("modsList.txt",f1,ca,08,ac));
            			}
HXLINE( 234)			::Array< ::String > _g1;
HXDLIN( 234)			if (::hx::IsNotNull( daList )) {
HXLINE( 234)				::Array< ::String > daList1 = ::Array_obj< ::String >::__new(0);
HXLINE(  69)				daList1 = ::StringTools_obj::trim(daList).split(HX_("\n",0a,00,00,00));
HXLINE( 234)				{
HXLINE( 234)					int _g2 = 0;
HXDLIN( 234)					int _g3 = daList1->length;
HXDLIN( 234)					while((_g2 < _g3)){
HXLINE( 234)						_g2 = (_g2 + 1);
HXDLIN( 234)						int i = (_g2 - 1);
HXDLIN( 234)						daList1[i] = ::StringTools_obj::trim(daList1->__get(i));
            					}
            				}
HXDLIN( 234)				_g1 = daList1;
            			}
            			else {
HXLINE( 234)				_g1 = ::Array_obj< ::String >::__new(0);
            			}
HXDLIN( 234)			while((_g < _g1->length)){
HXLINE( 234)				::String mod = _g1->__get(_g);
HXDLIN( 234)				_g = (_g + 1);
HXDLIN( 234)				if ((::StringTools_obj::trim(mod).length < 1)) {
HXLINE( 234)					continue;
            				}
HXDLIN( 234)				::Array< ::String > dat = mod.split(HX_("|",7c,00,00,00));
HXDLIN( 234)				list_all->push(dat->__get(0));
HXDLIN( 234)				if ((dat->__get(1) == HX_("1",31,00,00,00))) {
HXLINE( 234)					list_enabled->push(dat->__get(0));
            				}
            				else {
HXLINE( 234)					list_disabled->push(dat->__get(0));
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g4 = _hx_e;
HXLINE( 175)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g4);
HXLINE( 234)				::haxe::Log_obj::trace(e,::hx::SourceInfo(HX_("source/backend/Mods.hx",1e,5b,8b,ff),176,HX_("backend.Mods",2b,aa,ba,a1),HX_("parseList",31,6e,59,cf)));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXDLIN( 234)		::Array< ::String > list = list_enabled;
HXLINE( 235)		bool _hx_tmp;
HXDLIN( 235)		if (::hx::IsNotNull( list )) {
HXLINE( 235)			_hx_tmp = ::hx::IsNotNull( list->__get(0) );
            		}
            		else {
HXLINE( 235)			_hx_tmp = false;
            		}
HXDLIN( 235)		if (_hx_tmp) {
HXLINE( 236)			::backend::Mods_obj::currentModDirectory = list->__get(0);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Mods_obj,loadTopMod,(void))


Mods_obj::Mods_obj()
{
}

bool Mods_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"getPack") ) { outValue = getPack_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"parseList") ) { outValue = parseList_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"globalMods") ) { outValue = ( globalMods ); return true; }
		if (HX_FIELD_EQ(inName,"loadTopMod") ) { outValue = loadTopMod_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getGlobalMods") ) { outValue = getGlobalMods_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"updateModList") ) { outValue = updateModList_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"pushGlobalMods") ) { outValue = pushGlobalMods_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"updatedOnState") ) { outValue = ( updatedOnState ); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"ignoreModFolders") ) { outValue = ( ignoreModFolders ); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getModDirectories") ) { outValue = getModDirectories_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"mergeAllTextsNamed") ) { outValue = mergeAllTextsNamed_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"currentModDirectory") ) { outValue = ( currentModDirectory ); return true; }
		if (HX_FIELD_EQ(inName,"directoriesWithFile") ) { outValue = directoriesWithFile_dyn(); return true; }
	}
	return false;
}

bool Mods_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"globalMods") ) { globalMods=ioValue.Cast< ::Array< ::String > >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"updatedOnState") ) { updatedOnState=ioValue.Cast< bool >(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"ignoreModFolders") ) { ignoreModFolders=ioValue.Cast< ::Array< ::String > >(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"currentModDirectory") ) { currentModDirectory=ioValue.Cast< ::String >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Mods_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo Mods_obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &Mods_obj::currentModDirectory,HX_("currentModDirectory",24,ad,ec,de)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &Mods_obj::ignoreModFolders,HX_("ignoreModFolders",15,37,dd,7e)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &Mods_obj::globalMods,HX_("globalMods",74,1e,04,3f)},
	{::hx::fsBool,(void *) &Mods_obj::updatedOnState,HX_("updatedOnState",77,07,c7,9a)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void Mods_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Mods_obj::currentModDirectory,"currentModDirectory");
	HX_MARK_MEMBER_NAME(Mods_obj::ignoreModFolders,"ignoreModFolders");
	HX_MARK_MEMBER_NAME(Mods_obj::globalMods,"globalMods");
	HX_MARK_MEMBER_NAME(Mods_obj::updatedOnState,"updatedOnState");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Mods_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Mods_obj::currentModDirectory,"currentModDirectory");
	HX_VISIT_MEMBER_NAME(Mods_obj::ignoreModFolders,"ignoreModFolders");
	HX_VISIT_MEMBER_NAME(Mods_obj::globalMods,"globalMods");
	HX_VISIT_MEMBER_NAME(Mods_obj::updatedOnState,"updatedOnState");
};

#endif

::hx::Class Mods_obj::__mClass;

static ::String Mods_obj_sStaticFields[] = {
	HX_("currentModDirectory",24,ad,ec,de),
	HX_("ignoreModFolders",15,37,dd,7e),
	HX_("globalMods",74,1e,04,3f),
	HX_("getGlobalMods",aa,7a,76,9b),
	HX_("pushGlobalMods",ee,c8,dc,25),
	HX_("getModDirectories",9f,5f,dc,88),
	HX_("mergeAllTextsNamed",5c,f5,10,e0),
	HX_("directoriesWithFile",cd,86,61,2f),
	HX_("getPack",8f,86,d4,1c),
	HX_("updatedOnState",77,07,c7,9a),
	HX_("parseList",31,6e,59,cf),
	HX_("updateModList",37,4d,4d,a8),
	HX_("loadTopMod",f3,21,4e,4a),
	::String(null())
};

void Mods_obj::__register()
{
	Mods_obj _hx_dummy;
	Mods_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("backend.Mods",2b,aa,ba,a1);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Mods_obj::__GetStatic;
	__mClass->mSetStaticField = &Mods_obj::__SetStatic;
	__mClass->mMarkFunc = Mods_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Mods_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Mods_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Mods_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Mods_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Mods_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Mods_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_15_boot)
HXDLIN(  15)		currentModDirectory = HX_("",00,00,00,00);
            	}
{
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_16_boot)
HXDLIN(  16)		ignoreModFolders = ::Array_obj< ::String >::fromData( _hx_array_data_a1baaa2b_29,15);
            	}
{
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_34_boot)
HXDLIN(  34)		globalMods = ::Array_obj< ::String >::__new(0);
            	}
{
            	HX_STACKFRAME(&_hx_pos_9e01c1b3771b993c_156_boot)
HXDLIN( 156)		updatedOnState = false;
            	}
}

} // end namespace backend
