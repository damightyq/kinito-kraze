// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_ClientPrefs
#include <backend/ClientPrefs.h>
#endif
#ifndef INCLUDED_backend_Language
#include <backend/Language.h>
#endif
#ifndef INCLUDED_backend_MusicBeatState
#include <backend/MusicBeatState.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_SaveVariables
#include <backend/SaveVariables.h>
#endif
#ifndef INCLUDED_backend_animation_PsychAnimationController
#include <backend/animation/PsychAnimationController.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMath
#include <flixel/math/FlxMath.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRandom
#include <flixel/math/FlxRandom.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif
#ifndef INCLUDED_objects_Note
#include <objects/Note.h>
#endif
#ifndef INCLUDED_objects_NoteSplash
#include <objects/NoteSplash.h>
#endif
#ifndef INCLUDED_objects_PixelSplashShader
#include <objects/PixelSplashShader.h>
#endif
#ifndef INCLUDED_objects_PixelSplashShaderRef
#include <objects/PixelSplashShaderRef.h>
#endif
#ifndef INCLUDED_objects_StrumNote
#include <objects/StrumNote.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_shaders_RGBPalette
#include <shaders/RGBPalette.h>
#endif
#ifndef INCLUDED_states_PlayState
#include <states/PlayState.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_30_new,"objects.NoteSplash","new",0x6a418ee5,"objects.NoteSplash.new","objects/NoteSplash.hx",30,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_62_loadSplash,"objects.NoteSplash","loadSplash",0xfa5efc48,"objects.NoteSplash.loadSplash","objects/NoteSplash.hx",62,0xe471e78a)
static const Float _hx_array_data_45753873_10[] = {
	(Float)0,(Float)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_290_spawnSplashNote,"objects.NoteSplash","spawnSplashNote",0x3f35d119,"objects.NoteSplash.spawnSplashNote","objects/NoteSplash.hx",290,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_192_spawnSplashNote,"objects.NoteSplash","spawnSplashNote",0x3f35d119,"objects.NoteSplash.spawnSplashNote","objects/NoteSplash.hx",192,0xe471e78a)
static const Float _hx_array_data_45753873_14[] = {
	(Float)0,(Float)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_320_playDefaultAnim,"objects.NoteSplash","playDefaultAnim",0xfa9677e3,"objects.NoteSplash.playDefaultAnim","objects/NoteSplash.hx",320,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_329_checkForAnim,"objects.NoteSplash","checkForAnim",0x4bc4b2ad,"objects.NoteSplash.checkForAnim","objects/NoteSplash.hx",329,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_340_update,"objects.NoteSplash","update",0x3dabe8a4,"objects.NoteSplash.update","objects/NoteSplash.hx",340,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_391_set_config,"objects.NoteSplash","set_config",0x4172b11a,"objects.NoteSplash.set_config","objects/NoteSplash.hx",391,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_417_set_maxAnims,"objects.NoteSplash","set_maxAnims",0x332ebc56,"objects.NoteSplash.set_maxAnims","objects/NoteSplash.hx",417,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_363_getSplashSkinPostfix,"objects.NoteSplash","getSplashSkinPostfix",0x421668b6,"objects.NoteSplash.getSplashSkinPostfix","objects/NoteSplash.hx",363,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_372_createConfig,"objects.NoteSplash","createConfig",0x86425fb9,"objects.NoteSplash.createConfig","objects/NoteSplash.hx",372,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_382_addAnimationToConfig,"objects.NoteSplash","addAnimationToConfig",0xff39423b,"objects.NoteSplash.addAnimationToConfig","objects/NoteSplash.hx",382,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_45_boot,"objects.NoteSplash","boot",0x87347a0d,"objects.NoteSplash.boot","objects/NoteSplash.hx",45,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_46_boot,"objects.NoteSplash","boot",0x87347a0d,"objects.NoteSplash.boot","objects/NoteSplash.hx",46,0xe471e78a)
HX_LOCAL_STACK_FRAME(_hx_pos_a3b2eb9b9f1b347d_338_boot,"objects.NoteSplash","boot",0x87347a0d,"objects.NoteSplash.boot","objects/NoteSplash.hx",338,0xe471e78a)
namespace objects{

void NoteSplash_obj::__construct( ::Dynamic __o_x, ::Dynamic __o_y,::String splash){
            		 ::Dynamic x = __o_x;
            		if (::hx::IsNull(__o_x)) x = 0;
            		 ::Dynamic y = __o_y;
            		if (::hx::IsNull(__o_y)) y = 0;
            	HX_GC_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_30_new)
HXLINE( 337)		this->aliveTime = ((Float)0);
HXLINE(  60)		this->maxAnims = 0;
HXLINE(  43)		this->noteDataMap =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE(  42)		this->spawned = false;
HXLINE(  40)		this->inEditor = false;
HXLINE(  39)		this->copyY = true;
HXLINE(  38)		this->copyX = true;
HXLINE(  36)		this->noteData = 0;
HXLINE(  50)		super::__construct(x,y,null());
HXLINE(  52)		this->animation =  ::backend::animation::PsychAnimationController_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this));
HXLINE(  54)		this->rgbShader =  ::objects::PixelSplashShaderRef_obj::__alloc( HX_CTX );
HXLINE(  55)		this->shader = this->rgbShader->shader;
HXLINE(  57)		this->loadSplash(splash);
            	}

Dynamic NoteSplash_obj::__CreateEmpty() { return new NoteSplash_obj; }

void *NoteSplash_obj::_hx_vtable = 0;

Dynamic NoteSplash_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< NoteSplash_obj > _hx_result = new NoteSplash_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool NoteSplash_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2c01639b) {
		if (inClassId<=(int)0x12f691ed) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x12f691ed;
		} else {
			return inClassId==(int)0x2c01639b;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void NoteSplash_obj::loadSplash(::String splash){
            	HX_GC_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_62_loadSplash)
HXLINE(  63)		this->set_config(null());
HXLINE(  64)		this->set_maxAnims(0);
HXLINE(  66)		if (::hx::IsNull( splash )) {
HXLINE(  68)			splash = (::objects::NoteSplash_obj::defaultNoteSplash + ::objects::NoteSplash_obj::getSplashSkinPostfix());
HXLINE(  69)			bool _hx_tmp;
HXDLIN(  69)			bool _hx_tmp1;
HXDLIN(  69)			if (::hx::IsNotNull( ::states::PlayState_obj::SONG )) {
HXLINE(  69)				_hx_tmp1 = ::hx::IsNotNull( ::states::PlayState_obj::SONG->__Field(HX_("splashSkin",84,03,e1,a1),::hx::paccDynamic) );
            			}
            			else {
HXLINE(  69)				_hx_tmp1 = false;
            			}
HXDLIN(  69)			if (_hx_tmp1) {
HXLINE(  69)				_hx_tmp = (( (::String)(::states::PlayState_obj::SONG->__Field(HX_("splashSkin",84,03,e1,a1),::hx::paccDynamic)) ).length > 0);
            			}
            			else {
HXLINE(  69)				_hx_tmp = false;
            			}
HXDLIN(  69)			if (_hx_tmp) {
HXLINE(  69)				splash = ( (::String)(::states::PlayState_obj::SONG->__Field(HX_("splashSkin",84,03,e1,a1),::hx::paccDynamic)) );
            			}
            		}
HXLINE(  72)		this->texture = splash;
HXLINE(  73)		::String key = this->texture;
HXDLIN(  73)		::String parentFolder = null();
HXDLIN(  73)		if ((key.indexOf(HX_("psychic",d5,09,aa,19),null()) != -1)) {
HXLINE(  73)			::haxe::Log_obj::trace(key, ::Dynamic(::hx::Anon_obj::Create(5)
            				->setFixed(0,HX_("className",a3,92,3d,dc),HX_("backend.Paths",34,17,99,92))
            				->setFixed(1,HX_("customParams",d7,51,18,ed),::cpp::VirtualArray_obj::__new(2)->init(0,parentFolder)->init(1,true))
            				->setFixed(2,HX_("methodName",cc,19,0f,12),HX_("getSparrowAtlas",55,ab,b7,a7))
            				->setFixed(3,HX_("fileName",e7,5a,43,62),HX_("source/backend/Paths.hx",ff,43,8c,3d))
            				->setFixed(4,HX_("lineNumber",dd,81,22,76),372)));
            		}
HXDLIN(  73)		 ::flixel::graphics::FlxGraphic imageLoaded = ::backend::Paths_obj::image(key,parentFolder,true);
HXDLIN(  73)		bool xmlExists = false;
HXDLIN(  73)		::String xml = ::backend::Paths_obj::modFolders(((HX_("images/",77,50,74,c1) + key) + HX_(".xml",69,3e,c3,1e)));
HXDLIN(  73)		if (::sys::FileSystem_obj::exists(xml)) {
HXLINE( 378)			xmlExists = true;
            		}
HXLINE(  73)		 ::Dynamic _hx_tmp2;
HXDLIN(  73)		if (xmlExists) {
HXLINE(  73)			_hx_tmp2 = ::sys::io::File_obj::getContent(xml);
            		}
            		else {
HXLINE(  73)			::String key1 = (HX_("images/",77,50,74,c1) + key);
HXDLIN(  73)			::Dynamic this1 = ::backend::Language_obj::phrases;
HXDLIN(  73)			::String str = ( ( ::haxe::ds::StringMap)(this1) )->get_string(::StringTools_obj::trim(key1).toLowerCase());
HXDLIN(  73)			if (::hx::IsNotNull( str )) {
HXLINE(  82)				key1 = str;
            			}
HXLINE(  73)			_hx_tmp2 = ::backend::Paths_obj::getPath((key1 + HX_(".xml",69,3e,c3,1e)),HX_("TEXT",ad,94,ba,37),parentFolder,null());
            		}
HXDLIN(  73)		this->set_frames(::flixel::graphics::frames::FlxAtlasFrames_obj::fromSparrow(imageLoaded,_hx_tmp2));
HXLINE(  74)		if (::hx::IsNull( this->frames )) {
HXLINE(  76)			this->texture = (::objects::NoteSplash_obj::defaultNoteSplash + ::objects::NoteSplash_obj::getSplashSkinPostfix());
HXLINE(  77)			::String key2 = this->texture;
HXDLIN(  77)			::String parentFolder1 = null();
HXDLIN(  77)			if ((key2.indexOf(HX_("psychic",d5,09,aa,19),null()) != -1)) {
HXLINE(  77)				::haxe::Log_obj::trace(key2, ::Dynamic(::hx::Anon_obj::Create(5)
            					->setFixed(0,HX_("className",a3,92,3d,dc),HX_("backend.Paths",34,17,99,92))
            					->setFixed(1,HX_("customParams",d7,51,18,ed),::cpp::VirtualArray_obj::__new(2)->init(0,parentFolder1)->init(1,true))
            					->setFixed(2,HX_("methodName",cc,19,0f,12),HX_("getSparrowAtlas",55,ab,b7,a7))
            					->setFixed(3,HX_("fileName",e7,5a,43,62),HX_("source/backend/Paths.hx",ff,43,8c,3d))
            					->setFixed(4,HX_("lineNumber",dd,81,22,76),372)));
            			}
HXDLIN(  77)			 ::flixel::graphics::FlxGraphic imageLoaded1 = ::backend::Paths_obj::image(key2,parentFolder1,true);
HXDLIN(  77)			bool xmlExists1 = false;
HXDLIN(  77)			::String xml1 = ::backend::Paths_obj::modFolders(((HX_("images/",77,50,74,c1) + key2) + HX_(".xml",69,3e,c3,1e)));
HXDLIN(  77)			if (::sys::FileSystem_obj::exists(xml1)) {
HXLINE( 378)				xmlExists1 = true;
            			}
HXLINE(  77)			 ::Dynamic _hx_tmp3;
HXDLIN(  77)			if (xmlExists1) {
HXLINE(  77)				_hx_tmp3 = ::sys::io::File_obj::getContent(xml1);
            			}
            			else {
HXLINE(  77)				::String key3 = (HX_("images/",77,50,74,c1) + key2);
HXDLIN(  77)				::Dynamic this2 = ::backend::Language_obj::phrases;
HXDLIN(  77)				::String str1 = ( ( ::haxe::ds::StringMap)(this2) )->get_string(::StringTools_obj::trim(key3).toLowerCase());
HXDLIN(  77)				if (::hx::IsNotNull( str1 )) {
HXLINE(  82)					key3 = str1;
            				}
HXLINE(  77)				_hx_tmp3 = ::backend::Paths_obj::getPath((key3 + HX_(".xml",69,3e,c3,1e)),HX_("TEXT",ad,94,ba,37),parentFolder1,null());
            			}
HXDLIN(  77)			this->set_frames(::flixel::graphics::frames::FlxAtlasFrames_obj::fromSparrow(imageLoaded1,_hx_tmp3));
HXLINE(  78)			if (::hx::IsNull( this->frames )) {
HXLINE(  80)				this->texture = ::objects::NoteSplash_obj::defaultNoteSplash;
HXLINE(  81)				::String key4 = this->texture;
HXDLIN(  81)				::String parentFolder2 = null();
HXDLIN(  81)				if ((key4.indexOf(HX_("psychic",d5,09,aa,19),null()) != -1)) {
HXLINE(  81)					::haxe::Log_obj::trace(key4, ::Dynamic(::hx::Anon_obj::Create(5)
            						->setFixed(0,HX_("className",a3,92,3d,dc),HX_("backend.Paths",34,17,99,92))
            						->setFixed(1,HX_("customParams",d7,51,18,ed),::cpp::VirtualArray_obj::__new(2)->init(0,parentFolder2)->init(1,true))
            						->setFixed(2,HX_("methodName",cc,19,0f,12),HX_("getSparrowAtlas",55,ab,b7,a7))
            						->setFixed(3,HX_("fileName",e7,5a,43,62),HX_("source/backend/Paths.hx",ff,43,8c,3d))
            						->setFixed(4,HX_("lineNumber",dd,81,22,76),372)));
            				}
HXDLIN(  81)				 ::flixel::graphics::FlxGraphic imageLoaded2 = ::backend::Paths_obj::image(key4,parentFolder2,true);
HXDLIN(  81)				bool xmlExists2 = false;
HXDLIN(  81)				::String xml2 = ::backend::Paths_obj::modFolders(((HX_("images/",77,50,74,c1) + key4) + HX_(".xml",69,3e,c3,1e)));
HXDLIN(  81)				if (::sys::FileSystem_obj::exists(xml2)) {
HXLINE( 378)					xmlExists2 = true;
            				}
HXLINE(  81)				 ::Dynamic _hx_tmp4;
HXDLIN(  81)				if (xmlExists2) {
HXLINE(  81)					_hx_tmp4 = ::sys::io::File_obj::getContent(xml2);
            				}
            				else {
HXLINE(  81)					::String key5 = (HX_("images/",77,50,74,c1) + key4);
HXDLIN(  81)					::Dynamic this3 = ::backend::Language_obj::phrases;
HXDLIN(  81)					::String str2 = ( ( ::haxe::ds::StringMap)(this3) )->get_string(::StringTools_obj::trim(key5).toLowerCase());
HXDLIN(  81)					if (::hx::IsNotNull( str2 )) {
HXLINE(  82)						key5 = str2;
            					}
HXLINE(  81)					_hx_tmp4 = ::backend::Paths_obj::getPath((key5 + HX_(".xml",69,3e,c3,1e)),HX_("TEXT",ad,94,ba,37),parentFolder2,null());
            				}
HXDLIN(  81)				this->set_frames(::flixel::graphics::frames::FlxAtlasFrames_obj::fromSparrow(imageLoaded2,_hx_tmp4));
            			}
            		}
HXLINE(  85)		::String path = (HX_("images/",77,50,74,c1) + this->texture);
HXLINE(  86)		if (::objects::NoteSplash_obj::configs->exists(path)) {
HXLINE(  88)			this->set_config(::objects::NoteSplash_obj::configs->get(path));
HXLINE(  89)			{
HXLINE(  89)				 ::Dynamic anim = ( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->iterator();
HXDLIN(  89)				while(( (bool)(anim->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE(  89)					 ::Dynamic anim1 = anim->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
HXLINE(  91)					if ((::hx::Mod(anim1->__Field(HX_("noteData",3c,7b,96,51),::hx::paccDynamic),4) == 0)) {
HXLINE(  92)						this->set_maxAnims((this->maxAnims + 1));
            					}
            				}
            			}
HXLINE(  94)			return;
            		}
            		else {
HXLINE(  96)			if (::backend::Paths_obj::fileExists(((HX_("",00,00,00,00) + path) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),null(),null())) {
HXLINE(  98)				::String path1 = ::backend::Paths_obj::getPath(((HX_("",00,00,00,00) + path) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),null(),true);
HXDLIN(  98)				::String text;
HXDLIN(  98)				if (::sys::FileSystem_obj::exists(path1)) {
HXLINE(  98)					text = ::sys::io::File_obj::getContent(path1);
            				}
            				else {
HXLINE(  98)					text = null();
            				}
HXDLIN(  98)				 ::Dynamic config =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,text)->doParse();
HXLINE(  99)				if (::hx::IsNotNull( config )) {
HXLINE( 101)					 ::Dynamic tempConfig =  ::Dynamic(::hx::Anon_obj::Create(5)
            						->setFixed(0,HX_("animations",ef,34,1c,83), ::haxe::ds::StringMap_obj::__alloc( HX_CTX ))
            						->setFixed(1,HX_("allowRGB",04,8e,17,9e),( (bool)(config->__Field(HX_("allowRGB",04,8e,17,9e),::hx::paccDynamic)) ))
            						->setFixed(2,HX_("allowPixel",3d,81,6f,ed),( (bool)(config->__Field(HX_("allowPixel",3d,81,6f,ed),::hx::paccDynamic)) ))
            						->setFixed(3,HX_("rgb",0d,db,56,00),( (::Array< ::Dynamic>)(config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic)) ))
            						->setFixed(4,HX_("scale",8a,ce,ce,78),( (Float)(config->__Field(HX_("scale",8a,ce,ce,78),::hx::paccDynamic)) )));
HXLINE( 109)					{
HXLINE( 109)						int _g = 0;
HXDLIN( 109)						::Array< ::String > _g1 = ::Reflect_obj::fields( ::Dynamic(config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic)));
HXDLIN( 109)						while((_g < _g1->length)){
HXLINE( 109)							::String i = _g1->__get(_g);
HXDLIN( 109)							_g = (_g + 1);
HXLINE( 111)							 ::Dynamic anim2 = ::Reflect_obj::field( ::Dynamic(config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic)),i);
HXLINE( 112)							( ( ::haxe::ds::StringMap)( ::Dynamic(tempConfig->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->set(i,anim2);
HXLINE( 113)							if ((::hx::Mod(anim2->__Field(HX_("noteData",3c,7b,96,51),::hx::paccDynamic),4) == 0)) {
HXLINE( 114)								this->set_maxAnims((this->maxAnims + 1));
            							}
            						}
            					}
HXLINE( 117)					this->set_config(tempConfig);
HXLINE( 118)					::objects::NoteSplash_obj::configs->set(path,this->config);
HXLINE( 119)					return;
            				}
            			}
            		}
HXLINE( 124)		 ::Dynamic tempConfig1 = ::objects::NoteSplash_obj::createConfig();
HXLINE( 125)		::String anim3 = HX_("note splash",d5,03,6e,d8);
HXLINE( 126)		::Array< ::Dynamic> fps = ::Array_obj< ::Dynamic>::__new(2)->init(0,22)->init(1,26);
HXLINE( 127)		::Array< ::Dynamic> offsets = ::Array_obj< ::Dynamic>::__new(1)->init(0,::Array_obj< Float >::fromData( _hx_array_data_45753873_10,2));
HXLINE( 128)		if (::backend::Paths_obj::fileExists(((HX_("",00,00,00,00) + path) + HX_(".txt",02,3f,c0,1e)),HX_("TEXT",ad,94,ba,37),null(),null())) {
HXLINE( 130)			::String path2 = ::backend::Paths_obj::getPath(((HX_("",00,00,00,00) + path) + HX_(".txt",02,3f,c0,1e)),HX_("TEXT",ad,94,ba,37),null(),true);
HXDLIN( 130)			::String string;
HXDLIN( 130)			if (::sys::FileSystem_obj::exists(path2)) {
HXLINE( 130)				string = ::sys::io::File_obj::getContent(path2);
            			}
            			else {
HXLINE( 130)				string = null();
            			}
HXDLIN( 130)			::Array< ::String > daList = ::Array_obj< ::String >::__new(0);
HXLINE(  69)			daList = ::StringTools_obj::trim(string).split(HX_("\n",0a,00,00,00));
HXLINE( 130)			{
HXLINE( 130)				int _g2 = 0;
HXDLIN( 130)				int _g3 = daList->length;
HXDLIN( 130)				while((_g2 < _g3)){
HXLINE( 130)					_g2 = (_g2 + 1);
HXDLIN( 130)					int i1 = (_g2 - 1);
HXDLIN( 130)					daList[i1] = ::StringTools_obj::trim(daList->__get(i1));
            				}
            			}
HXDLIN( 130)			::Array< ::String > configFile = daList;
HXLINE( 131)			if ((configFile->length > 0)) {
HXLINE( 133)				anim3 = configFile->__get(0);
HXLINE( 134)				if ((configFile->length > 1)) {
HXLINE( 136)					::Array< ::String > framerates = configFile->__get(1).split(HX_(" ",20,00,00,00));
HXLINE( 137)					 ::Dynamic fps1 = ::Std_obj::parseInt(framerates->__get(0));
HXDLIN( 137)					fps = ::Array_obj< ::Dynamic>::__new(2)->init(0,fps1)->init(1,::Std_obj::parseInt(framerates->__get(1)));
HXLINE( 138)					if (::hx::IsNull( fps->__get(0) )) {
HXLINE( 138)						fps[0] = 22;
            					}
HXLINE( 139)					if (::hx::IsNull( fps->__get(1) )) {
HXLINE( 139)						fps[1] = 26;
            					}
HXLINE( 141)					if ((configFile->length > 2)) {
HXLINE( 143)						offsets = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 144)						{
HXLINE( 144)							int _g4 = 2;
HXDLIN( 144)							int _g5 = configFile->length;
HXDLIN( 144)							while((_g4 < _g5)){
HXLINE( 144)								_g4 = (_g4 + 1);
HXDLIN( 144)								int i2 = (_g4 - 1);
HXLINE( 146)								if ((::StringTools_obj::trim(configFile->__get(i2)) != HX_("",00,00,00,00))) {
HXLINE( 148)									::Array< ::String > animOffs = configFile->__get(i2).split(HX_(" ",20,00,00,00));
HXLINE( 149)									Float x = ::Std_obj::parseFloat(animOffs->__get(0));
HXLINE( 150)									Float y = ::Std_obj::parseFloat(animOffs->__get(1));
HXLINE( 151)									if (::Math_obj::isNaN(x)) {
HXLINE( 151)										x = ( (Float)(0) );
            									}
HXLINE( 152)									if (::Math_obj::isNaN(y)) {
HXLINE( 152)										y = ( (Float)(0) );
            									}
HXLINE( 153)									offsets->push(::Array_obj< Float >::__new(2)->init(0,x)->init(1,y));
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 161)		bool failedToFind = false;
HXLINE( 162)		while(true){
HXLINE( 164)			{
HXLINE( 164)				int _g6 = 0;
HXDLIN( 164)				::Array< ::String > _g7 = ::objects::Note_obj::colArray;
HXDLIN( 164)				while((_g6 < _g7->length)){
HXLINE( 164)					::String v = _g7->__get(_g6);
HXDLIN( 164)					_g6 = (_g6 + 1);
HXLINE( 166)					if (!(this->checkForAnim((((((HX_("",00,00,00,00) + anim3) + HX_(" ",20,00,00,00)) + v) + HX_(" ",20,00,00,00)) + (this->maxAnims + 1))))) {
HXLINE( 168)						failedToFind = true;
HXLINE( 169)						goto _hx_goto_6;
            					}
            				}
            				_hx_goto_6:;
            			}
HXLINE( 172)			if (failedToFind) {
HXLINE( 172)				goto _hx_goto_5;
            			}
HXLINE( 173)			this->set_maxAnims((this->maxAnims + 1));
            		}
            		_hx_goto_5:;
HXLINE( 176)		{
HXLINE( 176)			int _g8 = 0;
HXDLIN( 176)			int _g9 = this->maxAnims;
HXDLIN( 176)			while((_g8 < _g9)){
HXLINE( 176)				_g8 = (_g8 + 1);
HXDLIN( 176)				int animNum = (_g8 - 1);
HXLINE( 178)				{
HXLINE( 178)					int _g_current = 0;
HXDLIN( 178)					::Array< ::String > _g_array = ::objects::Note_obj::colArray;
HXDLIN( 178)					while((_g_current < _g_array->length)){
HXLINE( 178)						::String _g_value = _g_array->__get(_g_current);
HXDLIN( 178)						_g_current = (_g_current + 1);
HXDLIN( 178)						int _g_key = (_g_current - 1);
HXDLIN( 178)						int i3 = _g_key;
HXDLIN( 178)						::String col = _g_value;
HXLINE( 179)						{
HXLINE( 180)							int data = (::hx::Mod(i3,::objects::Note_obj::colArray->length) + (animNum * ::objects::Note_obj::colArray->length));
HXLINE( 181)							::String name;
HXDLIN( 181)							if ((animNum > 0)) {
HXLINE( 181)								name = ((HX_("",00,00,00,00) + col) + (animNum + 1));
            							}
            							else {
HXLINE( 181)								name = col;
            							}
HXLINE( 182)							::Array< Float > offset = offsets->__get(::flixel::math::FlxMath_obj::wrap(data,0,::Std_obj::_hx_int(( (Float)((offsets->length - 1)) )))).StaticCast< ::Array< Float > >();
HXLINE( 183)							::objects::NoteSplash_obj::addAnimationToConfig(tempConfig1,( (Float)(1) ),name,(((((HX_("",00,00,00,00) + anim3) + HX_(" ",20,00,00,00)) + col) + HX_(" ",20,00,00,00)) + (animNum + 1)),fps,offset,::Array_obj< int >::__new(0),data);
            						}
            					}
            				}
            			}
            		}
HXLINE( 187)		this->set_config(tempConfig1);
HXLINE( 188)		::objects::NoteSplash_obj::configs->set(path,this->config);
            	}


HX_DEFINE_DYNAMIC_FUNC1(NoteSplash_obj,loadSplash,(void))

void NoteSplash_obj::spawnSplashNote( ::Dynamic __o_x, ::Dynamic __o_y, ::Dynamic __o_noteData, ::objects::Note note, ::Dynamic __o_randomize){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::objects::NoteSplash,_gthis) HXARGC(1)
            		void _hx_run(::String name){
            			HX_GC_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_290_spawnSplashNote)
HXLINE( 291)			_gthis->kill();
HXLINE( 292)			_gthis->spawned = false;
            		}
            		HX_END_LOCAL_FUNC1((void))

            		 ::Dynamic x = __o_x;
            		if (::hx::IsNull(__o_x)) x = 0;
            		 ::Dynamic y = __o_y;
            		if (::hx::IsNull(__o_y)) y = 0;
            		 ::Dynamic noteData = __o_noteData;
            		if (::hx::IsNull(__o_noteData)) noteData = 0;
            		 ::Dynamic randomize = __o_randomize;
            		if (::hx::IsNull(__o_randomize)) randomize = true;
            	HX_GC_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_192_spawnSplashNote)
HXDLIN( 192)		 ::objects::NoteSplash _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 193)		bool _hx_tmp;
HXDLIN( 193)		if (::hx::IsNotNull( note )) {
HXLINE( 193)			_hx_tmp = ( (bool)(note->noteSplashData->__Field(HX_("disabled",7c,41,04,7c),::hx::paccDynamic)) );
            		}
            		else {
HXLINE( 193)			_hx_tmp = false;
            		}
HXDLIN( 193)		if (_hx_tmp) {
HXLINE( 194)			return;
            		}
HXLINE( 196)		this->aliveTime = ( (Float)(0) );
HXLINE( 198)		if (!(this->inEditor)) {
HXLINE( 200)			::String loadedTexture = (::objects::NoteSplash_obj::defaultNoteSplash + ::objects::NoteSplash_obj::getSplashSkinPostfix());
HXLINE( 201)			bool _hx_tmp1;
HXDLIN( 201)			if (::hx::IsNotNull( note )) {
HXLINE( 201)				_hx_tmp1 = ::hx::IsNotNull( note->noteSplashData->__Field(HX_("texture",db,c8,e0,9e),::hx::paccDynamic) );
            			}
            			else {
HXLINE( 201)				_hx_tmp1 = false;
            			}
HXDLIN( 201)			if (_hx_tmp1) {
HXLINE( 201)				loadedTexture = ( (::String)(note->noteSplashData->__Field(HX_("texture",db,c8,e0,9e),::hx::paccDynamic)) );
            			}
            			else {
HXLINE( 202)				bool _hx_tmp2;
HXDLIN( 202)				bool _hx_tmp3;
HXDLIN( 202)				if (::hx::IsNotNull( ::states::PlayState_obj::SONG )) {
HXLINE( 202)					_hx_tmp3 = ::hx::IsNotNull( ::states::PlayState_obj::SONG->__Field(HX_("splashSkin",84,03,e1,a1),::hx::paccDynamic) );
            				}
            				else {
HXLINE( 202)					_hx_tmp3 = false;
            				}
HXDLIN( 202)				if (_hx_tmp3) {
HXLINE( 202)					_hx_tmp2 = (( (::String)(::states::PlayState_obj::SONG->__Field(HX_("splashSkin",84,03,e1,a1),::hx::paccDynamic)) ).length > 0);
            				}
            				else {
HXLINE( 202)					_hx_tmp2 = false;
            				}
HXDLIN( 202)				if (_hx_tmp2) {
HXLINE( 202)					loadedTexture = ( (::String)(::states::PlayState_obj::SONG->__Field(HX_("splashSkin",84,03,e1,a1),::hx::paccDynamic)) );
            				}
            			}
HXLINE( 204)			if ((this->texture != loadedTexture)) {
HXLINE( 204)				this->loadSplash(loadedTexture);
            			}
            		}
HXLINE( 207)		this->setPosition(x,y);
HXLINE( 209)		if (::hx::IsNotNull( this->babyArrow )) {
HXLINE( 210)			this->setPosition((this->babyArrow->x - (::objects::Note_obj::swagWidth * ((Float)0.95))),(this->babyArrow->y - ::objects::Note_obj::swagWidth));
            		}
HXLINE( 212)		if (::hx::IsNotNull( note )) {
HXLINE( 213)			noteData = note->noteData;
            		}
HXLINE( 215)		bool _hx_tmp4;
HXDLIN( 215)		if (( (bool)(randomize) )) {
HXLINE( 215)			_hx_tmp4 = (this->maxAnims > 1);
            		}
            		else {
HXLINE( 215)			_hx_tmp4 = false;
            		}
HXDLIN( 215)		if (_hx_tmp4) {
HXLINE( 216)			int noteData1 = ::hx::Mod(noteData,::objects::Note_obj::colArray->length);
HXDLIN( 216)			int noteData2 = ::flixel::FlxG_obj::random->_hx_int(0,(this->maxAnims - 1),null());
HXDLIN( 216)			noteData = (noteData1 + (noteData2 * ::objects::Note_obj::colArray->length));
            		}
HXLINE( 218)		this->noteData = ( (int)(noteData) );
HXLINE( 219)		::String anim = this->playDefaultAnim();
HXLINE( 221)		 ::shaders::RGBPalette tempShader = null();
HXLINE( 222)		if (( (bool)(this->config->__Field(HX_("allowRGB",04,8e,17,9e),::hx::paccDynamic)) )) {
HXLINE( 224)			::objects::Note_obj::initializeGlobalRGBShader(::hx::Mod(noteData,::objects::Note_obj::colArray->length));
HXLINE( 225)			bool _hx_tmp5;
HXDLIN( 225)			if (!(this->inEditor)) {
HXLINE( 225)				bool _hx_tmp6;
HXDLIN( 225)				if (::hx::IsNotNull( note )) {
HXLINE( 225)					_hx_tmp6 = ( (bool)(note->noteSplashData->__Field(HX_("useRGBShader",cb,ac,57,46),::hx::paccDynamic)) );
            				}
            				else {
HXLINE( 225)					_hx_tmp6 = true;
            				}
HXDLIN( 225)				if (_hx_tmp6) {
HXLINE( 225)					if (::hx::IsNotNull( ::states::PlayState_obj::SONG )) {
HXLINE( 225)						_hx_tmp5 = !(( (bool)(::states::PlayState_obj::SONG->__Field(HX_("disableNoteRGB",33,ad,d1,4a),::hx::paccDynamic)) ));
            					}
            					else {
HXLINE( 225)						_hx_tmp5 = true;
            					}
            				}
            				else {
HXLINE( 225)					_hx_tmp5 = false;
            				}
            			}
            			else {
HXLINE( 225)				_hx_tmp5 = true;
            			}
HXDLIN( 225)			if (_hx_tmp5) {
HXLINE( 227)				tempShader =  ::shaders::RGBPalette_obj::__alloc( HX_CTX );
HXLINE( 229)				bool _hx_tmp7;
HXDLIN( 229)				bool _hx_tmp8;
HXDLIN( 229)				if (::hx::IsNotNull( note )) {
HXLINE( 229)					_hx_tmp8 = !(( (bool)(note->noteSplashData->__Field(HX_("useGlobalShader",cf,57,4f,53),::hx::paccDynamic)) ));
            				}
            				else {
HXLINE( 229)					_hx_tmp8 = true;
            				}
HXDLIN( 229)				if (!(_hx_tmp8)) {
HXLINE( 229)					_hx_tmp7 = this->inEditor;
            				}
            				else {
HXLINE( 229)					_hx_tmp7 = true;
            				}
HXDLIN( 229)				if (_hx_tmp7) {
HXLINE( 231)					::Array< ::Dynamic> colors = ( (::Array< ::Dynamic>)(this->config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic)) );
HXLINE( 232)					if (::hx::IsNotNull( colors )) {
HXLINE( 234)						int _g = 0;
HXDLIN( 234)						int _g1 = colors->length;
HXDLIN( 234)						while((_g < _g1)){
HXLINE( 234)							_g = (_g + 1);
HXDLIN( 234)							int i = (_g - 1);
HXLINE( 236)							if ((i > 2)) {
HXLINE( 236)								goto _hx_goto_11;
            							}
HXLINE( 238)							::Array< int > arr = ::backend::ClientPrefs_obj::data->arrowRGB->__get(::hx::Mod(noteData,::objects::Note_obj::colArray->length)).StaticCast< ::Array< int > >();
HXLINE( 239)							if (::states::PlayState_obj::get_isPixelStage()) {
HXLINE( 239)								arr = ::backend::ClientPrefs_obj::data->arrowRGBPixel->__get(::hx::Mod(noteData,::objects::Note_obj::colArray->length)).StaticCast< ::Array< int > >();
            							}
HXLINE( 241)							 ::Dynamic rgb = colors->__get(i);
HXLINE( 242)							if (::hx::IsNull( rgb )) {
HXLINE( 244)								if ((i == 0)) {
HXLINE( 244)									tempShader->set_r(arr->__get(0));
            								}
            								else {
HXLINE( 245)									if ((i == 1)) {
HXLINE( 245)										tempShader->set_g(arr->__get(1));
            									}
            									else {
HXLINE( 246)										if ((i == 2)) {
HXLINE( 246)											tempShader->set_b(arr->__get(2));
            										}
            									}
            								}
HXLINE( 247)								continue;
            							}
HXLINE( 250)							 ::Dynamic r = rgb->__Field(HX_("r",72,00,00,00),::hx::paccDynamic);
HXLINE( 251)							 ::Dynamic g = rgb->__Field(HX_("g",67,00,00,00),::hx::paccDynamic);
HXLINE( 252)							 ::Dynamic b = rgb->__Field(HX_("b",62,00,00,00),::hx::paccDynamic);
HXLINE( 254)							bool _hx_tmp9;
HXDLIN( 254)							bool _hx_tmp10;
HXDLIN( 254)							if (::hx::IsNotNull( r )) {
HXLINE( 254)								_hx_tmp10 = ::Math_obj::isNaN(( (Float)(r) ));
            							}
            							else {
HXLINE( 254)								_hx_tmp10 = true;
            							}
HXDLIN( 254)							if (!(_hx_tmp10)) {
HXLINE( 254)								_hx_tmp9 = ::hx::IsLess( r,0 );
            							}
            							else {
HXLINE( 254)								_hx_tmp9 = true;
            							}
HXDLIN( 254)							if (_hx_tmp9) {
HXLINE( 254)								r = arr->__get(0);
            							}
HXLINE( 255)							bool _hx_tmp11;
HXDLIN( 255)							bool _hx_tmp12;
HXDLIN( 255)							if (::hx::IsNotNull( g )) {
HXLINE( 255)								_hx_tmp12 = ::Math_obj::isNaN(( (Float)(g) ));
            							}
            							else {
HXLINE( 255)								_hx_tmp12 = true;
            							}
HXDLIN( 255)							if (!(_hx_tmp12)) {
HXLINE( 255)								_hx_tmp11 = ::hx::IsLess( g,0 );
            							}
            							else {
HXLINE( 255)								_hx_tmp11 = true;
            							}
HXDLIN( 255)							if (_hx_tmp11) {
HXLINE( 255)								g = arr->__get(1);
            							}
HXLINE( 256)							bool _hx_tmp13;
HXDLIN( 256)							bool _hx_tmp14;
HXDLIN( 256)							if (::hx::IsNotNull( b )) {
HXLINE( 256)								_hx_tmp14 = ::Math_obj::isNaN(( (Float)(b) ));
            							}
            							else {
HXLINE( 256)								_hx_tmp14 = true;
            							}
HXDLIN( 256)							if (!(_hx_tmp14)) {
HXLINE( 256)								_hx_tmp13 = ::hx::IsLess( b,0 );
            							}
            							else {
HXLINE( 256)								_hx_tmp13 = true;
            							}
HXDLIN( 256)							if (_hx_tmp13) {
HXLINE( 256)								b = arr->__get(2);
            							}
HXLINE( 258)							int Red = ( (int)(r) );
HXDLIN( 258)							int Green = ( (int)(g) );
HXDLIN( 258)							int Blue = ( (int)(b) );
HXDLIN( 258)							int Alpha = 255;
HXDLIN( 258)							int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 258)							{
HXLINE( 258)								color = (color & -16711681);
HXDLIN( 258)								int color1;
HXDLIN( 258)								if ((Red > 255)) {
HXLINE( 258)									color1 = 255;
            								}
            								else {
HXLINE( 258)									if ((Red < 0)) {
HXLINE( 258)										color1 = 0;
            									}
            									else {
HXLINE( 258)										color1 = Red;
            									}
            								}
HXDLIN( 258)								color = (color | (color1 << 16));
            							}
HXDLIN( 258)							{
HXLINE( 258)								color = (color & -65281);
HXDLIN( 258)								int color2;
HXDLIN( 258)								if ((Green > 255)) {
HXLINE( 258)									color2 = 255;
            								}
            								else {
HXLINE( 258)									if ((Green < 0)) {
HXLINE( 258)										color2 = 0;
            									}
            									else {
HXLINE( 258)										color2 = Green;
            									}
            								}
HXDLIN( 258)								color = (color | (color2 << 8));
            							}
HXDLIN( 258)							{
HXLINE( 258)								color = (color & -256);
HXDLIN( 258)								int color3;
HXDLIN( 258)								if ((Blue > 255)) {
HXLINE( 258)									color3 = 255;
            								}
            								else {
HXLINE( 258)									if ((Blue < 0)) {
HXLINE( 258)										color3 = 0;
            									}
            									else {
HXLINE( 258)										color3 = Blue;
            									}
            								}
HXDLIN( 258)								color = (color | color3);
            							}
HXDLIN( 258)							{
HXLINE( 258)								color = (color & 16777215);
HXDLIN( 258)								int color4;
HXDLIN( 258)								if ((Alpha > 255)) {
HXLINE( 258)									color4 = 255;
            								}
            								else {
HXLINE( 258)									if ((Alpha < 0)) {
HXLINE( 258)										color4 = 0;
            									}
            									else {
HXLINE( 258)										color4 = Alpha;
            									}
            								}
HXDLIN( 258)								color = (color | (color4 << 24));
            							}
HXDLIN( 258)							int color5 = color;
HXLINE( 259)							if ((i == 0)) {
HXLINE( 259)								tempShader->set_r(color5);
            							}
            							else {
HXLINE( 260)								if ((i == 1)) {
HXLINE( 260)									tempShader->set_g(color5);
            								}
            								else {
HXLINE( 261)									if ((i == 2)) {
HXLINE( 261)										tempShader->set_b(color5);
            									}
            								}
            							}
            						}
            						_hx_goto_11:;
            					}
            					else {
HXLINE( 264)						tempShader->copyValues(::objects::Note_obj::globalRgbShaders->__get(::hx::Mod(noteData,::objects::Note_obj::colArray->length)).StaticCast<  ::shaders::RGBPalette >());
            					}
HXLINE( 266)					if (::hx::IsNotNull( note )) {
HXLINE( 268)						if (::hx::IsNotEq( note->noteSplashData->__Field(HX_("r",72,00,00,00),::hx::paccDynamic),-1 )) {
HXLINE( 268)							tempShader->set_r(( (int)(note->noteSplashData->__Field(HX_("r",72,00,00,00),::hx::paccDynamic)) ));
            						}
HXLINE( 269)						if (::hx::IsNotEq( note->noteSplashData->__Field(HX_("g",67,00,00,00),::hx::paccDynamic),-1 )) {
HXLINE( 269)							tempShader->set_g(( (int)(note->noteSplashData->__Field(HX_("g",67,00,00,00),::hx::paccDynamic)) ));
            						}
HXLINE( 270)						if (::hx::IsNotEq( note->noteSplashData->__Field(HX_("b",62,00,00,00),::hx::paccDynamic),-1 )) {
HXLINE( 270)							tempShader->set_b(( (int)(note->noteSplashData->__Field(HX_("b",62,00,00,00),::hx::paccDynamic)) ));
            						}
            					}
            				}
            				else {
HXLINE( 273)					tempShader->copyValues(::objects::Note_obj::globalRgbShaders->__get(::hx::Mod(noteData,::objects::Note_obj::colArray->length)).StaticCast<  ::shaders::RGBPalette >());
            				}
            			}
            		}
HXLINE( 276)		this->rgbShader->copyValues(tempShader);
HXLINE( 277)		if (!(( (bool)(this->config->__Field(HX_("allowPixel",3d,81,6f,ed),::hx::paccDynamic)) ))) {
HXLINE( 277)			this->rgbShader->set_pixelAmount(( (Float)(1) ));
            		}
            		else {
HXLINE( 278)			if (::states::PlayState_obj::get_isPixelStage()) {
HXLINE( 278)				this->rgbShader->set_pixelAmount(( (Float)(6) ));
            			}
            		}
HXLINE( 280)		{
HXLINE( 280)			 ::flixel::math::FlxBasePoint this1 = this->offset;
HXDLIN( 280)			this1->set_x(( (Float)(10) ));
HXDLIN( 280)			this1->set_y(( (Float)(10) ));
            		}
HXLINE( 281)		 ::Dynamic conf = ( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(anim);
HXLINE( 282)		::Array< Float > offsets = ::Array_obj< Float >::fromData( _hx_array_data_45753873_14,2);
HXLINE( 283)		if (::hx::IsNotNull( conf )) {
HXLINE( 283)			offsets = ( (::Array< Float >)(conf->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) );
            		}
HXLINE( 284)		if (::hx::IsNotNull( offsets )) {
HXLINE( 286)			this->offset->set_x((this->offset->x + offsets->__get(0)));
HXLINE( 287)			this->offset->set_y((this->offset->y + offsets->__get(1)));
            		}
HXLINE( 290)		this->animation->finishCallback =  ::Dynamic(new _hx_Closure_0(_gthis));
HXLINE( 295)		this->set_alpha(::backend::ClientPrefs_obj::data->splashAlpha);
HXLINE( 296)		if (::hx::IsNotNull( note )) {
HXLINE( 296)			this->set_alpha(( (Float)(note->noteSplashData->__Field(HX_("a",61,00,00,00),::hx::paccDynamic)) ));
            		}
HXLINE( 298)		this->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 299)		if (::hx::IsNotNull( note )) {
HXLINE( 299)			this->set_antialiasing(( (bool)(note->noteSplashData->__Field(HX_("antialiasing",f4,16,b3,48),::hx::paccDynamic)) ));
            		}
HXLINE( 300)		bool _hx_tmp15;
HXDLIN( 300)		if (::states::PlayState_obj::get_isPixelStage()) {
HXLINE( 300)			_hx_tmp15 = ( (bool)(this->config->__Field(HX_("allowPixel",3d,81,6f,ed),::hx::paccDynamic)) );
            		}
            		else {
HXLINE( 300)			_hx_tmp15 = false;
            		}
HXDLIN( 300)		if (_hx_tmp15) {
HXLINE( 300)			this->set_antialiasing(false);
            		}
HXLINE( 302)		int minFps = 22;
HXLINE( 303)		int maxFps = 26;
HXLINE( 304)		if (::hx::IsNotNull( conf )) {
HXLINE( 306)			minFps = ( (int)( ::Dynamic(conf->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic))->__GetItem(0)) );
HXLINE( 307)			if ((minFps < 0)) {
HXLINE( 307)				minFps = 0;
            			}
HXLINE( 309)			maxFps = ( (int)( ::Dynamic(conf->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic))->__GetItem(1)) );
HXLINE( 310)			if ((maxFps < 0)) {
HXLINE( 310)				maxFps = 0;
            			}
            		}
HXLINE( 313)		if (::hx::IsNotNull( this->animation->_curAnim )) {
HXLINE( 314)			 ::flixel::animation::FlxAnimation _hx_tmp16 = this->animation->_curAnim;
HXDLIN( 314)			_hx_tmp16->set_frameRate(( (Float)(::flixel::FlxG_obj::random->_hx_int(minFps,maxFps,null())) ));
            		}
HXLINE( 316)		this->spawned = true;
            	}


HX_DEFINE_DYNAMIC_FUNC5(NoteSplash_obj,spawnSplashNote,(void))

::String NoteSplash_obj::playDefaultAnim(){
            	HX_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_320_playDefaultAnim)
HXLINE( 321)		::String anim = this->noteDataMap->get_string(this->noteData);
HXLINE( 322)		bool _hx_tmp;
HXDLIN( 322)		if (::hx::IsNotNull( anim )) {
HXLINE( 322)			_hx_tmp = this->animation->exists(anim);
            		}
            		else {
HXLINE( 322)			_hx_tmp = false;
            		}
HXDLIN( 322)		if (_hx_tmp) {
HXLINE( 323)			this->animation->play(anim,true,null(),null());
            		}
HXLINE( 325)		return anim;
            	}


HX_DEFINE_DYNAMIC_FUNC0(NoteSplash_obj,playDefaultAnim,return )

bool NoteSplash_obj::checkForAnim(::String anim){
            	HX_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_329_checkForAnim)
HXLINE( 330)		::Array< ::Dynamic> animFrames = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 332)		this->animation->findByPrefix(animFrames,anim,null());
HXLINE( 334)		return (animFrames->length > 0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(NoteSplash_obj,checkForAnim,return )

void NoteSplash_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_340_update)
HXLINE( 341)		if (this->spawned) {
HXLINE( 343)			 ::objects::NoteSplash _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 343)			_hx_tmp->aliveTime = (_hx_tmp->aliveTime + elapsed);
HXLINE( 344)			bool _hx_tmp1;
HXDLIN( 344)			if (::hx::IsNull( this->animation->_curAnim )) {
HXLINE( 344)				_hx_tmp1 = (this->aliveTime >= ::objects::NoteSplash_obj::buggedKillTime);
            			}
            			else {
HXLINE( 344)				_hx_tmp1 = false;
            			}
HXDLIN( 344)			if (_hx_tmp1) {
HXLINE( 346)				this->kill();
HXLINE( 347)				this->spawned = false;
            			}
            		}
HXLINE( 351)		if (::hx::IsNotNull( this->babyArrow )) {
HXLINE( 353)			if (this->copyX) {
HXLINE( 354)				this->set_x((this->babyArrow->x - (::objects::Note_obj::swagWidth * ((Float)0.95))));
            			}
HXLINE( 356)			if (this->copyY) {
HXLINE( 357)				this->set_y((this->babyArrow->y - ::objects::Note_obj::swagWidth));
            			}
            		}
HXLINE( 359)		this->super::update(elapsed);
            	}


 ::Dynamic NoteSplash_obj::set_config( ::Dynamic value){
            	HX_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_391_set_config)
HXLINE( 392)		if (::hx::IsNull( value )) {
HXLINE( 392)			value = ::objects::NoteSplash_obj::createConfig();
            		}
HXLINE( 395)		this->animation->clearAnimations();
HXLINE( 396)		this->noteDataMap->clear();
HXLINE( 398)		{
HXLINE( 398)			 ::Dynamic i = ( ( ::haxe::ds::StringMap)( ::Dynamic(value->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->iterator();
HXDLIN( 398)			while(( (bool)(i->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 398)				 ::Dynamic i1 = i->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)();
HXLINE( 400)				::String key = ( (::String)(i1->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic)) );
HXLINE( 401)				bool _hx_tmp;
HXDLIN( 401)				bool _hx_tmp1;
HXDLIN( 401)				if ((( (::String)(i1->__Field(HX_("prefix",92,d9,b6,ae),::hx::paccDynamic)) ).length > 0)) {
HXLINE( 401)					_hx_tmp1 = ::hx::IsNotNull( key );
            				}
            				else {
HXLINE( 401)					_hx_tmp1 = false;
            				}
HXDLIN( 401)				if (_hx_tmp1) {
HXLINE( 401)					_hx_tmp = (key.length > 0);
            				}
            				else {
HXLINE( 401)					_hx_tmp = false;
            				}
HXDLIN( 401)				if (_hx_tmp) {
HXLINE( 403)					bool _hx_tmp2;
HXDLIN( 403)					if (::hx::IsNotNull( i1->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic) )) {
HXLINE( 403)						_hx_tmp2 = (( (::Array< int >)(i1->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) )->length > 0);
            					}
            					else {
HXLINE( 403)						_hx_tmp2 = false;
            					}
HXDLIN( 403)					if (_hx_tmp2) {
HXLINE( 404)						this->animation->addByIndices(key,( (::String)(i1->__Field(HX_("prefix",92,d9,b6,ae),::hx::paccDynamic)) ),( (::Array< int >)(i1->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) ),HX_("",00,00,00,00), ::Dynamic(i1->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic))->__GetItem(1),false,null(),null());
            					}
            					else {
HXLINE( 406)						this->animation->addByPrefix(key,( (::String)(i1->__Field(HX_("prefix",92,d9,b6,ae),::hx::paccDynamic)) ), ::Dynamic(i1->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic))->__GetItem(1),false,null(),null());
            					}
HXLINE( 408)					this->noteDataMap->set(( (int)(i1->__Field(HX_("noteData",3c,7b,96,51),::hx::paccDynamic)) ),key);
            				}
            			}
            		}
HXLINE( 412)		{
HXLINE( 412)			 ::flixel::math::FlxBasePoint this1 = this->scale;
HXDLIN( 412)			Float y = ( (Float)(value->__Field(HX_("scale",8a,ce,ce,78),::hx::paccDynamic)) );
HXDLIN( 412)			this1->set_x(( (Float)(value->__Field(HX_("scale",8a,ce,ce,78),::hx::paccDynamic)) ));
HXDLIN( 412)			this1->set_y(y);
            		}
HXLINE( 413)		return (this->config = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(NoteSplash_obj,set_config,return )

int NoteSplash_obj::set_maxAnims(int value){
            	HX_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_417_set_maxAnims)
HXLINE( 418)		if ((value > 0)) {
HXLINE( 419)			this->noteData = ::Std_obj::_hx_int(( (Float)(::flixel::math::FlxMath_obj::wrap(this->noteData,0,((value * ::objects::Note_obj::colArray->length) - 1))) ));
            		}
            		else {
HXLINE( 421)			this->noteData = 0;
            		}
HXLINE( 423)		return (this->maxAnims = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(NoteSplash_obj,set_maxAnims,return )

::String NoteSplash_obj::defaultNoteSplash;

 ::haxe::ds::StringMap NoteSplash_obj::configs;

Float NoteSplash_obj::buggedKillTime;

::String NoteSplash_obj::getSplashSkinPostfix(){
            	HX_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_363_getSplashSkinPostfix)
HXLINE( 364)		::String skin = HX_("",00,00,00,00);
HXLINE( 365)		if ((::backend::ClientPrefs_obj::data->splashSkin != ::backend::ClientPrefs_obj::defaultData->splashSkin)) {
HXLINE( 366)			skin = (HX_("-",2d,00,00,00) + ::StringTools_obj::replace(::StringTools_obj::trim(::backend::ClientPrefs_obj::data->splashSkin).toLowerCase(),HX_(" ",20,00,00,00),HX_("-",2d,00,00,00)));
            		}
HXLINE( 367)		return skin;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(NoteSplash_obj,getSplashSkinPostfix,return )

 ::Dynamic NoteSplash_obj::createConfig(){
            	HX_GC_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_372_createConfig)
HXDLIN( 372)		return  ::Dynamic(::hx::Anon_obj::Create(5)
            			->setFixed(0,HX_("animations",ef,34,1c,83), ::haxe::ds::StringMap_obj::__alloc( HX_CTX ))
            			->setFixed(1,HX_("allowRGB",04,8e,17,9e),true)
            			->setFixed(2,HX_("allowPixel",3d,81,6f,ed),true)
            			->setFixed(3,HX_("rgb",0d,db,56,00),null())
            			->setFixed(4,HX_("scale",8a,ce,ce,78),( (Float)(1) )));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(NoteSplash_obj,createConfig,return )

 ::Dynamic NoteSplash_obj::addAnimationToConfig( ::Dynamic config,Float scale,::String name,::String prefix,::Array< int > fps,::Array< Float > offsets,::Array< int > indices,int noteData){
            	HX_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_382_addAnimationToConfig)
HXLINE( 383)		if (::hx::IsNull( config )) {
HXLINE( 383)			config = ::objects::NoteSplash_obj::createConfig();
            		}
HXLINE( 385)		( ( ::haxe::ds::StringMap)( ::Dynamic(config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->set(name, ::Dynamic(::hx::Anon_obj::Create(6)
            			->setFixed(0,HX_("prefix",92,d9,b6,ae),prefix)
            			->setFixed(1,HX_("offsets",80,09,65,d7),offsets)
            			->setFixed(2,HX_("indices",27,47,54,e3),indices)
            			->setFixed(3,HX_("fps",e9,c7,4d,00),fps)
            			->setFixed(4,HX_("name",4b,72,ff,48),name)
            			->setFixed(5,HX_("noteData",3c,7b,96,51),noteData)));
HXLINE( 386)		config->__SetField(HX_("scale",8a,ce,ce,78),scale,::hx::paccDynamic);
HXLINE( 387)		return config;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(NoteSplash_obj,addAnimationToConfig,return )


::hx::ObjectPtr< NoteSplash_obj > NoteSplash_obj::__new( ::Dynamic __o_x, ::Dynamic __o_y,::String splash) {
	::hx::ObjectPtr< NoteSplash_obj > __this = new NoteSplash_obj();
	__this->__construct(__o_x,__o_y,splash);
	return __this;
}

::hx::ObjectPtr< NoteSplash_obj > NoteSplash_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic __o_x, ::Dynamic __o_y,::String splash) {
	NoteSplash_obj *__this = (NoteSplash_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(NoteSplash_obj), true, "objects.NoteSplash"));
	*(void **)__this = NoteSplash_obj::_hx_vtable;
	__this->__construct(__o_x,__o_y,splash);
	return __this;
}

NoteSplash_obj::NoteSplash_obj()
{
}

void NoteSplash_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(NoteSplash);
	HX_MARK_MEMBER_NAME(rgbShader,"rgbShader");
	HX_MARK_MEMBER_NAME(texture,"texture");
	HX_MARK_MEMBER_NAME(config,"config");
	HX_MARK_MEMBER_NAME(babyArrow,"babyArrow");
	HX_MARK_MEMBER_NAME(noteData,"noteData");
	HX_MARK_MEMBER_NAME(copyX,"copyX");
	HX_MARK_MEMBER_NAME(copyY,"copyY");
	HX_MARK_MEMBER_NAME(inEditor,"inEditor");
	HX_MARK_MEMBER_NAME(spawned,"spawned");
	HX_MARK_MEMBER_NAME(noteDataMap,"noteDataMap");
	HX_MARK_MEMBER_NAME(maxAnims,"maxAnims");
	HX_MARK_MEMBER_NAME(aliveTime,"aliveTime");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void NoteSplash_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(rgbShader,"rgbShader");
	HX_VISIT_MEMBER_NAME(texture,"texture");
	HX_VISIT_MEMBER_NAME(config,"config");
	HX_VISIT_MEMBER_NAME(babyArrow,"babyArrow");
	HX_VISIT_MEMBER_NAME(noteData,"noteData");
	HX_VISIT_MEMBER_NAME(copyX,"copyX");
	HX_VISIT_MEMBER_NAME(copyY,"copyY");
	HX_VISIT_MEMBER_NAME(inEditor,"inEditor");
	HX_VISIT_MEMBER_NAME(spawned,"spawned");
	HX_VISIT_MEMBER_NAME(noteDataMap,"noteDataMap");
	HX_VISIT_MEMBER_NAME(maxAnims,"maxAnims");
	HX_VISIT_MEMBER_NAME(aliveTime,"aliveTime");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val NoteSplash_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"copyX") ) { return ::hx::Val( copyX ); }
		if (HX_FIELD_EQ(inName,"copyY") ) { return ::hx::Val( copyY ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"config") ) { return ::hx::Val( config ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"texture") ) { return ::hx::Val( texture ); }
		if (HX_FIELD_EQ(inName,"spawned") ) { return ::hx::Val( spawned ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"noteData") ) { return ::hx::Val( noteData ); }
		if (HX_FIELD_EQ(inName,"inEditor") ) { return ::hx::Val( inEditor ); }
		if (HX_FIELD_EQ(inName,"maxAnims") ) { return ::hx::Val( maxAnims ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"rgbShader") ) { return ::hx::Val( rgbShader ); }
		if (HX_FIELD_EQ(inName,"babyArrow") ) { return ::hx::Val( babyArrow ); }
		if (HX_FIELD_EQ(inName,"aliveTime") ) { return ::hx::Val( aliveTime ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"loadSplash") ) { return ::hx::Val( loadSplash_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_config") ) { return ::hx::Val( set_config_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"noteDataMap") ) { return ::hx::Val( noteDataMap ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"checkForAnim") ) { return ::hx::Val( checkForAnim_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_maxAnims") ) { return ::hx::Val( set_maxAnims_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"spawnSplashNote") ) { return ::hx::Val( spawnSplashNote_dyn() ); }
		if (HX_FIELD_EQ(inName,"playDefaultAnim") ) { return ::hx::Val( playDefaultAnim_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool NoteSplash_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"configs") ) { outValue = ( configs ); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"createConfig") ) { outValue = createConfig_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"buggedKillTime") ) { outValue = ( buggedKillTime ); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"defaultNoteSplash") ) { outValue = ( defaultNoteSplash ); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"getSplashSkinPostfix") ) { outValue = getSplashSkinPostfix_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addAnimationToConfig") ) { outValue = addAnimationToConfig_dyn(); return true; }
	}
	return false;
}

::hx::Val NoteSplash_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"copyX") ) { copyX=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"copyY") ) { copyY=inValue.Cast< bool >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"config") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_config(inValue.Cast<  ::Dynamic >()) );config=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"texture") ) { texture=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"spawned") ) { spawned=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"noteData") ) { noteData=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"inEditor") ) { inEditor=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxAnims") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_maxAnims(inValue.Cast< int >()) );maxAnims=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"rgbShader") ) { rgbShader=inValue.Cast<  ::objects::PixelSplashShaderRef >(); return inValue; }
		if (HX_FIELD_EQ(inName,"babyArrow") ) { babyArrow=inValue.Cast<  ::objects::StrumNote >(); return inValue; }
		if (HX_FIELD_EQ(inName,"aliveTime") ) { aliveTime=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"noteDataMap") ) { noteDataMap=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool NoteSplash_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"configs") ) { configs=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"buggedKillTime") ) { buggedKillTime=ioValue.Cast< Float >(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"defaultNoteSplash") ) { defaultNoteSplash=ioValue.Cast< ::String >(); return true; }
	}
	return false;
}

void NoteSplash_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("rgbShader",12,56,b9,2f));
	outFields->push(HX_("texture",db,c8,e0,9e));
	outFields->push(HX_("config",c2,56,d2,c7));
	outFields->push(HX_("babyArrow",93,78,aa,71));
	outFields->push(HX_("noteData",3c,7b,96,51));
	outFields->push(HX_("copyX",03,83,5f,4a));
	outFields->push(HX_("copyY",04,83,5f,4a));
	outFields->push(HX_("inEditor",72,8b,5b,c4));
	outFields->push(HX_("spawned",5a,3b,f7,9e));
	outFields->push(HX_("noteDataMap",c0,f4,4b,c5));
	outFields->push(HX_("maxAnims",fe,1b,01,cd));
	outFields->push(HX_("aliveTime",7a,c6,79,aa));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo NoteSplash_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::objects::PixelSplashShaderRef */ ,(int)offsetof(NoteSplash_obj,rgbShader),HX_("rgbShader",12,56,b9,2f)},
	{::hx::fsString,(int)offsetof(NoteSplash_obj,texture),HX_("texture",db,c8,e0,9e)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(NoteSplash_obj,config),HX_("config",c2,56,d2,c7)},
	{::hx::fsObject /*  ::objects::StrumNote */ ,(int)offsetof(NoteSplash_obj,babyArrow),HX_("babyArrow",93,78,aa,71)},
	{::hx::fsInt,(int)offsetof(NoteSplash_obj,noteData),HX_("noteData",3c,7b,96,51)},
	{::hx::fsBool,(int)offsetof(NoteSplash_obj,copyX),HX_("copyX",03,83,5f,4a)},
	{::hx::fsBool,(int)offsetof(NoteSplash_obj,copyY),HX_("copyY",04,83,5f,4a)},
	{::hx::fsBool,(int)offsetof(NoteSplash_obj,inEditor),HX_("inEditor",72,8b,5b,c4)},
	{::hx::fsBool,(int)offsetof(NoteSplash_obj,spawned),HX_("spawned",5a,3b,f7,9e)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(NoteSplash_obj,noteDataMap),HX_("noteDataMap",c0,f4,4b,c5)},
	{::hx::fsInt,(int)offsetof(NoteSplash_obj,maxAnims),HX_("maxAnims",fe,1b,01,cd)},
	{::hx::fsFloat,(int)offsetof(NoteSplash_obj,aliveTime),HX_("aliveTime",7a,c6,79,aa)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo NoteSplash_obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &NoteSplash_obj::defaultNoteSplash,HX_("defaultNoteSplash",1a,47,0e,34)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &NoteSplash_obj::configs,HX_("configs",71,93,39,10)},
	{::hx::fsFloat,(void *) &NoteSplash_obj::buggedKillTime,HX_("buggedKillTime",bd,92,40,5e)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String NoteSplash_obj_sMemberFields[] = {
	HX_("rgbShader",12,56,b9,2f),
	HX_("texture",db,c8,e0,9e),
	HX_("config",c2,56,d2,c7),
	HX_("babyArrow",93,78,aa,71),
	HX_("noteData",3c,7b,96,51),
	HX_("copyX",03,83,5f,4a),
	HX_("copyY",04,83,5f,4a),
	HX_("inEditor",72,8b,5b,c4),
	HX_("spawned",5a,3b,f7,9e),
	HX_("noteDataMap",c0,f4,4b,c5),
	HX_("maxAnims",fe,1b,01,cd),
	HX_("loadSplash",2d,b0,c3,74),
	HX_("spawnSplashNote",14,df,a1,0b),
	HX_("playDefaultAnim",de,85,02,c7),
	HX_("checkForAnim",d2,e9,a9,af),
	HX_("aliveTime",7a,c6,79,aa),
	HX_("update",09,86,05,87),
	HX_("set_config",ff,64,d7,bb),
	HX_("set_maxAnims",7b,f3,13,97),
	::String(null()) };

static void NoteSplash_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(NoteSplash_obj::defaultNoteSplash,"defaultNoteSplash");
	HX_MARK_MEMBER_NAME(NoteSplash_obj::configs,"configs");
	HX_MARK_MEMBER_NAME(NoteSplash_obj::buggedKillTime,"buggedKillTime");
};

#ifdef HXCPP_VISIT_ALLOCS
static void NoteSplash_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(NoteSplash_obj::defaultNoteSplash,"defaultNoteSplash");
	HX_VISIT_MEMBER_NAME(NoteSplash_obj::configs,"configs");
	HX_VISIT_MEMBER_NAME(NoteSplash_obj::buggedKillTime,"buggedKillTime");
};

#endif

::hx::Class NoteSplash_obj::__mClass;

static ::String NoteSplash_obj_sStaticFields[] = {
	HX_("defaultNoteSplash",1a,47,0e,34),
	HX_("configs",71,93,39,10),
	HX_("buggedKillTime",bd,92,40,5e),
	HX_("getSplashSkinPostfix",db,cc,6e,ed),
	HX_("createConfig",de,96,27,ea),
	HX_("addAnimationToConfig",60,a6,91,aa),
	::String(null())
};

void NoteSplash_obj::__register()
{
	NoteSplash_obj _hx_dummy;
	NoteSplash_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("objects.NoteSplash",73,38,75,45);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &NoteSplash_obj::__GetStatic;
	__mClass->mSetStaticField = &NoteSplash_obj::__SetStatic;
	__mClass->mMarkFunc = NoteSplash_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(NoteSplash_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(NoteSplash_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< NoteSplash_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = NoteSplash_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = NoteSplash_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = NoteSplash_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void NoteSplash_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_45_boot)
HXDLIN(  45)		defaultNoteSplash = HX_("noteSplashes/noteSplashes",4f,0e,1e,ef);
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_46_boot)
HXDLIN(  46)		configs =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
{
            	HX_STACKFRAME(&_hx_pos_a3b2eb9b9f1b347d_338_boot)
HXDLIN( 338)		buggedKillTime = ((Float)0.5);
            	}
}

} // end namespace objects
