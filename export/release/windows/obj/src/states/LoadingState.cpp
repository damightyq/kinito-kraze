// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_backend_Achievements
#include <backend/Achievements.h>
#endif
#ifndef INCLUDED_backend_ClientPrefs
#include <backend/ClientPrefs.h>
#endif
#ifndef INCLUDED_backend_Controls
#include <backend/Controls.h>
#endif
#ifndef INCLUDED_backend_Language
#include <backend/Language.h>
#endif
#ifndef INCLUDED_backend_Mods
#include <backend/Mods.h>
#endif
#ifndef INCLUDED_backend_MusicBeatState
#include <backend/MusicBeatState.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_SaveVariables
#include <backend/SaveVariables.h>
#endif
#ifndef INCLUDED_backend_Song
#include <backend/Song.h>
#endif
#ifndef INCLUDED_backend_StageData
#include <backend/StageData.h>
#endif
#ifndef INCLUDED_crowplexus_hscript_Error
#include <crowplexus/hscript/Error.h>
#endif
#ifndef INCLUDED_crowplexus_hscript_Printer
#include <crowplexus/hscript/Printer.h>
#endif
#ifndef INCLUDED_crowplexus_iris_Iris
#include <crowplexus/iris/Iris.h>
#endif
#ifndef INCLUDED_crowplexus_iris_IrisCall
#include <crowplexus/iris/IrisCall.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_transition_FlxTransitionableState
#include <flixel/addons/transition/FlxTransitionableState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxAtlasFrames
#include <flixel/graphics/frames/FlxAtlasFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSoundGroup
#include <flixel/sound/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_FlxAssets
#include <flixel/system/FlxAssets.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_LogFrontEnd
#include <flixel/system/frontEnds/LogFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxEase
#include <flixel/tweens/FlxEase.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_FlxTimer
#include <flixel/util/FlxTimer.h>
#endif
#ifndef INCLUDED_flixel_util_FlxTimerManager
#include <flixel/util/FlxTimerManager.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ValueException
#include <haxe/ValueException.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif
#ifndef INCLUDED_haxe_io_Path
#include <haxe/io/Path.h>
#endif
#ifndef INCLUDED_lime_app_Future
#include <lime/app/Future.h>
#endif
#ifndef INCLUDED_lime_utils_Assets
#include <lime/utils/Assets.h>
#endif
#ifndef INCLUDED_objects_Note
#include <objects/Note.h>
#endif
#ifndef INCLUDED_objects_NoteSplash
#include <objects/NoteSplash.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_media_Sound
#include <openfl/media/Sound.h>
#endif
#ifndef INCLUDED_openfl_utils_Assets
#include <openfl/utils/Assets.h>
#endif
#ifndef INCLUDED_psychlua_HScript
#include <psychlua/HScript.h>
#endif
#ifndef INCLUDED_states_LoadingState
#include <states/LoadingState.h>
#endif
#ifndef INCLUDED_states_PlayState
#include <states/PlayState.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif
#ifndef INCLUDED_sys_thread_FixedThreadPool
#include <sys/thread/FixedThreadPool.h>
#endif
#ifndef INCLUDED_sys_thread_IThreadPool
#include <sys/thread/IThreadPool.h>
#endif
#ifndef INCLUDED_sys_thread_Mutex
#include <sys/thread/Mutex.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_670a7524baf7a379_39_new,"states.LoadingState","new",0xb6608a33,"states.LoadingState.new","states/LoadingState.hx",39,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_91_create,"states.LoadingState","create",0xe9745309,"states.LoadingState.create","states/LoadingState.hx",91,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_117_create,"states.LoadingState","create",0xe9745309,"states.LoadingState.create","states/LoadingState.hx",117,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_118_create,"states.LoadingState","create",0xe9745309,"states.LoadingState.create","states/LoadingState.hx",118,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_191_addBehindBar,"states.LoadingState","addBehindBar",0x3faafea5,"states.LoadingState.addBehindBar","states/LoadingState.hx",191,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_196_update,"states.LoadingState","update",0xf46a7216,"states.LoadingState.update","states/LoadingState.hx",196,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_274_update,"states.LoadingState","update",0xf46a7216,"states.LoadingState.update","states/LoadingState.hx",274,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_306_destroy,"states.LoadingState","destroy",0x6f6fcc4d,"states.LoadingState.destroy","states/LoadingState.hx",306,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_319_onLoad,"states.LoadingState","onLoad",0x57a68ef2,"states.LoadingState.onLoad","states/LoadingState.hx",319,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_58_loadAndSwitchState,"states.LoadingState","loadAndSwitchState",0x9884a639,"states.LoadingState.loadAndSwitchState","states/LoadingState.hx",58,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_332__loaded,"states.LoadingState","_loaded",0x11cff8f7,"states.LoadingState._loaded","states/LoadingState.hx",332,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_345_checkLoaded,"states.LoadingState","checkLoaded",0x2e685fc0,"states.LoadingState.checkLoaded","states/LoadingState.hx",345,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_358_loadNextDirectory,"states.LoadingState","loadNextDirectory",0xddf29207,"states.LoadingState.loadNextDirectory","states/LoadingState.hx",358,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_371_getNextState,"states.LoadingState","getNextState",0xb11c2075,"states.LoadingState.getNextState","states/LoadingState.hx",371,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_403_prepare,"states.LoadingState","prepare",0x82c730da,"states.LoadingState.prepare","states/LoadingState.hx",403,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_412__startPool,"states.LoadingState","_startPool",0x5b72ecac,"states.LoadingState._startPool","states/LoadingState.hx",412,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_447_prepareToSong,"states.LoadingState","prepareToSong",0x7838536a,"states.LoadingState.prepareToSong","states/LoadingState.hx",447,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_459_prepareToSong,"states.LoadingState","prepareToSong",0x7838536a,"states.LoadingState.prepareToSong","states/LoadingState.hx",459,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_514_prepareToSong,"states.LoadingState","prepareToSong",0x7838536a,"states.LoadingState.prepareToSong","states/LoadingState.hx",514,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_579_prepareToSong,"states.LoadingState","prepareToSong",0x7838536a,"states.LoadingState.prepareToSong","states/LoadingState.hx",579,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_587_prepareToSong,"states.LoadingState","prepareToSong",0x7838536a,"states.LoadingState.prepareToSong","states/LoadingState.hx",587,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_602_prepareToSong,"states.LoadingState","prepareToSong",0x7838536a,"states.LoadingState.prepareToSong","states/LoadingState.hx",602,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_423_prepareToSong,"states.LoadingState","prepareToSong",0x7838536a,"states.LoadingState.prepareToSong","states/LoadingState.hx",423,0x41b125bc)
static const int _hx_array_data_7fc4f4c1_37[] = {
	(int)0,
};
static const int _hx_array_data_7fc4f4c1_38[] = {
	(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_607_clearInvalids,"states.LoadingState","clearInvalids",0x06d51fdc,"states.LoadingState.clearInvalids","states/LoadingState.hx",607,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_619_clearInvalidFrom,"states.LoadingState","clearInvalidFrom",0x1deb79c1,"states.LoadingState.clearInvalidFrom","states/LoadingState.hx",619,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_661_startThreads,"states.LoadingState","startThreads",0x3bb2cdf4,"states.LoadingState.startThreads","states/LoadingState.hx",661,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_671__threadFunc,"states.LoadingState","_threadFunc",0x05fed120,"states.LoadingState._threadFunc","states/LoadingState.hx",671,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_673__threadFunc,"states.LoadingState","_threadFunc",0x05fed120,"states.LoadingState._threadFunc","states/LoadingState.hx",673,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_674__threadFunc,"states.LoadingState","_threadFunc",0x05fed120,"states.LoadingState._threadFunc","states/LoadingState.hx",674,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_675__threadFunc,"states.LoadingState","_threadFunc",0x05fed120,"states.LoadingState._threadFunc","states/LoadingState.hx",675,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_678__threadFunc,"states.LoadingState","_threadFunc",0x05fed120,"states.LoadingState._threadFunc","states/LoadingState.hx",678,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_687_initThread,"states.LoadingState","initThread",0x8f7f4c87,"states.LoadingState.initThread","states/LoadingState.hx",687,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_712_preloadCharacter,"states.LoadingState","preloadCharacter",0x384810ed,"states.LoadingState.preloadCharacter","states/LoadingState.hx",712,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_770_preloadSound,"states.LoadingState","preloadSound",0x16a5d013,"states.LoadingState.preloadSound","states/LoadingState.hx",770,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_799_preloadGraphic,"states.LoadingState","preloadGraphic",0x252af6ec,"states.LoadingState.preloadGraphic","states/LoadingState.hx",799,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_842_getCPUThreadsCount,"states.LoadingState","getCPUThreadsCount",0xcbb39a85,"states.LoadingState.getCPUThreadsCount","states/LoadingState.hx",842,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_41_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",41,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_42_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",42,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_44_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",44,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_45_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",45,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_47_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",47,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_369_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",369,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_398_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",398,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_399_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",399,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_400_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",400,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_401_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",401,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_409_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",409,0x41b125bc)
HX_LOCAL_STACK_FRAME(_hx_pos_670a7524baf7a379_410_boot,"states.LoadingState","boot",0xd63162ff,"states.LoadingState.boot","states/LoadingState.hx",410,0x41b125bc)
namespace states{

void LoadingState_obj::__construct( ::flixel::FlxState target,bool stopMusic){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_39_new)
HXLINE( 317)		this->finishedLoading = false;
HXLINE( 194)		this->transitioning = false;
HXLINE(  82)		this->pressedTimes = 0;
HXLINE(  81)		this->spawnedPessy = false;
HXLINE(  80)		this->isSpinning = false;
HXLINE(  78)		this->shakeMult = ((Float)0);
HXLINE(  69)		this->stateChangeDelay = ((Float)0);
HXLINE(  68)		this->curPercent = ((Float)0);
HXLINE(  67)		this->intendedPercent = ((Float)0);
HXLINE(  66)		this->barWidth = 0;
HXLINE(  62)		this->dontUpdate = false;
HXLINE(  61)		this->stopMusic = false;
HXLINE(  60)		this->target = null();
HXLINE(  51)		this->target = target;
HXLINE(  52)		this->stopMusic = stopMusic;
HXLINE(  54)		super::__construct();
            	}

Dynamic LoadingState_obj::__CreateEmpty() { return new LoadingState_obj; }

void *LoadingState_obj::_hx_vtable = 0;

Dynamic LoadingState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< LoadingState_obj > _hx_result = new LoadingState_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool LoadingState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x53aaab8a) {
			if (inClassId<=(int)0x137cfbbb) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x137cfbbb;
			} else {
				return inClassId==(int)0x53aaab8a;
			}
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void LoadingState_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_91_create)
HXLINE(  92)		this->persistentUpdate = true;
HXLINE(  93)		this->barGroup =  ::flixel::group::FlxTypedSpriteGroup_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  94)		this->add(this->barGroup);
HXLINE(  96)		 ::flixel::FlxSprite barBack =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,660,null())->makeGraphic(1,1,-16777216,null(),null());
HXLINE(  97)		{
HXLINE(  97)			 ::flixel::math::FlxBasePoint this1 = barBack->scale;
HXDLIN(  97)			this1->set_x(( (Float)((::flixel::FlxG_obj::width - 300)) ));
HXDLIN(  97)			this1->set_y(( (Float)(25) ));
            		}
HXLINE(  98)		barBack->updateHitbox();
HXLINE(  99)		{
HXLINE(  99)			int axes = 1;
HXDLIN(  99)			bool _hx_tmp;
HXDLIN(  99)			if ((axes != 1)) {
HXLINE(  99)				_hx_tmp = (axes == 17);
            			}
            			else {
HXLINE(  99)				_hx_tmp = true;
            			}
HXDLIN(  99)			if (_hx_tmp) {
HXLINE(  99)				int _hx_tmp1 = ::flixel::FlxG_obj::width;
HXDLIN(  99)				barBack->set_x(((( (Float)(_hx_tmp1) ) - barBack->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  99)			bool _hx_tmp2;
HXDLIN(  99)			if ((axes != 16)) {
HXLINE(  99)				_hx_tmp2 = (axes == 17);
            			}
            			else {
HXLINE(  99)				_hx_tmp2 = true;
            			}
HXDLIN(  99)			if (_hx_tmp2) {
HXLINE(  99)				int _hx_tmp3 = ::flixel::FlxG_obj::height;
HXDLIN(  99)				barBack->set_y(((( (Float)(_hx_tmp3) ) - barBack->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE( 100)		this->barGroup->add(barBack).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 102)		this->bar =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,(barBack->x + 5),(barBack->y + 5),null())->makeGraphic(1,1,-1,null(),null());
HXLINE( 103)		{
HXLINE( 103)			 ::flixel::math::FlxBasePoint this2 = this->bar->scale;
HXDLIN( 103)			this2->set_x(( (Float)(0) ));
HXDLIN( 103)			this2->set_y(( (Float)(15) ));
            		}
HXLINE( 104)		this->bar->updateHitbox();
HXLINE( 105)		this->barGroup->add(this->bar).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 106)		this->barWidth = ::Std_obj::_hx_int((barBack->get_width() - ( (Float)(10) )));
HXLINE( 109)		bool _hx_tmp4;
HXDLIN( 109)		if (::hx::IsNotNull( ::backend::Mods_obj::currentModDirectory )) {
HXLINE( 109)			_hx_tmp4 = (::StringTools_obj::trim(::backend::Mods_obj::currentModDirectory).length > 0);
            		}
            		else {
HXLINE( 109)			_hx_tmp4 = false;
            		}
HXDLIN( 109)		if (_hx_tmp4) {
HXLINE( 111)			::String scriptPath = ((HX_("mods/",9e,2f,58,0c) + ::backend::Mods_obj::currentModDirectory) + HX_("/data/LoadingScreen.hx",0c,81,07,57));
HXLINE( 112)			if (::sys::FileSystem_obj::exists(scriptPath)) {
HXLINE( 114)				try {
            					HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            					int _hx_run(){
            						HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_117_create)
HXLINE( 117)						return ::states::LoadingState_obj::loaded;
            					}
            					HX_END_LOCAL_FUNC0(return)

            					HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(0)
            					int _hx_run(){
            						HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_118_create)
HXLINE( 118)						return ::states::LoadingState_obj::loadMax;
            					}
            					HX_END_LOCAL_FUNC0(return)

            					HX_STACK_CATCHABLE( ::crowplexus::hscript::Error, 0);
            					HX_STACK_CATCHABLE( ::haxe::ValueException, 1);
HXLINE( 116)					this->hscript =  ::psychlua::HScript_obj::__alloc( HX_CTX ,null(),scriptPath,null(),null());
HXLINE( 117)					this->hscript->set(HX_("getLoaded",3b,d1,c5,d4), ::Dynamic(new _hx_Closure_0()),null());
HXLINE( 118)					this->hscript->set(HX_("getLoadMax",28,0a,3f,58), ::Dynamic(new _hx_Closure_1()),null());
HXLINE( 119)					this->hscript->set(HX_("barBack",9a,9d,6d,83),barBack,null());
HXLINE( 120)					this->hscript->set(HX_("bar",d3,b1,4a,00),this->bar,null());
HXLINE( 122)					if (this->hscript->exists(HX_("onCreate",7b,5d,bc,5b))) {
HXLINE( 124)						this->hscript->call(HX_("onCreate",7b,5d,bc,5b),null());
HXLINE( 125)						::haxe::Log_obj::trace((HX_("initialized hscript interp successfully: ",20,1d,3c,c4) + scriptPath),::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),125,HX_("states.LoadingState",c1,f4,c4,7f),HX_("create",fc,66,0f,7c)));
HXLINE( 126)						this->super::create();
HXDLIN( 126)						return;
            					}
            					else {
HXLINE( 130)						::haxe::Log_obj::trace(((HX_("\"",22,00,00,00) + scriptPath) + HX_("\" contains no \"onCreate\" function, stopping script.",82,1c,43,ab)),::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),130,HX_("states.LoadingState",c1,f4,c4,7f),HX_("create",fc,66,0f,7c)));
            					}
            				} catch( ::Dynamic _hx_e) {
            					if (_hx_e.IsClass<  ::crowplexus::hscript::Error >() ){
            						HX_STACK_BEGIN_CATCH
            						 ::crowplexus::hscript::Error e1 = _hx_e;
HXLINE( 135)						 ::Dynamic pos1 =  ::Dynamic(::hx::Anon_obj::Create(2)
            							->setFixed(0,HX_("showLine",91,db,39,af),false)
            							->setFixed(1,HX_("fileName",e7,5a,43,62),scriptPath));
HXLINE( 136)						 ::Dynamic _hx_tmp5 = ::crowplexus::iris::Iris_obj::error;
HXDLIN( 136)						_hx_tmp5(::crowplexus::hscript::Printer_obj::errorToString(e1,false),pos1);
HXLINE( 137)						 ::psychlua::HScript hscript1 = ::hx::TCast<  ::psychlua::HScript >::cast(( ( ::crowplexus::iris::Iris)(::crowplexus::iris::Iris_obj::instances->get(scriptPath)) ));
            					}
            					else if (_hx_e.IsClass<  ::haxe::ValueException >() ){
            						HX_STACK_BEGIN_CATCH
            						 ::haxe::ValueException _g = _hx_e;
HXLINE( 133)						{
HXLINE( 133)							null();
            						}
HXLINE( 114)						if (::Std_obj::isOfType(_g->value,::hx::ClassOf< ::crowplexus::hscript::Error >())) {
HXLINE( 133)							 ::crowplexus::hscript::Error e1 = ( ( ::crowplexus::hscript::Error)(_g->value) );
HXLINE( 134)							{
HXLINE( 135)								 ::Dynamic pos1 =  ::Dynamic(::hx::Anon_obj::Create(2)
            									->setFixed(0,HX_("showLine",91,db,39,af),false)
            									->setFixed(1,HX_("fileName",e7,5a,43,62),scriptPath));
HXLINE( 136)								 ::Dynamic _hx_tmp6 = ::crowplexus::iris::Iris_obj::error;
HXDLIN( 136)								_hx_tmp6(::crowplexus::hscript::Printer_obj::errorToString(e1,false),pos1);
HXLINE( 137)								 ::psychlua::HScript hscript1 = ::hx::TCast<  ::psychlua::HScript >::cast(( ( ::crowplexus::iris::Iris)(::crowplexus::iris::Iris_obj::instances->get(scriptPath)) ));
            							}
            						}
            						else {
HXLINE( 114)							HX_STACK_DO_THROW(_g);
            						}
            					}
            					else {
            						HX_STACK_DO_THROW(_hx_e);
            					}
            				}
HXLINE( 139)				if (::hx::IsNotNull( this->hscript )) {
HXLINE( 139)					this->hscript->destroy();
            				}
HXLINE( 140)				this->hscript = null();
            			}
            		}
HXLINE( 146)		 ::flixel::FlxSprite bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXDLIN( 146)		 ::flixel::FlxSprite bg1 = bg->loadGraphic(::backend::Paths_obj::image(HX_("menuDesat",26,91,04,72),null(),null()),null(),null(),null(),null(),null());
HXLINE( 147)		bg1->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 148)		bg1->setGraphicSize(::Std_obj::_hx_int(( (Float)(::flixel::FlxG_obj::width) )),null());
HXLINE( 149)		bg1->set_color(-3051521);
HXLINE( 150)		bg1->updateHitbox();
HXLINE( 151)		this->addBehindBar(bg1);
HXLINE( 153)		::cpp::VirtualArray values = ::cpp::VirtualArray_obj::__new(1)->init(0,HX_("...",ee,0f,23,00));
HXDLIN( 153)		::Dynamic this3 = ::backend::Language_obj::phrases;
HXDLIN( 153)		 ::EReg hideChars =  ::EReg_obj::__alloc( HX_CTX ,HX_("[~&\\\\/;:<>#.,'\"%?!]",85,3f,6d,6d),HX_("g",67,00,00,00));
HXDLIN( 153)		::String str = ( ( ::haxe::ds::StringMap)(this3) )->get_string(::StringTools_obj::trim(hideChars->replace(::StringTools_obj::replace(HX_("now_loading",13,07,bf,10),HX_(" ",20,00,00,00),HX_("_",5f,00,00,00)),HX_("",00,00,00,00)).toLowerCase()));
HXDLIN( 153)		if (::hx::IsNull( str )) {
HXLINE(  62)			str = HX_("Now Loading",32,b1,d8,ae);
            		}
HXLINE( 153)		if (::hx::IsNull( str )) {
HXLINE(  68)			str = HX_("now_loading",13,07,bf,10);
            		}
HXLINE( 153)		if (::hx::IsNotNull( values )) {
HXLINE( 153)			int _g_current = 0;
HXDLIN( 153)			::cpp::VirtualArray _g_array = values;
HXDLIN( 153)			while((_g_current < _g_array->get_length())){
HXLINE( 153)				 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 153)				_g_current = (_g_current + 1);
HXDLIN( 153)				int _g_key = (_g_current - 1);
HXDLIN( 153)				int num = _g_key;
HXDLIN( 153)				 ::Dynamic value = _g_value;
HXLINE(  72)				str = ::StringTools_obj::replace(str,((HX_("{",7b,00,00,00) + (num + 1)) + HX_("}",7d,00,00,00)),( (::String)(value) ));
            			}
            		}
HXLINE( 153)		this->loadingText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,520,600,400,str,32,null());
HXLINE( 154)		 ::flixel::text::FlxText _hx_tmp7 = this->loadingText;
HXDLIN( 154)		::String key = (HX_("fonts/",eb,13,ef,fa) + HX_("vcr.ttf",9d,d2,a7,82));
HXDLIN( 154)		::Dynamic this4 = ::backend::Language_obj::phrases;
HXDLIN( 154)		::String str1 = ( ( ::haxe::ds::StringMap)(this4) )->get_string(::StringTools_obj::trim(key).toLowerCase());
HXDLIN( 154)		if (::hx::IsNotNull( str1 )) {
HXLINE(  82)			key = str1;
            		}
HXLINE( 154)		::String folderKey = key;
HXDLIN( 154)		::String file = ::backend::Paths_obj::modFolders(folderKey);
HXDLIN( 154)		::String _hx_tmp8;
HXDLIN( 154)		if (::sys::FileSystem_obj::exists(file)) {
HXLINE( 154)			_hx_tmp8 = file;
            		}
            		else {
HXLINE( 154)			_hx_tmp8 = (HX_("assets/",4c,2a,dc,36) + folderKey);
            		}
HXDLIN( 154)		_hx_tmp7->setFormat(_hx_tmp8,32,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn(),-16777216,null());
HXLINE( 155)		this->loadingText->set_borderSize(( (Float)(2) ));
HXLINE( 156)		this->addBehindBar(this->loadingText);
HXLINE( 158)		 ::flixel::FlxSprite _hx_tmp9 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,0,null());
HXDLIN( 158)		this->logo = _hx_tmp9->loadGraphic(::backend::Paths_obj::image(HX_("loading_screen/icon",b9,4e,16,3a),null(),null()),null(),null(),null(),null(),null());
HXLINE( 159)		this->logo->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 160)		{
HXLINE( 160)			 ::flixel::math::FlxBasePoint this5 = this->logo->scale;
HXDLIN( 160)			this5->set_x(((Float)0.75));
HXDLIN( 160)			this5->set_y(((Float)0.75));
            		}
HXLINE( 161)		this->logo->updateHitbox();
HXLINE( 162)		{
HXLINE( 162)			 ::flixel::FlxSprite _this = this->logo;
HXDLIN( 162)			int axes1 = 17;
HXDLIN( 162)			bool _hx_tmp10;
HXDLIN( 162)			if ((axes1 != 1)) {
HXLINE( 162)				_hx_tmp10 = (axes1 == 17);
            			}
            			else {
HXLINE( 162)				_hx_tmp10 = true;
            			}
HXDLIN( 162)			if (_hx_tmp10) {
HXLINE( 162)				int _hx_tmp11 = ::flixel::FlxG_obj::width;
HXDLIN( 162)				_this->set_x(((( (Float)(_hx_tmp11) ) - _this->get_width()) / ( (Float)(2) )));
            			}
HXDLIN( 162)			bool _hx_tmp12;
HXDLIN( 162)			if ((axes1 != 16)) {
HXLINE( 162)				_hx_tmp12 = (axes1 == 17);
            			}
            			else {
HXLINE( 162)				_hx_tmp12 = true;
            			}
HXDLIN( 162)			if (_hx_tmp12) {
HXLINE( 162)				int _hx_tmp13 = ::flixel::FlxG_obj::height;
HXDLIN( 162)				_this->set_y(((( (Float)(_hx_tmp13) ) - _this->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE( 163)		 ::flixel::FlxSprite fh = this->logo;
HXDLIN( 163)		fh->set_x((fh->x - ( (Float)(50) )));
HXLINE( 164)		 ::flixel::FlxSprite fh1 = this->logo;
HXDLIN( 164)		fh1->set_y((fh1->y - ( (Float)(40) )));
HXLINE( 165)		this->addBehindBar(this->logo);
HXLINE( 180)		this->super::create();
HXLINE( 182)		bool _hx_tmp14;
HXDLIN( 182)		if ((this->stateChangeDelay <= 0)) {
HXLINE( 182)			_hx_tmp14 = ::states::LoadingState_obj::checkLoaded();
            		}
            		else {
HXLINE( 182)			_hx_tmp14 = false;
            		}
HXDLIN( 182)		if (_hx_tmp14) {
HXLINE( 184)			this->dontUpdate = true;
HXLINE( 185)			this->onLoad();
            		}
            	}


void LoadingState_obj::addBehindBar( ::flixel::FlxBasic obj){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_191_addBehindBar)
HXDLIN( 191)		this->insert(this->members->indexOf(this->barGroup,null()),obj);
            	}


HX_DEFINE_DYNAMIC_FUNC1(LoadingState_obj,addBehindBar,(void))

void LoadingState_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_196_update)
HXDLIN( 196)		 ::states::LoadingState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 197)		this->super::update(elapsed);
HXLINE( 198)		if (this->dontUpdate) {
HXLINE( 198)			return;
            		}
HXLINE( 200)		if (!(this->transitioning)) {
HXLINE( 202)			bool _hx_tmp;
HXDLIN( 202)			if (!(this->finishedLoading)) {
HXLINE( 202)				_hx_tmp = ::states::LoadingState_obj::checkLoaded();
            			}
            			else {
HXLINE( 202)				_hx_tmp = false;
            			}
HXDLIN( 202)			if (_hx_tmp) {
HXLINE( 204)				if ((this->stateChangeDelay <= 0)) {
HXLINE( 206)					this->transitioning = true;
HXLINE( 207)					this->onLoad();
HXLINE( 208)					return;
            				}
            				else {
HXLINE( 210)					this->stateChangeDelay = ::Math_obj::max(( (Float)(0) ),(this->stateChangeDelay - elapsed));
            				}
            			}
HXLINE( 212)			this->intendedPercent = (( (Float)(::states::LoadingState_obj::loaded) ) / ( (Float)(::states::LoadingState_obj::loadMax) ));
            		}
HXLINE( 215)		if ((this->curPercent != this->intendedPercent)) {
HXLINE( 217)			if ((::Math_obj::abs((this->curPercent - this->intendedPercent)) < ((Float)0.001))) {
HXLINE( 217)				this->curPercent = this->intendedPercent;
            			}
            			else {
HXLINE( 218)				Float a = this->intendedPercent;
HXDLIN( 218)				this->curPercent = (a + (::Math_obj::exp((-(elapsed) * ( (Float)(15) ))) * (this->curPercent - a)));
            			}
HXLINE( 220)			this->bar->scale->set_x((( (Float)(this->barWidth) ) * this->curPercent));
HXLINE( 221)			this->bar->updateHitbox();
            		}
HXLINE( 225)		if (::hx::IsNotNull( this->hscript )) {
HXLINE( 227)			if (this->hscript->exists(HX_("onUpdate",88,7c,b2,66))) {
HXLINE( 227)				this->hscript->call(HX_("onUpdate",88,7c,b2,66),::cpp::VirtualArray_obj::__new(1)->init(0,elapsed));
            			}
HXLINE( 228)			return;
            		}
HXLINE( 233)		 ::states::LoadingState _hx_tmp1 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 233)		_hx_tmp1->timePassed = (_hx_tmp1->timePassed + elapsed);
HXLINE( 234)		 ::states::LoadingState _hx_tmp2 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 234)		_hx_tmp2->shakeFl = (_hx_tmp2->shakeFl + (elapsed * ( (Float)(3000) )));
HXLINE( 235)		::String dots = HX_("",00,00,00,00);
HXLINE( 236)		switch((int)(::Math_obj::floor((::hx::Mod(this->timePassed,1) * ( (Float)(3) ))))){
            			case (int)0: {
HXLINE( 239)				dots = HX_(".",2e,00,00,00);
            			}
            			break;
            			case (int)1: {
HXLINE( 241)				dots = HX_("..",40,28,00,00);
            			}
            			break;
            			case (int)2: {
HXLINE( 243)				dots = HX_("...",ee,0f,23,00);
            			}
            			break;
            		}
HXLINE( 245)		 ::flixel::text::FlxText _hx_tmp3 = this->loadingText;
HXDLIN( 245)		::cpp::VirtualArray values = ::cpp::VirtualArray_obj::__new(1)->init(0,dots);
HXDLIN( 245)		::Dynamic this1 = ::backend::Language_obj::phrases;
HXDLIN( 245)		 ::EReg hideChars =  ::EReg_obj::__alloc( HX_CTX ,HX_("[~&\\\\/;:<>#.,'\"%?!]",85,3f,6d,6d),HX_("g",67,00,00,00));
HXDLIN( 245)		::String str = ( ( ::haxe::ds::StringMap)(this1) )->get_string(::StringTools_obj::trim(hideChars->replace(::StringTools_obj::replace(HX_("now_loading",13,07,bf,10),HX_(" ",20,00,00,00),HX_("_",5f,00,00,00)),HX_("",00,00,00,00)).toLowerCase()));
HXDLIN( 245)		if (::hx::IsNull( str )) {
HXLINE(  62)			str = HX_("Now Loading{1}",75,1a,56,48);
            		}
HXLINE( 245)		if (::hx::IsNull( str )) {
HXLINE(  68)			str = HX_("now_loading",13,07,bf,10);
            		}
HXLINE( 245)		if (::hx::IsNotNull( values )) {
HXLINE( 245)			int _g_current = 0;
HXDLIN( 245)			::cpp::VirtualArray _g_array = values;
HXDLIN( 245)			while((_g_current < _g_array->get_length())){
HXLINE( 245)				 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 245)				_g_current = (_g_current + 1);
HXDLIN( 245)				int _g_key = (_g_current - 1);
HXDLIN( 245)				int num = _g_key;
HXDLIN( 245)				 ::Dynamic value = _g_value;
HXLINE(  72)				str = ::StringTools_obj::replace(str,((HX_("{",7b,00,00,00) + (num + 1)) + HX_("}",7d,00,00,00)),( (::String)(value) ));
            			}
            		}
HXLINE( 245)		_hx_tmp3->set_text(str);
HXLINE( 247)		if (!(this->spawnedPessy)) {
HXLINE( 249)			bool _hx_tmp4;
HXDLIN( 249)			if (!(this->transitioning)) {
HXLINE( 249)				_hx_tmp4 = this->get_controls()->get_ACCEPT();
            			}
            			else {
HXLINE( 249)				_hx_tmp4 = false;
            			}
HXDLIN( 249)			if (_hx_tmp4) {
HXLINE( 251)				this->shakeMult = ( (Float)(1) );
HXLINE( 252)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp5 = ::flixel::FlxG_obj::sound;
HXDLIN( 252)				_hx_tmp5->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("cancelMenu",39,a4,43,b7)),null(),true,null()),null(),null(),null(),null(),null());
HXLINE( 253)				this->pressedTimes++;
            			}
HXLINE( 255)			this->shakeMult = ::Math_obj::max(( (Float)(0) ),(this->shakeMult - (elapsed * ( (Float)(5) ))));
HXLINE( 256)			this->logo->offset->set_x(((::Math_obj::sin(((this->shakeFl * ::Math_obj::PI) / ( (Float)(180) ))) * this->shakeMult) * ( (Float)(100) )));
HXLINE( 258)			if ((this->pressedTimes >= 5)) {
            				HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::states::LoadingState,_gthis) HXARGC(1)
            				void _hx_run( ::flixel::util::FlxTimer tmr){
            					HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_274_update)
HXLINE( 275)					_gthis->pessy->set_x(( (Float)((::flixel::FlxG_obj::width + 200)) ));
HXLINE( 276)					_gthis->pessy->velocity->set_x(( (Float)(-1100) ));
HXLINE( 277)					if (_gthis->pessy->flipX) {
HXLINE( 279)						 ::flixel::FlxSprite _gthis1 = _gthis->pessy;
HXDLIN( 279)						_gthis1->set_x((-(_gthis->pessy->get_width()) - ( (Float)(200) )));
HXLINE( 280)						 ::flixel::FlxSprite fh = _gthis->pessy;
HXDLIN( 280)						fh->velocity->set_x((fh->velocity->x * ( (Float)(-1) )));
            					}
HXLINE( 283)					_gthis->pessy->set_visible(true);
HXLINE( 284)					_gthis->pessy->animation->play(HX_("run",4b,e7,56,00),true,null(),null());
HXLINE( 285)					::backend::Achievements_obj::unlock(HX_("pessy_easter_egg",0b,74,c0,34),null());
HXLINE( 287)					 ::states::LoadingState _gthis2 = _gthis;
HXDLIN( 287)					int _hx_tmp = _gthis->members->indexOf(_gthis->loadingText,null());
HXDLIN( 287)					_gthis2->insert(_hx_tmp,_gthis->pessy).StaticCast<  ::flixel::FlxBasic >();
            				}
            				HX_END_LOCAL_FUNC1((void))

HXLINE( 260)				::flixel::FlxG_obj::camera->fade((int)-1426063361,((Float)0.5),true,null(),null());
HXLINE( 261)				this->logo->set_visible(false);
HXLINE( 262)				this->spawnedPessy = true;
HXLINE( 263)				this->stateChangeDelay = ( (Float)(5) );
HXLINE( 264)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp6 = ::flixel::FlxG_obj::sound;
HXDLIN( 264)				_hx_tmp6->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("secret",70,0e,4a,64)),null(),true,null()),null(),null(),null(),null(),null());
HXLINE( 266)				this->pessy =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,700,140,null());
HXLINE( 267)				 ::flixel::FlxSprite _hx_tmp7 = this->pessy;
HXDLIN( 267)				::String parentFolder = null();
HXDLIN( 267)				if ((HX_("loading_screen/pessy",c4,1d,92,a2).indexOf(HX_("psychic",d5,09,aa,19),null()) != -1)) {
HXLINE( 267)					::haxe::Log_obj::trace(HX_("loading_screen/pessy",c4,1d,92,a2), ::Dynamic(::hx::Anon_obj::Create(5)
            						->setFixed(0,HX_("className",a3,92,3d,dc),HX_("backend.Paths",34,17,99,92))
            						->setFixed(1,HX_("customParams",d7,51,18,ed),::cpp::VirtualArray_obj::__new(2)->init(0,parentFolder)->init(1,true))
            						->setFixed(2,HX_("methodName",cc,19,0f,12),HX_("getSparrowAtlas",55,ab,b7,a7))
            						->setFixed(3,HX_("fileName",e7,5a,43,62),HX_("source/backend/Paths.hx",ff,43,8c,3d))
            						->setFixed(4,HX_("lineNumber",dd,81,22,76),372)));
            				}
HXDLIN( 267)				 ::flixel::graphics::FlxGraphic imageLoaded = ::backend::Paths_obj::image(HX_("loading_screen/pessy",c4,1d,92,a2),parentFolder,true);
HXDLIN( 267)				bool xmlExists = false;
HXDLIN( 267)				::String xml = ::backend::Paths_obj::modFolders(((HX_("images/",77,50,74,c1) + HX_("loading_screen/pessy",c4,1d,92,a2)) + HX_(".xml",69,3e,c3,1e)));
HXDLIN( 267)				if (::sys::FileSystem_obj::exists(xml)) {
HXLINE( 378)					xmlExists = true;
            				}
HXLINE( 267)				 ::Dynamic _hx_tmp8;
HXDLIN( 267)				if (xmlExists) {
HXLINE( 267)					_hx_tmp8 = ::sys::io::File_obj::getContent(xml);
            				}
            				else {
HXLINE( 267)					::String key = (HX_("images/",77,50,74,c1) + HX_("loading_screen/pessy",c4,1d,92,a2));
HXDLIN( 267)					::Dynamic this2 = ::backend::Language_obj::phrases;
HXDLIN( 267)					::String str1 = ( ( ::haxe::ds::StringMap)(this2) )->get_string(::StringTools_obj::trim(key).toLowerCase());
HXDLIN( 267)					if (::hx::IsNotNull( str1 )) {
HXLINE(  82)						key = str1;
            					}
HXLINE( 267)					_hx_tmp8 = ::backend::Paths_obj::getPath((key + HX_(".xml",69,3e,c3,1e)),HX_("TEXT",ad,94,ba,37),parentFolder,null());
            				}
HXDLIN( 267)				_hx_tmp7->set_frames(::flixel::graphics::frames::FlxAtlasFrames_obj::fromSparrow(imageLoaded,_hx_tmp8));
HXLINE( 268)				this->pessy->animation->addByPrefix(HX_("run",4b,e7,56,00),HX_("run",4b,e7,56,00),24,true,null(),null());
HXLINE( 269)				this->pessy->animation->addByPrefix(HX_("spin",c2,e1,58,4c),HX_("spin",c2,e1,58,4c),24,true,null(),null());
HXLINE( 270)				this->pessy->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 271)				this->pessy->set_flipX((this->logo->offset->x > 0));
HXLINE( 272)				this->pessy->set_visible(false);
HXLINE( 274)				 ::flixel::util::FlxTimer_obj::__alloc( HX_CTX ,null())->start(((Float)0.01), ::Dynamic(new _hx_Closure_0(_gthis)),null());
            			}
            		}
            		else {
HXLINE( 291)			bool _hx_tmp9;
HXDLIN( 291)			bool _hx_tmp10;
HXDLIN( 291)			if (!(this->isSpinning)) {
HXLINE( 291)				if (this->pessy->flipX) {
HXLINE( 291)					_hx_tmp10 = (this->pessy->x > ::flixel::FlxG_obj::width);
            				}
            				else {
HXLINE( 291)					_hx_tmp10 = false;
            				}
            			}
            			else {
HXLINE( 291)				_hx_tmp10 = false;
            			}
HXDLIN( 291)			if (!(_hx_tmp10)) {
HXLINE( 291)				if (!(this->pessy->flipX)) {
HXLINE( 291)					Float _hx_tmp11 = this->pessy->x;
HXDLIN( 291)					_hx_tmp9 = (_hx_tmp11 < -(this->pessy->get_width()));
            				}
            				else {
HXLINE( 291)					_hx_tmp9 = false;
            				}
            			}
            			else {
HXLINE( 291)				_hx_tmp9 = true;
            			}
HXDLIN( 291)			if (_hx_tmp9) {
HXLINE( 293)				this->isSpinning = true;
HXLINE( 294)				this->pessy->animation->play(HX_("spin",c2,e1,58,4c),true,null(),null());
HXLINE( 295)				this->pessy->set_flipX(false);
HXLINE( 296)				this->pessy->set_x(( (Float)(500) ));
HXLINE( 297)				this->pessy->set_y(( (Float)((::flixel::FlxG_obj::height + 500)) ));
HXLINE( 298)				this->pessy->velocity->set_x(( (Float)(0) ));
HXLINE( 299)				::flixel::tweens::FlxTween_obj::tween(this->pessy, ::Dynamic(::hx::Anon_obj::Create(1)
            					->setFixed(0,HX_("y",79,00,00,00),10)),((Float)0.65), ::Dynamic(::hx::Anon_obj::Create(1)
            					->setFixed(0,HX_("ease",ee,8b,0c,43),::flixel::tweens::FlxEase_obj::quadOut_dyn())));
            			}
            		}
            	}


void LoadingState_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_306_destroy)
HXLINE( 307)		if (::hx::IsNotNull( this->hscript )) {
HXLINE( 309)			if (this->hscript->exists(HX_("onDestroy",9b,e5,30,fc))) {
HXLINE( 309)				this->hscript->call(HX_("onDestroy",9b,e5,30,fc),null());
            			}
HXLINE( 310)			this->hscript->destroy();
            		}
HXLINE( 312)		this->hscript = null();
HXLINE( 313)		this->super::destroy();
            	}


void LoadingState_obj::onLoad(){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_319_onLoad)
HXLINE( 320)		::states::LoadingState_obj::_loaded();
HXLINE( 322)		bool _hx_tmp;
HXDLIN( 322)		if (this->stopMusic) {
HXLINE( 322)			_hx_tmp = ::hx::IsNotNull( ::flixel::FlxG_obj::sound->music );
            		}
            		else {
HXLINE( 322)			_hx_tmp = false;
            		}
HXDLIN( 322)		if (_hx_tmp) {
HXLINE( 323)			 ::flixel::sound::FlxSound _this = ::flixel::FlxG_obj::sound->music;
HXDLIN( 323)			_this->cleanup(_this->autoDestroy,true);
            		}
HXLINE( 325)		::flixel::FlxG_obj::camera->set_visible(false);
HXLINE( 326)		::backend::MusicBeatState_obj::switchState(this->target);
HXLINE( 327)		this->transitioning = true;
HXLINE( 328)		this->finishedLoading = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(LoadingState_obj,onLoad,(void))

int LoadingState_obj::loaded;

int LoadingState_obj::loadMax;

 ::haxe::ds::StringMap LoadingState_obj::originalBitmapKeys;

 ::haxe::ds::StringMap LoadingState_obj::requestedBitmaps;

 ::sys::thread::Mutex LoadingState_obj::mutex;

 ::sys::thread::FixedThreadPool LoadingState_obj::threadPool;

void LoadingState_obj::loadAndSwitchState( ::flixel::FlxState target,::hx::Null< bool >  __o_stopMusic,::hx::Null< bool >  __o_intrusive){
            		bool stopMusic = __o_stopMusic.Default(false);
            		bool intrusive = __o_intrusive.Default(true);
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_58_loadAndSwitchState)
HXDLIN(  58)		::backend::MusicBeatState_obj::switchState(::states::LoadingState_obj::getNextState(target,stopMusic,intrusive));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(LoadingState_obj,loadAndSwitchState,(void))

void LoadingState_obj::_loaded(){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_332__loaded)
HXLINE( 333)		::states::LoadingState_obj::loaded = 0;
HXLINE( 334)		::states::LoadingState_obj::loadMax = 0;
HXLINE( 335)		::states::LoadingState_obj::initialThreadCompleted = true;
HXLINE( 336)		::states::LoadingState_obj::isIntrusive = false;
HXLINE( 338)		::flixel::addons::transition::FlxTransitionableState_obj::skipNextTransIn = true;
HXLINE( 339)		if (::hx::IsNotNull( ::states::LoadingState_obj::threadPool )) {
HXLINE( 339)			::states::LoadingState_obj::threadPool->shutdown();
            		}
HXLINE( 340)		::states::LoadingState_obj::threadPool = null();
HXLINE( 341)		::states::LoadingState_obj::mutex = null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(LoadingState_obj,_loaded,(void))

bool LoadingState_obj::checkLoaded(){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_345_checkLoaded)
HXLINE( 346)		{
HXLINE( 346)			::Dynamic map = ::states::LoadingState_obj::requestedBitmaps;
HXDLIN( 346)			::Dynamic _g_map = map;
HXDLIN( 346)			 ::Dynamic _g_keys = ::haxe::IMap_obj::keys(map);
HXDLIN( 346)			while(( (bool)(_g_keys->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 346)				::String key = ( (::String)(_g_keys->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXDLIN( 346)				 ::openfl::display::BitmapData _g_value = ( ( ::openfl::display::BitmapData)(::haxe::IMap_obj::get(_g_map,key)) );
HXDLIN( 346)				::String _g_key = key;
HXDLIN( 346)				::String key1 = _g_key;
HXDLIN( 346)				 ::openfl::display::BitmapData bitmap = _g_value;
HXLINE( 348)				bool _hx_tmp;
HXDLIN( 348)				if (::hx::IsNotNull( bitmap )) {
HXLINE( 348)					_hx_tmp = ::hx::IsNotNull( ::backend::Paths_obj::cacheBitmap(::states::LoadingState_obj::originalBitmapKeys->get_string(key1),null(),bitmap,null()) );
            				}
            				else {
HXLINE( 348)					_hx_tmp = false;
            				}
HXDLIN( 348)				if (!(_hx_tmp)) {
HXLINE( 349)					::haxe::Log_obj::trace((HX_("failed to cache image ",e5,67,30,2e) + key1),::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),349,HX_("states.LoadingState",c1,f4,c4,7f),HX_("checkLoaded",ed,1a,81,3a)));
            				}
            			}
            		}
HXLINE( 351)		::states::LoadingState_obj::requestedBitmaps->clear();
HXLINE( 352)		::states::LoadingState_obj::originalBitmapKeys->clear();
HXLINE( 354)		if ((::states::LoadingState_obj::loaded >= ::states::LoadingState_obj::loadMax)) {
HXLINE( 354)			return ::states::LoadingState_obj::initialThreadCompleted;
            		}
            		else {
HXLINE( 354)			return false;
            		}
HXDLIN( 354)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(LoadingState_obj,checkLoaded,return )

void LoadingState_obj::loadNextDirectory(){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_358_loadNextDirectory)
HXLINE( 359)		::String directory = HX_("shared",a5,5e,2b,1d);
HXLINE( 360)		::String weekDir = ::backend::StageData_obj::forceNextDirectory;
HXLINE( 361)		::backend::StageData_obj::forceNextDirectory = null();
HXLINE( 363)		bool _hx_tmp;
HXDLIN( 363)		bool _hx_tmp1;
HXDLIN( 363)		if (::hx::IsNotNull( weekDir )) {
HXLINE( 363)			_hx_tmp1 = (weekDir.length > 0);
            		}
            		else {
HXLINE( 363)			_hx_tmp1 = false;
            		}
HXDLIN( 363)		if (_hx_tmp1) {
HXLINE( 363)			_hx_tmp = (weekDir != HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 363)			_hx_tmp = false;
            		}
HXDLIN( 363)		if (_hx_tmp) {
HXLINE( 363)			directory = weekDir;
            		}
HXLINE( 365)		::backend::Paths_obj::setCurrentLevel(directory);
HXLINE( 366)		::haxe::Log_obj::trace((HX_("Setting asset folder to ",b3,9c,5c,a5) + directory),::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),366,HX_("states.LoadingState",c1,f4,c4,7f),HX_("loadNextDirectory",f4,6c,0f,89)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(LoadingState_obj,loadNextDirectory,(void))

bool LoadingState_obj::isIntrusive;

 ::flixel::FlxState LoadingState_obj::getNextState( ::flixel::FlxState target,::hx::Null< bool >  __o_stopMusic,::hx::Null< bool >  __o_intrusive){
            		bool stopMusic = __o_stopMusic.Default(false);
            		bool intrusive = __o_intrusive.Default(true);
            	HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_371_getNextState)
HXLINE( 376)		::states::LoadingState_obj::isIntrusive = intrusive;
HXLINE( 377)		::states::LoadingState_obj::_startPool();
HXLINE( 378)		::states::LoadingState_obj::loadNextDirectory();
HXLINE( 380)		if (intrusive) {
HXLINE( 381)			return  ::states::LoadingState_obj::__alloc( HX_CTX ,target,stopMusic);
            		}
HXLINE( 383)		bool _hx_tmp;
HXDLIN( 383)		if (stopMusic) {
HXLINE( 383)			_hx_tmp = ::hx::IsNotNull( ::flixel::FlxG_obj::sound->music );
            		}
            		else {
HXLINE( 383)			_hx_tmp = false;
            		}
HXDLIN( 383)		if (_hx_tmp) {
HXLINE( 384)			 ::flixel::sound::FlxSound _this = ::flixel::FlxG_obj::sound->music;
HXDLIN( 384)			_this->cleanup(_this->autoDestroy,true);
            		}
HXLINE( 386)		while(true){
HXLINE( 388)			if (::states::LoadingState_obj::checkLoaded()) {
HXLINE( 390)				::states::LoadingState_obj::_loaded();
HXLINE( 391)				goto _hx_goto_16;
            			}
            			else {
HXLINE( 393)				::Sys_obj::sleep(((Float)0.001));
            			}
            		}
            		_hx_goto_16:;
HXLINE( 395)		return target;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(LoadingState_obj,getNextState,return )

::Array< ::String > LoadingState_obj::imagesToPrepare;

::Array< ::String > LoadingState_obj::soundsToPrepare;

::Array< ::String > LoadingState_obj::musicToPrepare;

::Array< ::String > LoadingState_obj::songsToPrepare;

void LoadingState_obj::prepare(::Array< ::String > images,::Array< ::String > sounds,::Array< ::String > music){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_403_prepare)
HXLINE( 404)		if (::hx::IsNotNull( images )) {
HXLINE( 404)			::states::LoadingState_obj::imagesToPrepare = ::states::LoadingState_obj::imagesToPrepare->concat(images);
            		}
HXLINE( 405)		if (::hx::IsNotNull( sounds )) {
HXLINE( 405)			::states::LoadingState_obj::soundsToPrepare = ::states::LoadingState_obj::soundsToPrepare->concat(sounds);
            		}
HXLINE( 406)		if (::hx::IsNotNull( music )) {
HXLINE( 406)			::states::LoadingState_obj::musicToPrepare = ::states::LoadingState_obj::musicToPrepare->concat(music);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(LoadingState_obj,prepare,(void))

bool LoadingState_obj::initialThreadCompleted;

bool LoadingState_obj::dontPreloadDefaultVoices;

void LoadingState_obj::_startPool(){
            	HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_412__startPool)
HXLINE( 415)		int threadCount = ::Std_obj::_hx_int(::Math_obj::max(( (Float)(1) ),( (Float)((::states::LoadingState_obj::getCPUThreadsCount() - 2)) )));
HXLINE( 419)		::states::LoadingState_obj::threadPool =  ::sys::thread::FixedThreadPool_obj::__alloc( HX_CTX ,threadCount);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(LoadingState_obj,_startPool,(void))

void LoadingState_obj::prepareToSong(){
            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0,::Array< int >,threadsMax,::Array< int >,threadsCompleted) HXARGC(0)
            		void _hx_run(){
            			HX_STACKFRAME(&_hx_pos_670a7524baf7a379_447_prepareToSong)
HXLINE( 448)			threadsCompleted[0]++;
HXLINE( 449)			if ((threadsCompleted->__get(0) == threadsMax->__get(0))) {
HXLINE( 451)				::states::LoadingState_obj::clearInvalids();
HXLINE( 452)				::states::LoadingState_obj::startThreads();
HXLINE( 453)				::states::LoadingState_obj::initialThreadCompleted = true;
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1,::String,folder) HXARGC(0)
            		bool _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_459_prepareToSong)
HXLINE( 461)			::String noteSkin = ::objects::Note_obj::defaultNoteSkin;
HXLINE( 462)			bool _hx_tmp;
HXDLIN( 462)			if (::hx::IsNotNull( ::states::PlayState_obj::SONG->__Field(HX_("arrowSkin",e6,d4,f8,07),::hx::paccDynamic) )) {
HXLINE( 462)				_hx_tmp = (( (::String)(::states::PlayState_obj::SONG->__Field(HX_("arrowSkin",e6,d4,f8,07),::hx::paccDynamic)) ).length > 1);
            			}
            			else {
HXLINE( 462)				_hx_tmp = false;
            			}
HXDLIN( 462)			if (_hx_tmp) {
HXLINE( 462)				noteSkin = ( (::String)(::states::PlayState_obj::SONG->__Field(HX_("arrowSkin",e6,d4,f8,07),::hx::paccDynamic)) );
            			}
HXLINE( 464)			::String customSkin = (noteSkin + ::objects::Note_obj::getNoteSkinPostfix());
HXLINE( 465)			if (::backend::Paths_obj::fileExists(((HX_("images/",77,50,74,c1) + customSkin) + HX_(".png",3b,2d,bd,1e)),HX_("IMAGE",3b,57,57,3b),null(),null())) {
HXLINE( 465)				noteSkin = customSkin;
            			}
HXLINE( 466)			::states::LoadingState_obj::imagesToPrepare->push(noteSkin);
HXLINE( 470)			::String noteSplash = ::objects::NoteSplash_obj::defaultNoteSplash;
HXLINE( 471)			bool _hx_tmp1;
HXDLIN( 471)			if (::hx::IsNotNull( ::states::PlayState_obj::SONG->__Field(HX_("splashSkin",84,03,e1,a1),::hx::paccDynamic) )) {
HXLINE( 471)				_hx_tmp1 = (( (::String)(::states::PlayState_obj::SONG->__Field(HX_("splashSkin",84,03,e1,a1),::hx::paccDynamic)) ).length > 0);
            			}
            			else {
HXLINE( 471)				_hx_tmp1 = false;
            			}
HXDLIN( 471)			if (_hx_tmp1) {
HXLINE( 471)				noteSplash = ( (::String)(::states::PlayState_obj::SONG->__Field(HX_("splashSkin",84,03,e1,a1),::hx::paccDynamic)) );
            			}
            			else {
HXLINE( 472)				noteSplash = (noteSplash + ::objects::NoteSplash_obj::getSplashSkinPostfix());
            			}
HXLINE( 473)			::states::LoadingState_obj::imagesToPrepare->push(noteSplash);
HXLINE( 475)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 477)				::String folder1 = null();
HXDLIN( 477)				::String path = ::backend::Paths_obj::getPath(((HX_("data/",c5,0e,88,d4) + ((HX_("",00,00,00,00) + folder) + HX_("/preload",7a,3b,86,b5))) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),folder1,true);
HXLINE( 478)				 ::Dynamic json = null();
HXLINE( 481)				::String moddyFile = ::backend::Paths_obj::modFolders(((HX_("data/",c5,0e,88,d4) + ((HX_("",00,00,00,00) + folder) + HX_("/preload",7a,3b,86,b5))) + HX_(".json",56,f1,d6,c2)));
HXLINE( 482)				if (::sys::FileSystem_obj::exists(moddyFile)) {
HXLINE( 482)					json =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::sys::io::File_obj::getContent(moddyFile))->doParse();
            				}
            				else {
HXLINE( 483)					json =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::sys::io::File_obj::getContent(path))->doParse();
            				}
HXLINE( 488)				if (::hx::IsNotNull( json )) {
HXLINE( 490)					::Array< ::String > imgs = ::Array_obj< ::String >::__new(0);
HXLINE( 491)					::Array< ::String > snds = ::Array_obj< ::String >::__new(0);
HXLINE( 492)					::Array< ::String > mscs = ::Array_obj< ::String >::__new(0);
HXLINE( 493)					{
HXLINE( 493)						int _g = 0;
HXDLIN( 493)						::Array< ::String > _g1 = ::Reflect_obj::fields(json);
HXDLIN( 493)						while((_g < _g1->length)){
HXLINE( 493)							::String asset = _g1->__get(_g);
HXDLIN( 493)							_g = (_g + 1);
HXLINE( 495)							int filters = ( (int)(::Reflect_obj::field(json,asset)) );
HXLINE( 496)							::String asset1 = ::StringTools_obj::trim(asset);
HXLINE( 498)							bool _hx_tmp2;
HXDLIN( 498)							if ((filters >= 0)) {
HXLINE( 498)								_hx_tmp2 = ::backend::StageData_obj::validateVisibility(filters);
            							}
            							else {
HXLINE( 498)								_hx_tmp2 = true;
            							}
HXDLIN( 498)							if (_hx_tmp2) {
HXLINE( 500)								if (::StringTools_obj::startsWith(asset1,HX_("images/",77,50,74,c1))) {
HXLINE( 501)									imgs->push(asset1.substr(HX_("images/",77,50,74,c1).length,null()));
            								}
            								else {
HXLINE( 502)									if (::StringTools_obj::startsWith(asset1,HX_("sounds/",eb,02,a5,b6))) {
HXLINE( 503)										snds->push(asset1.substr(HX_("sounds/",eb,02,a5,b6).length,null()));
            									}
            									else {
HXLINE( 504)										if (::StringTools_obj::startsWith(asset1,HX_("music/",ea,bf,1b,3f))) {
HXLINE( 505)											mscs->push(asset1.substr(HX_("music/",ea,bf,1b,3f).length,null()));
            										}
            									}
            								}
            							}
            						}
            					}
HXLINE( 508)					::states::LoadingState_obj::prepare(imgs,snds,mscs);
            				}
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g2 = _hx_e;
HXLINE( 511)					{
HXLINE( 511)						null();
            					}
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
HXLINE( 512)			return true;
            		}
            		HX_END_LOCAL_FUNC0(return)

            		HX_BEGIN_LOCAL_FUNC_S5(::hx::LocalFunc,_hx_Closure_5,::Array< int >,threadsMax, ::Dynamic,song, ::Dynamic,completedThread,::Array< int >,threadsCompleted,::String,folder) HXARGC(1)
            		 ::lime::app::Future _hx_run(bool _){
            			HX_BEGIN_LOCAL_FUNC_S5(::hx::LocalFunc,_hx_Closure_4,::Array< int >,threadsMax, ::Dynamic,song,::Array< int >,threadsCompleted, ::Dynamic,completedThread,::String,folder) HXARGC(0)
            			bool _hx_run(){
            				HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_514_prepareToSong)
HXLINE( 515)				bool _hx_tmp;
HXDLIN( 515)				if (::hx::IsNotNull( song->__Field(HX_("stage",be,6a,0b,84),::hx::paccDynamic) )) {
HXLINE( 515)					_hx_tmp = (( (::String)(song->__Field(HX_("stage",be,6a,0b,84),::hx::paccDynamic)) ).length < 1);
            				}
            				else {
HXLINE( 515)					_hx_tmp = true;
            				}
HXDLIN( 515)				if (_hx_tmp) {
HXLINE( 516)					song->__SetField(HX_("stage",be,6a,0b,84),::backend::StageData_obj::vanillaSongStage(folder),::hx::paccDynamic);
            				}
HXLINE( 518)				 ::Dynamic stageData = ::backend::StageData_obj::getStageFile(( (::String)(song->__Field(HX_("stage",be,6a,0b,84),::hx::paccDynamic)) ));
HXLINE( 519)				if (::hx::IsNotNull( stageData )) {
HXLINE( 521)					::Array< ::String > imgs = ::Array_obj< ::String >::__new(0);
HXLINE( 522)					::Array< ::String > snds = ::Array_obj< ::String >::__new(0);
HXLINE( 523)					::Array< ::String > mscs = ::Array_obj< ::String >::__new(0);
HXLINE( 524)					if (::hx::IsNotNull( stageData->__Field(HX_("preload",c9,47,43,35),::hx::paccDynamic) )) {
HXLINE( 526)						int _g = 0;
HXDLIN( 526)						::Array< ::String > _g1 = ::Reflect_obj::fields( ::Dynamic(stageData->__Field(HX_("preload",c9,47,43,35),::hx::paccDynamic)));
HXDLIN( 526)						while((_g < _g1->length)){
HXLINE( 526)							::String asset = _g1->__get(_g);
HXDLIN( 526)							_g = (_g + 1);
HXLINE( 528)							int filters = ( (int)(::Reflect_obj::field( ::Dynamic(stageData->__Field(HX_("preload",c9,47,43,35),::hx::paccDynamic)),asset)) );
HXLINE( 529)							::String asset1 = ::StringTools_obj::trim(asset);
HXLINE( 531)							bool _hx_tmp1;
HXDLIN( 531)							if ((filters >= 0)) {
HXLINE( 531)								_hx_tmp1 = ::backend::StageData_obj::validateVisibility(filters);
            							}
            							else {
HXLINE( 531)								_hx_tmp1 = true;
            							}
HXDLIN( 531)							if (_hx_tmp1) {
HXLINE( 533)								if (::StringTools_obj::startsWith(asset1,HX_("images/",77,50,74,c1))) {
HXLINE( 534)									imgs->push(asset1.substr(HX_("images/",77,50,74,c1).length,null()));
            								}
            								else {
HXLINE( 535)									if (::StringTools_obj::startsWith(asset1,HX_("sounds/",eb,02,a5,b6))) {
HXLINE( 536)										snds->push(asset1.substr(HX_("sounds/",eb,02,a5,b6).length,null()));
            									}
            									else {
HXLINE( 537)										if (::StringTools_obj::startsWith(asset1,HX_("music/",ea,bf,1b,3f))) {
HXLINE( 538)											mscs->push(asset1.substr(HX_("music/",ea,bf,1b,3f).length,null()));
            										}
            									}
            								}
            							}
            						}
            					}
HXLINE( 543)					if (::hx::IsNotNull( stageData->__Field(HX_("objects",d4,68,4f,82),::hx::paccDynamic) )) {
HXLINE( 545)						int _g2 = 0;
HXDLIN( 545)						::cpp::VirtualArray _g3 = ( (::cpp::VirtualArray)(stageData->__Field(HX_("objects",d4,68,4f,82),::hx::paccDynamic)) );
HXDLIN( 545)						while((_g2 < _g3->get_length())){
HXLINE( 545)							 ::Dynamic sprite = _g3->__get(_g2);
HXDLIN( 545)							_g2 = (_g2 + 1);
HXLINE( 547)							bool _hx_tmp2;
HXDLIN( 547)							if (::hx::IsNotEq( sprite->__Field(HX_("type",ba,f2,08,4d),::hx::paccDynamic),HX_("sprite",05,dc,95,c3) )) {
HXLINE( 547)								_hx_tmp2 = ::hx::IsEq( sprite->__Field(HX_("type",ba,f2,08,4d),::hx::paccDynamic),HX_("animatedSprite",08,df,a8,cb) );
            							}
            							else {
HXLINE( 547)								_hx_tmp2 = true;
            							}
HXDLIN( 547)							if (_hx_tmp2) {
HXLINE( 548)								bool _hx_tmp3;
HXDLIN( 548)								bool _hx_tmp4;
HXDLIN( 548)								if (!(::hx::IsLess( sprite->__Field(HX_("filters",bb,a1,46,09),::hx::paccDynamic),0 ))) {
HXLINE( 548)									_hx_tmp4 = ::backend::StageData_obj::validateVisibility(( (int)(sprite->__Field(HX_("filters",bb,a1,46,09),::hx::paccDynamic)) ));
            								}
            								else {
HXLINE( 548)									_hx_tmp4 = true;
            								}
HXDLIN( 548)								if (_hx_tmp4) {
HXLINE( 548)									_hx_tmp3 = !(imgs->contains( ::Dynamic(sprite->__Field(HX_("image",5b,1f,69,bd),::hx::paccDynamic))));
            								}
            								else {
HXLINE( 548)									_hx_tmp3 = false;
            								}
HXDLIN( 548)								if (_hx_tmp3) {
HXLINE( 549)									imgs->push( ::Dynamic(sprite->__Field(HX_("image",5b,1f,69,bd),::hx::paccDynamic)));
            								}
            							}
            						}
            					}
HXLINE( 552)					::states::LoadingState_obj::prepare(imgs,snds,mscs);
            				}
HXLINE( 555)				::states::LoadingState_obj::songsToPrepare->push(((HX_("",00,00,00,00) + folder) + HX_("/Inst",95,b3,69,40)));
HXLINE( 557)				::String player1 = ( (::String)(song->__Field(HX_("player1",b0,09,15,8a),::hx::paccDynamic)) );
HXLINE( 558)				::String player2 = ( (::String)(song->__Field(HX_("player2",b1,09,15,8a),::hx::paccDynamic)) );
HXLINE( 559)				::Array< ::String > gfVersion = ::Array_obj< ::String >::__new(1)->init(0, ::Dynamic(song->__Field(HX_("gfVersion",b9,c6,7d,f3),::hx::paccDynamic)));
HXLINE( 560)				::String prefixVocals;
HXDLIN( 560)				if (( (bool)(song->__Field(HX_("needsVoices",be,05,e9,0d),::hx::paccDynamic)) )) {
HXLINE( 560)					prefixVocals = ((HX_("",00,00,00,00) + folder) + HX_("/Voices",10,18,4f,34));
            				}
            				else {
HXLINE( 560)					prefixVocals = null();
            				}
HXLINE( 561)				if (::hx::IsNull( gfVersion->__get(0) )) {
HXLINE( 561)					gfVersion[0] = HX_("gf",1f,5a,00,00);
            				}
HXLINE( 563)				::states::LoadingState_obj::dontPreloadDefaultVoices = false;
HXLINE( 564)				try {
            					HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 564)					::String path = ::backend::Paths_obj::getPath(((HX_("characters/",45,3c,bf,be) + player1) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),null(),null());
HXDLIN( 564)					 ::Dynamic character =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::sys::io::File_obj::getContent(path))->doParse();
HXDLIN( 564)					bool isAnimateAtlas = false;
HXDLIN( 564)					::String img = ( (::String)(character->__Field(HX_("image",5b,1f,69,bd),::hx::paccDynamic)) );
HXDLIN( 564)					img = ::StringTools_obj::trim(img);
HXDLIN( 564)					::String animToFind = ::backend::Paths_obj::getPath(((HX_("images/",77,50,74,c1) + img) + HX_("/Animation.json",61,fc,54,44)),HX_("TEXT",ad,94,ba,37),null(),null());
HXDLIN( 564)					bool _hx_tmp5;
HXDLIN( 564)					if (!(::sys::FileSystem_obj::exists(animToFind))) {
HXLINE( 564)						_hx_tmp5 = ::lime::utils::Assets_obj::exists(animToFind,null());
            					}
            					else {
HXLINE( 564)						_hx_tmp5 = true;
            					}
HXDLIN( 564)					if (_hx_tmp5) {
HXLINE( 564)						isAnimateAtlas = true;
            					}
HXDLIN( 564)					if (!(isAnimateAtlas)) {
HXLINE( 564)						::Array< ::String > split = img.split(HX_(",",2c,00,00,00));
HXDLIN( 564)						{
HXLINE( 564)							int _g4 = 0;
HXDLIN( 564)							while((_g4 < split->length)){
HXLINE( 564)								::String file = split->__get(_g4);
HXDLIN( 564)								_g4 = (_g4 + 1);
HXDLIN( 564)								::Array< ::String > _hx_tmp6 = ::states::LoadingState_obj::imagesToPrepare;
HXDLIN( 564)								_hx_tmp6->push(::StringTools_obj::trim(file));
            							}
            						}
            					}
            					else {
HXLINE( 564)						int _g5 = 0;
HXDLIN( 564)						while((_g5 < 10)){
HXLINE( 564)							_g5 = (_g5 + 1);
HXDLIN( 564)							int i = (_g5 - 1);
HXDLIN( 564)							::String st = (HX_("",00,00,00,00) + i);
HXDLIN( 564)							if ((i == 0)) {
HXLINE( 564)								st = HX_("",00,00,00,00);
            							}
HXDLIN( 564)							if (::backend::Paths_obj::fileExists(((((HX_("images/",77,50,74,c1) + img) + HX_("/spritemap",a8,c1,c8,a3)) + st) + HX_(".png",3b,2d,bd,1e)),HX_("IMAGE",3b,57,57,3b),null(),null())) {
HXLINE( 564)								::states::LoadingState_obj::imagesToPrepare->push((((HX_("",00,00,00,00) + img) + HX_("/spritemap",a8,c1,c8,a3)) + st));
HXDLIN( 564)								goto _hx_goto_24;
            							}
            						}
            						_hx_goto_24:;
            					}
HXDLIN( 564)					bool _hx_tmp7;
HXDLIN( 564)					bool _hx_tmp8;
HXDLIN( 564)					if (::hx::IsNotNull( prefixVocals )) {
HXLINE( 564)						_hx_tmp8 = ::hx::IsNotNull( character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic) );
            					}
            					else {
HXLINE( 564)						_hx_tmp8 = false;
            					}
HXDLIN( 564)					if (_hx_tmp8) {
HXLINE( 564)						_hx_tmp7 = ::hx::IsGreater(  ::Dynamic(character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic))->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic),0 );
            					}
            					else {
HXLINE( 564)						_hx_tmp7 = false;
            					}
HXDLIN( 564)					if (_hx_tmp7) {
HXLINE( 564)						::Array< ::String > _hx_tmp9 = ::states::LoadingState_obj::songsToPrepare;
HXDLIN( 564)						::String _hx_tmp10 = (prefixVocals + HX_("-",2d,00,00,00));
HXDLIN( 564)						_hx_tmp9->push((_hx_tmp10 + ::Std_obj::string( ::Dynamic(character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic)))));
HXDLIN( 564)						if (::hx::IsEq( player1,::states::PlayState_obj::SONG->__Field(HX_("player1",b0,09,15,8a),::hx::paccDynamic) )) {
HXLINE( 564)							::states::LoadingState_obj::dontPreloadDefaultVoices = true;
            						}
            					}
            				} catch( ::Dynamic _hx_e) {
            					if (_hx_e.IsClass<  ::Dynamic >() ){
            						HX_STACK_BEGIN_CATCH
            						 ::Dynamic _g6 = _hx_e;
HXLINE( 762)						 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g6);
HXLINE( 564)						{
HXLINE( 564)							 ::Dynamic _hx_tmp11 = ::haxe::Log_obj::trace;
HXDLIN( 564)							::String _hx_tmp12 = e->details();
HXDLIN( 564)							_hx_tmp11(_hx_tmp12,::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),764,HX_("states.LoadingState",c1,f4,c4,7f),HX_("preloadCharacter",a0,b2,b8,0f)));
            						}
            					}
            					else {
            						HX_STACK_DO_THROW(_hx_e);
            					}
            				}
HXLINE( 565)				bool _hx_tmp13;
HXDLIN( 565)				if (!(::states::LoadingState_obj::dontPreloadDefaultVoices)) {
HXLINE( 565)					_hx_tmp13 = ::hx::IsNotNull( prefixVocals );
            				}
            				else {
HXLINE( 565)					_hx_tmp13 = false;
            				}
HXDLIN( 565)				if (_hx_tmp13) {
HXLINE( 567)					bool _hx_tmp14;
HXDLIN( 567)					if (::backend::Paths_obj::fileExists((((HX_("",00,00,00,00) + prefixVocals) + HX_("-Player.",00,41,44,65)) + HX_("ogg",4f,94,54,00)),HX_("SOUND",af,c4,ba,fe),false,HX_("songs",fe,36,c7,80))) {
HXLINE( 567)						_hx_tmp14 = ::backend::Paths_obj::fileExists((((HX_("",00,00,00,00) + prefixVocals) + HX_("-Opponent.",04,a2,d3,17)) + HX_("ogg",4f,94,54,00)),HX_("SOUND",af,c4,ba,fe),false,HX_("songs",fe,36,c7,80));
            					}
            					else {
HXLINE( 567)						_hx_tmp14 = false;
            					}
HXDLIN( 567)					if (_hx_tmp14) {
HXLINE( 569)						::states::LoadingState_obj::songsToPrepare->push(((HX_("",00,00,00,00) + prefixVocals) + HX_("-Player",6e,3f,93,bb)));
HXLINE( 570)						::states::LoadingState_obj::songsToPrepare->push(((HX_("",00,00,00,00) + prefixVocals) + HX_("-Opponent",ea,ea,d9,e6)));
            					}
            					else {
HXLINE( 572)						if (::backend::Paths_obj::fileExists((((HX_("",00,00,00,00) + prefixVocals) + HX_(".",2e,00,00,00)) + HX_("ogg",4f,94,54,00)),HX_("SOUND",af,c4,ba,fe),false,HX_("songs",fe,36,c7,80))) {
HXLINE( 573)							::states::LoadingState_obj::songsToPrepare->push(prefixVocals);
            						}
            					}
            				}
HXLINE( 576)				if ((player2 != player1)) {
            					HX_BEGIN_LOCAL_FUNC_S3(::hx::LocalFunc,_hx_Closure_2,::String,prefixVocals,::String,player2, ::Dynamic,completedThread) HXARGC(0)
            					void _hx_run(){
            						HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_579_prepareToSong)
HXLINE( 580)						try {
            							HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 580)							try {
            								HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 580)								::String path = ::backend::Paths_obj::getPath(((HX_("characters/",45,3c,bf,be) + player2) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),null(),null());
HXDLIN( 580)								 ::Dynamic character =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::sys::io::File_obj::getContent(path))->doParse();
HXDLIN( 580)								bool isAnimateAtlas = false;
HXDLIN( 580)								::String img = ( (::String)(character->__Field(HX_("image",5b,1f,69,bd),::hx::paccDynamic)) );
HXDLIN( 580)								img = ::StringTools_obj::trim(img);
HXDLIN( 580)								::String animToFind = ::backend::Paths_obj::getPath(((HX_("images/",77,50,74,c1) + img) + HX_("/Animation.json",61,fc,54,44)),HX_("TEXT",ad,94,ba,37),null(),null());
HXDLIN( 580)								bool _hx_tmp;
HXDLIN( 580)								if (!(::sys::FileSystem_obj::exists(animToFind))) {
HXLINE( 580)									_hx_tmp = ::lime::utils::Assets_obj::exists(animToFind,null());
            								}
            								else {
HXLINE( 580)									_hx_tmp = true;
            								}
HXDLIN( 580)								if (_hx_tmp) {
HXLINE( 580)									isAnimateAtlas = true;
            								}
HXDLIN( 580)								if (!(isAnimateAtlas)) {
HXLINE( 580)									::Array< ::String > split = img.split(HX_(",",2c,00,00,00));
HXDLIN( 580)									{
HXLINE( 580)										int _g = 0;
HXDLIN( 580)										while((_g < split->length)){
HXLINE( 580)											::String file = split->__get(_g);
HXDLIN( 580)											_g = (_g + 1);
HXDLIN( 580)											::Array< ::String > _hx_tmp1 = ::states::LoadingState_obj::imagesToPrepare;
HXDLIN( 580)											_hx_tmp1->push(::StringTools_obj::trim(file));
            										}
            									}
            								}
            								else {
HXLINE( 580)									int _g1 = 0;
HXDLIN( 580)									while((_g1 < 10)){
HXLINE( 580)										_g1 = (_g1 + 1);
HXDLIN( 580)										int i = (_g1 - 1);
HXDLIN( 580)										::String st = (HX_("",00,00,00,00) + i);
HXDLIN( 580)										if ((i == 0)) {
HXLINE( 580)											st = HX_("",00,00,00,00);
            										}
HXDLIN( 580)										if (::backend::Paths_obj::fileExists(((((HX_("images/",77,50,74,c1) + img) + HX_("/spritemap",a8,c1,c8,a3)) + st) + HX_(".png",3b,2d,bd,1e)),HX_("IMAGE",3b,57,57,3b),null(),null())) {
HXLINE( 580)											::states::LoadingState_obj::imagesToPrepare->push((((HX_("",00,00,00,00) + img) + HX_("/spritemap",a8,c1,c8,a3)) + st));
HXDLIN( 580)											goto _hx_goto_26;
            										}
            									}
            									_hx_goto_26:;
            								}
HXDLIN( 580)								bool _hx_tmp2;
HXDLIN( 580)								bool _hx_tmp3;
HXDLIN( 580)								if (::hx::IsNotNull( prefixVocals )) {
HXLINE( 580)									_hx_tmp3 = ::hx::IsNotNull( character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic) );
            								}
            								else {
HXLINE( 580)									_hx_tmp3 = false;
            								}
HXDLIN( 580)								if (_hx_tmp3) {
HXLINE( 580)									_hx_tmp2 = ::hx::IsGreater(  ::Dynamic(character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic))->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic),0 );
            								}
            								else {
HXLINE( 580)									_hx_tmp2 = false;
            								}
HXDLIN( 580)								if (_hx_tmp2) {
HXLINE( 580)									::Array< ::String > _hx_tmp4 = ::states::LoadingState_obj::songsToPrepare;
HXDLIN( 580)									::String _hx_tmp5 = (prefixVocals + HX_("-",2d,00,00,00));
HXDLIN( 580)									_hx_tmp4->push((_hx_tmp5 + ::Std_obj::string( ::Dynamic(character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic)))));
HXDLIN( 580)									if (::hx::IsEq( player2,::states::PlayState_obj::SONG->__Field(HX_("player1",b0,09,15,8a),::hx::paccDynamic) )) {
HXLINE( 580)										::states::LoadingState_obj::dontPreloadDefaultVoices = true;
            									}
            								}
            							} catch( ::Dynamic _hx_e) {
            								if (_hx_e.IsClass<  ::Dynamic >() ){
            									HX_STACK_BEGIN_CATCH
            									 ::Dynamic _g2 = _hx_e;
HXLINE( 762)									 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g2);
HXLINE( 580)									{
HXLINE( 580)										 ::Dynamic _hx_tmp6 = ::haxe::Log_obj::trace;
HXDLIN( 580)										::String _hx_tmp7 = e->details();
HXDLIN( 580)										_hx_tmp6(_hx_tmp7,::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),764,HX_("states.LoadingState",c1,f4,c4,7f),HX_("preloadCharacter",a0,b2,b8,0f)));
            									}
            								}
            								else {
            									HX_STACK_DO_THROW(_hx_e);
            								}
            							}
            						} catch( ::Dynamic _hx_e) {
            							if (_hx_e.IsClass<  ::Dynamic >() ){
            								HX_STACK_BEGIN_CATCH
            								 ::Dynamic _g3 = _hx_e;
HXLINE( 580)								{
HXLINE( 580)									null();
            								}
            							}
            							else {
            								HX_STACK_DO_THROW(_hx_e);
            							}
            						}
HXLINE( 581)						completedThread();
            					}
            					HX_END_LOCAL_FUNC0((void))

HXLINE( 578)					threadsMax[0]++;
HXLINE( 579)					::states::LoadingState_obj::threadPool->run( ::Dynamic(new _hx_Closure_2(prefixVocals,player2,completedThread)));
            				}
HXLINE( 584)				bool _hx_tmp15;
HXDLIN( 584)				bool _hx_tmp16;
HXDLIN( 584)				if (!(( (bool)(stageData->__Field(HX_("hide_girlfriend",57,bd,d9,f9),::hx::paccDynamic)) ))) {
HXLINE( 584)					_hx_tmp16 = (gfVersion->__get(0) != player2);
            				}
            				else {
HXLINE( 584)					_hx_tmp16 = false;
            				}
HXDLIN( 584)				if (_hx_tmp16) {
HXLINE( 584)					_hx_tmp15 = (gfVersion->__get(0) != player1);
            				}
            				else {
HXLINE( 584)					_hx_tmp15 = false;
            				}
HXDLIN( 584)				if (_hx_tmp15) {
            					HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_3, ::Dynamic,completedThread,::Array< ::String >,gfVersion) HXARGC(0)
            					void _hx_run(){
            						HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_587_prepareToSong)
HXLINE( 588)						try {
            							HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 588)							::String prefixVocals = null();
HXDLIN( 588)							try {
            								HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 588)								::String path = ::backend::Paths_obj::getPath(((HX_("characters/",45,3c,bf,be) + gfVersion->__get(0)) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),null(),null());
HXDLIN( 588)								 ::Dynamic character =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::sys::io::File_obj::getContent(path))->doParse();
HXDLIN( 588)								bool isAnimateAtlas = false;
HXDLIN( 588)								::String img = ( (::String)(character->__Field(HX_("image",5b,1f,69,bd),::hx::paccDynamic)) );
HXDLIN( 588)								img = ::StringTools_obj::trim(img);
HXDLIN( 588)								::String animToFind = ::backend::Paths_obj::getPath(((HX_("images/",77,50,74,c1) + img) + HX_("/Animation.json",61,fc,54,44)),HX_("TEXT",ad,94,ba,37),null(),null());
HXDLIN( 588)								bool _hx_tmp;
HXDLIN( 588)								if (!(::sys::FileSystem_obj::exists(animToFind))) {
HXLINE( 588)									_hx_tmp = ::lime::utils::Assets_obj::exists(animToFind,null());
            								}
            								else {
HXLINE( 588)									_hx_tmp = true;
            								}
HXDLIN( 588)								if (_hx_tmp) {
HXLINE( 588)									isAnimateAtlas = true;
            								}
HXDLIN( 588)								if (!(isAnimateAtlas)) {
HXLINE( 588)									::Array< ::String > split = img.split(HX_(",",2c,00,00,00));
HXDLIN( 588)									{
HXLINE( 588)										int _g = 0;
HXDLIN( 588)										while((_g < split->length)){
HXLINE( 588)											::String file = split->__get(_g);
HXDLIN( 588)											_g = (_g + 1);
HXDLIN( 588)											::Array< ::String > _hx_tmp1 = ::states::LoadingState_obj::imagesToPrepare;
HXDLIN( 588)											_hx_tmp1->push(::StringTools_obj::trim(file));
            										}
            									}
            								}
            								else {
HXLINE( 588)									int _g1 = 0;
HXDLIN( 588)									while((_g1 < 10)){
HXLINE( 588)										_g1 = (_g1 + 1);
HXDLIN( 588)										int i = (_g1 - 1);
HXDLIN( 588)										::String st = (HX_("",00,00,00,00) + i);
HXDLIN( 588)										if ((i == 0)) {
HXLINE( 588)											st = HX_("",00,00,00,00);
            										}
HXDLIN( 588)										if (::backend::Paths_obj::fileExists(((((HX_("images/",77,50,74,c1) + img) + HX_("/spritemap",a8,c1,c8,a3)) + st) + HX_(".png",3b,2d,bd,1e)),HX_("IMAGE",3b,57,57,3b),null(),null())) {
HXLINE( 588)											::states::LoadingState_obj::imagesToPrepare->push((((HX_("",00,00,00,00) + img) + HX_("/spritemap",a8,c1,c8,a3)) + st));
HXDLIN( 588)											goto _hx_goto_28;
            										}
            									}
            									_hx_goto_28:;
            								}
HXDLIN( 588)								bool _hx_tmp2;
HXDLIN( 588)								bool _hx_tmp3;
HXDLIN( 588)								if (::hx::IsNotNull( prefixVocals )) {
HXLINE( 588)									_hx_tmp3 = ::hx::IsNotNull( character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic) );
            								}
            								else {
HXLINE( 588)									_hx_tmp3 = false;
            								}
HXDLIN( 588)								if (_hx_tmp3) {
HXLINE( 588)									_hx_tmp2 = ::hx::IsGreater(  ::Dynamic(character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic))->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic),0 );
            								}
            								else {
HXLINE( 588)									_hx_tmp2 = false;
            								}
HXDLIN( 588)								if (_hx_tmp2) {
HXLINE( 588)									::Array< ::String > _hx_tmp4 = ::states::LoadingState_obj::songsToPrepare;
HXDLIN( 588)									_hx_tmp4->push(((prefixVocals + HX_("-",2d,00,00,00)) + ::Std_obj::string( ::Dynamic(character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic)))));
HXDLIN( 588)									if (::hx::IsEq( gfVersion->__get(0),::states::PlayState_obj::SONG->__Field(HX_("player1",b0,09,15,8a),::hx::paccDynamic) )) {
HXLINE( 588)										::states::LoadingState_obj::dontPreloadDefaultVoices = true;
            									}
            								}
            							} catch( ::Dynamic _hx_e) {
            								if (_hx_e.IsClass<  ::Dynamic >() ){
            									HX_STACK_BEGIN_CATCH
            									 ::Dynamic _g2 = _hx_e;
HXLINE( 762)									 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g2);
HXLINE( 588)									{
HXLINE( 588)										 ::Dynamic _hx_tmp5 = ::haxe::Log_obj::trace;
HXDLIN( 588)										::String _hx_tmp6 = e->details();
HXDLIN( 588)										_hx_tmp5(_hx_tmp6,::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),764,HX_("states.LoadingState",c1,f4,c4,7f),HX_("preloadCharacter",a0,b2,b8,0f)));
            									}
            								}
            								else {
            									HX_STACK_DO_THROW(_hx_e);
            								}
            							}
            						} catch( ::Dynamic _hx_e) {
            							if (_hx_e.IsClass<  ::Dynamic >() ){
            								HX_STACK_BEGIN_CATCH
            								 ::Dynamic _g3 = _hx_e;
HXLINE( 588)								{
HXLINE( 588)									null();
            								}
            							}
            							else {
            								HX_STACK_DO_THROW(_hx_e);
            							}
            						}
HXLINE( 589)						completedThread();
            					}
            					HX_END_LOCAL_FUNC0((void))

HXLINE( 586)					threadsMax[0]++;
HXLINE( 587)					::states::LoadingState_obj::threadPool->run( ::Dynamic(new _hx_Closure_3(completedThread,gfVersion)));
            				}
HXLINE( 593)				if ((threadsCompleted->__get(0) == threadsMax->__get(0))) {
HXLINE( 595)					::states::LoadingState_obj::clearInvalids();
HXLINE( 596)					::states::LoadingState_obj::startThreads();
HXLINE( 597)					::states::LoadingState_obj::initialThreadCompleted = true;
            				}
HXLINE( 599)				return true;
            			}
            			HX_END_LOCAL_FUNC0(return)

            			HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_514_prepareToSong)
HXLINE( 514)			return  ::lime::app::Future_obj::__alloc( HX_CTX , ::Dynamic(new _hx_Closure_4(threadsMax,song,threadsCompleted,completedThread,folder)),::states::LoadingState_obj::isIntrusive);
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_6) HXARGC(1)
            		void _hx_run( ::Dynamic err){
            			HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_602_prepareToSong)
HXLINE( 602)			 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 602)			::String _hx_tmp1 = (HX_("ERROR! while preparing song: ",ed,78,89,66) + ::Std_obj::string(err));
HXDLIN( 602)			_hx_tmp(_hx_tmp1,::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),602,HX_("states.LoadingState",c1,f4,c4,7f),HX_("prepareToSong",d7,f3,57,48)));
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_423_prepareToSong)
HXLINE( 424)		if (::hx::IsNull( ::states::PlayState_obj::SONG )) {
HXLINE( 426)			::states::LoadingState_obj::imagesToPrepare = ::Array_obj< ::String >::__new(0);
HXLINE( 427)			::states::LoadingState_obj::soundsToPrepare = ::Array_obj< ::String >::__new(0);
HXLINE( 428)			::states::LoadingState_obj::musicToPrepare = ::Array_obj< ::String >::__new(0);
HXLINE( 429)			::states::LoadingState_obj::songsToPrepare = ::Array_obj< ::String >::__new(0);
HXLINE( 430)			::states::LoadingState_obj::loaded = 0;
HXLINE( 431)			::states::LoadingState_obj::loadMax = 0;
HXLINE( 432)			::states::LoadingState_obj::initialThreadCompleted = true;
HXLINE( 433)			::states::LoadingState_obj::isIntrusive = false;
HXLINE( 434)			return;
            		}
HXLINE( 437)		::states::LoadingState_obj::_startPool();
HXLINE( 438)		::states::LoadingState_obj::imagesToPrepare = ::Array_obj< ::String >::__new(0);
HXLINE( 439)		::states::LoadingState_obj::soundsToPrepare = ::Array_obj< ::String >::__new(0);
HXLINE( 440)		::states::LoadingState_obj::musicToPrepare = ::Array_obj< ::String >::__new(0);
HXLINE( 441)		::states::LoadingState_obj::songsToPrepare = ::Array_obj< ::String >::__new(0);
HXLINE( 443)		::states::LoadingState_obj::initialThreadCompleted = false;
HXLINE( 444)		::Array< int > threadsCompleted = ::Array_obj< int >::fromData( _hx_array_data_7fc4f4c1_37,1);
HXLINE( 445)		::Array< int > threadsMax = ::Array_obj< int >::fromData( _hx_array_data_7fc4f4c1_38,1);
HXLINE( 446)		 ::Dynamic completedThread =  ::Dynamic(new _hx_Closure_0(threadsMax,threadsCompleted));
HXLINE( 457)		 ::Dynamic song = ::states::PlayState_obj::SONG;
HXLINE( 458)		::String path = ::backend::Song_obj::loadedSongName;
HXDLIN( 458)		 ::EReg invalidChars =  ::EReg_obj::__alloc( HX_CTX ,HX_("[~&;:<>#\\s]",07,34,b4,25),HX_("g",67,00,00,00));
HXDLIN( 458)		 ::EReg hideChars =  ::EReg_obj::__alloc( HX_CTX ,HX_("[.,'\"%?!]",ca,d9,c0,ac),HX_("g",67,00,00,00));
HXDLIN( 458)		::String folder = ::StringTools_obj::trim(hideChars->replace(invalidChars->replace(path,HX_("-",2d,00,00,00)),HX_("",00,00,00,00))).toLowerCase();
HXLINE( 459)		 ::lime::app::Future_obj::__alloc( HX_CTX , ::Dynamic(new _hx_Closure_1(folder)),::states::LoadingState_obj::isIntrusive)->then( ::Dynamic(new _hx_Closure_5(threadsMax,song,completedThread,threadsCompleted,folder)))->onError( ::Dynamic(new _hx_Closure_6()));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(LoadingState_obj,prepareToSong,(void))

void LoadingState_obj::clearInvalids(){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_607_clearInvalids)
HXLINE( 608)		::states::LoadingState_obj::clearInvalidFrom(::states::LoadingState_obj::imagesToPrepare,HX_("images",b8,50,92,fe),HX_(".png",3b,2d,bd,1e),HX_("IMAGE",3b,57,57,3b),null());
HXLINE( 609)		::states::LoadingState_obj::clearInvalidFrom(::states::LoadingState_obj::soundsToPrepare,HX_("sounds",c4,a8,2e,32),(HX_(".",2e,00,00,00) + HX_("ogg",4f,94,54,00)),HX_("SOUND",af,c4,ba,fe),null());
HXLINE( 610)		::states::LoadingState_obj::clearInvalidFrom(::states::LoadingState_obj::musicToPrepare,HX_("music",a5,d0,5a,10),(HX_(" .",0e,1c,00,00) + HX_("ogg",4f,94,54,00)),HX_("SOUND",af,c4,ba,fe),null());
HXLINE( 611)		::states::LoadingState_obj::clearInvalidFrom(::states::LoadingState_obj::songsToPrepare,HX_("songs",fe,36,c7,80),(HX_(".",2e,00,00,00) + HX_("ogg",4f,94,54,00)),HX_("SOUND",af,c4,ba,fe),HX_("songs",fe,36,c7,80));
HXLINE( 613)		{
HXLINE( 613)			{
HXLINE( 613)				::Array< ::String > arr = ::states::LoadingState_obj::imagesToPrepare;
HXLINE( 614)				while(arr->contains(null())){
HXLINE( 615)					arr->remove(null());
            				}
            			}
HXLINE( 613)			{
HXLINE( 613)				::Array< ::String > arr1 = ::states::LoadingState_obj::soundsToPrepare;
HXLINE( 614)				while(arr1->contains(null())){
HXLINE( 615)					arr1->remove(null());
            				}
            			}
HXLINE( 613)			{
HXLINE( 613)				::Array< ::String > arr2 = ::states::LoadingState_obj::musicToPrepare;
HXLINE( 614)				while(arr2->contains(null())){
HXLINE( 615)					arr2->remove(null());
            				}
            			}
HXLINE( 613)			{
HXLINE( 613)				::Array< ::String > arr3 = ::states::LoadingState_obj::songsToPrepare;
HXLINE( 614)				while(arr3->contains(null())){
HXLINE( 615)					arr3->remove(null());
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(LoadingState_obj,clearInvalids,(void))

void LoadingState_obj::clearInvalidFrom(::Array< ::String > arr,::String prefix,::String ext,::String type,::String parentFolder){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_619_clearInvalidFrom)
HXLINE( 620)		{
HXLINE( 620)			int _g = 0;
HXDLIN( 620)			::Array< ::String > _g1 = arr->copy();
HXDLIN( 620)			while((_g < _g1->length)){
HXLINE( 620)				::String folder = _g1->__get(_g);
HXDLIN( 620)				_g = (_g + 1);
HXLINE( 622)				::String nam = ::StringTools_obj::trim(folder);
HXLINE( 623)				if (::StringTools_obj::endsWith(nam,HX_("/",2f,00,00,00))) {
HXLINE( 625)					int _g2 = 0;
HXDLIN( 625)					::String fileToFind = (((HX_("",00,00,00,00) + prefix) + HX_("/",2f,00,00,00)) + nam);
HXDLIN( 625)					::Array< ::String > foldersToCheck = ::Array_obj< ::String >::__new(0);
HXDLIN( 625)					if (::sys::FileSystem_obj::exists((HX_("assets/shared/",1e,69,1e,47) + fileToFind))) {
HXLINE( 625)						foldersToCheck->push((HX_("assets/shared/",1e,69,1e,47) + fileToFind));
            					}
HXDLIN( 625)					bool _hx_tmp;
HXDLIN( 625)					if (::hx::IsNotNull( ::backend::Paths_obj::currentLevel )) {
HXLINE( 625)						_hx_tmp = (::backend::Paths_obj::currentLevel != HX_("assets/shared/",1e,69,1e,47));
            					}
            					else {
HXLINE( 625)						_hx_tmp = false;
            					}
HXDLIN( 625)					if (_hx_tmp) {
HXLINE( 625)						::String folder1 = ::backend::Paths_obj::currentLevel;
HXDLIN( 625)						if (::hx::IsNull( folder1 )) {
HXLINE( 625)							folder1 = HX_("shared",a5,5e,2b,1d);
            						}
HXDLIN( 625)						::String pth = (((HX_("assets/",4c,2a,dc,36) + folder1) + HX_("/",2f,00,00,00)) + fileToFind);
HXDLIN( 625)						bool _hx_tmp1;
HXDLIN( 625)						if (!(foldersToCheck->contains(pth))) {
HXLINE( 625)							_hx_tmp1 = ::sys::FileSystem_obj::exists(pth);
            						}
            						else {
HXLINE( 625)							_hx_tmp1 = false;
            						}
HXDLIN( 625)						if (_hx_tmp1) {
HXLINE( 625)							foldersToCheck->push(pth);
            						}
            					}
HXDLIN( 625)					{
HXLINE( 625)						{
HXLINE( 625)							int _g3 = 0;
HXDLIN( 625)							::Array< ::String > _g4 = ::backend::Mods_obj::globalMods;
HXDLIN( 625)							while((_g3 < _g4->length)){
HXLINE( 625)								::String mod = _g4->__get(_g3);
HXDLIN( 625)								_g3 = (_g3 + 1);
HXDLIN( 625)								::String key = ((mod + HX_("/",2f,00,00,00)) + fileToFind);
HXDLIN( 625)								if (::hx::IsNull( key )) {
HXLINE( 625)									key = HX_("",00,00,00,00);
            								}
HXDLIN( 625)								::String folder2 = (HX_("mods/",9e,2f,58,0c) + key);
HXDLIN( 625)								bool _hx_tmp2;
HXDLIN( 625)								if (::sys::FileSystem_obj::exists(folder2)) {
HXLINE( 625)									_hx_tmp2 = !(foldersToCheck->contains(folder2));
            								}
            								else {
HXLINE( 625)									_hx_tmp2 = false;
            								}
HXDLIN( 625)								if (_hx_tmp2) {
HXLINE( 625)									foldersToCheck->push(folder2);
            								}
            							}
            						}
HXDLIN( 625)						::String key1 = fileToFind;
HXDLIN( 625)						if (::hx::IsNull( key1 )) {
HXLINE( 625)							key1 = HX_("",00,00,00,00);
            						}
HXDLIN( 625)						::String folder3 = (HX_("mods/",9e,2f,58,0c) + key1);
HXDLIN( 625)						bool _hx_tmp3;
HXDLIN( 625)						if (::sys::FileSystem_obj::exists(folder3)) {
HXLINE( 625)							_hx_tmp3 = !(foldersToCheck->contains(folder3));
            						}
            						else {
HXLINE( 625)							_hx_tmp3 = false;
            						}
HXDLIN( 625)						if (_hx_tmp3) {
HXLINE( 625)							::String key2 = fileToFind;
HXDLIN( 625)							if (::hx::IsNull( key2 )) {
HXLINE( 625)								key2 = HX_("",00,00,00,00);
            							}
HXDLIN( 625)							foldersToCheck->push((HX_("mods/",9e,2f,58,0c) + key2));
            						}
HXDLIN( 625)						bool _hx_tmp4;
HXDLIN( 625)						if (::hx::IsNotNull( ::backend::Mods_obj::currentModDirectory )) {
HXLINE( 625)							_hx_tmp4 = (::backend::Mods_obj::currentModDirectory.length > 0);
            						}
            						else {
HXLINE( 625)							_hx_tmp4 = false;
            						}
HXDLIN( 625)						if (_hx_tmp4) {
HXLINE( 625)							::String key3 = ((::backend::Mods_obj::currentModDirectory + HX_("/",2f,00,00,00)) + fileToFind);
HXDLIN( 625)							if (::hx::IsNull( key3 )) {
HXLINE( 625)								key3 = HX_("",00,00,00,00);
            							}
HXDLIN( 625)							::String folder4 = (HX_("mods/",9e,2f,58,0c) + key3);
HXDLIN( 625)							bool _hx_tmp5;
HXDLIN( 625)							if (::sys::FileSystem_obj::exists(folder4)) {
HXLINE( 625)								_hx_tmp5 = !(foldersToCheck->contains(folder4));
            							}
            							else {
HXLINE( 625)								_hx_tmp5 = false;
            							}
HXDLIN( 625)							if (_hx_tmp5) {
HXLINE( 625)								foldersToCheck->push(folder4);
            							}
            						}
            					}
HXDLIN( 625)					::Array< ::String > _g5 = foldersToCheck;
HXDLIN( 625)					while((_g2 < _g5->length)){
HXLINE( 625)						::String subfolder = _g5->__get(_g2);
HXDLIN( 625)						_g2 = (_g2 + 1);
HXLINE( 627)						{
HXLINE( 627)							int _g6 = 0;
HXDLIN( 627)							::Array< ::String > _g7 = ::sys::FileSystem_obj::readDirectory(subfolder);
HXDLIN( 627)							while((_g6 < _g7->length)){
HXLINE( 627)								::String file = _g7->__get(_g6);
HXDLIN( 627)								_g6 = (_g6 + 1);
HXLINE( 629)								if (::StringTools_obj::endsWith(file,ext)) {
HXLINE( 631)									::String toAdd = (nam + ::haxe::io::Path_obj::withoutExtension(file));
HXLINE( 632)									if (!(arr->contains(toAdd))) {
HXLINE( 632)										arr->push(toAdd);
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 641)		int i = 0;
HXLINE( 642)		while((i < arr->length)){
HXLINE( 645)			::String member = arr->__get(i);
HXLINE( 646)			::String myKey = ((((HX_("",00,00,00,00) + prefix) + HX_("/",2f,00,00,00)) + member) + ext);
HXLINE( 647)			if ((parentFolder == HX_("songs",fe,36,c7,80))) {
HXLINE( 647)				myKey = ((HX_("",00,00,00,00) + member) + ext);
            			}
HXLINE( 650)			bool doTrace = false;
HXLINE( 651)			bool _hx_tmp6;
HXDLIN( 651)			if (!(::StringTools_obj::endsWith(member,HX_("/",2f,00,00,00)))) {
HXLINE( 651)				if (!(::backend::Paths_obj::fileExists(myKey,type,false,parentFolder))) {
HXLINE( 651)					doTrace = true;
HXDLIN( 651)					_hx_tmp6 = doTrace;
            				}
            				else {
HXLINE( 651)					_hx_tmp6 = false;
            				}
            			}
            			else {
HXLINE( 651)				_hx_tmp6 = true;
            			}
HXDLIN( 651)			if (_hx_tmp6) {
HXLINE( 653)				arr->remove(member);
HXLINE( 654)				if (doTrace) {
HXLINE( 654)					::haxe::Log_obj::trace((((HX_("Removed invalid ",e9,a5,ce,fb) + prefix) + HX_(": ",a6,32,00,00)) + member),::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),654,HX_("states.LoadingState",c1,f4,c4,7f),HX_("clearInvalidFrom",74,1b,5c,f5)));
            				}
            			}
            			else {
HXLINE( 656)				i = (i + 1);
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(LoadingState_obj,clearInvalidFrom,(void))

void LoadingState_obj::startThreads(){
            	HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_661_startThreads)
HXLINE( 662)		::states::LoadingState_obj::mutex =  ::sys::thread::Mutex_obj::__alloc( HX_CTX );
HXLINE( 663)		::states::LoadingState_obj::loadMax = (((::states::LoadingState_obj::imagesToPrepare->length + ::states::LoadingState_obj::soundsToPrepare->length) + ::states::LoadingState_obj::musicToPrepare->length) + ::states::LoadingState_obj::songsToPrepare->length);
HXLINE( 664)		::states::LoadingState_obj::loaded = 0;
HXLINE( 667)		::states::LoadingState_obj::_threadFunc();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(LoadingState_obj,startThreads,(void))

void LoadingState_obj::_threadFunc(){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_671__threadFunc)
HXLINE( 672)		::states::LoadingState_obj::_startPool();
HXLINE( 673)		{
HXLINE( 673)			int _g = 0;
HXDLIN( 673)			::Array< ::String > _g1 = ::states::LoadingState_obj::soundsToPrepare;
HXDLIN( 673)			while((_g < _g1->length)){
            				HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0,::String,sound) HXARGC(0)
            				 ::openfl::media::Sound _hx_run(){
            					HX_STACKFRAME(&_hx_pos_670a7524baf7a379_673__threadFunc)
HXLINE( 673)					return ::states::LoadingState_obj::preloadSound((HX_("sounds/",eb,02,a5,b6) + sound),null(),null(),null());
            				}
            				HX_END_LOCAL_FUNC0(return)

HXLINE( 673)				::String sound = _g1->__get(_g);
HXDLIN( 673)				_g = (_g + 1);
HXDLIN( 673)				::states::LoadingState_obj::initThread( ::Dynamic(new _hx_Closure_0(sound)),(HX_("sound ",71,a8,2e,32) + sound));
            			}
            		}
HXLINE( 674)		{
HXLINE( 674)			int _g2 = 0;
HXDLIN( 674)			::Array< ::String > _g3 = ::states::LoadingState_obj::musicToPrepare;
HXDLIN( 674)			while((_g2 < _g3->length)){
            				HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1,::String,music) HXARGC(0)
            				 ::openfl::media::Sound _hx_run(){
            					HX_STACKFRAME(&_hx_pos_670a7524baf7a379_674__threadFunc)
HXLINE( 674)					return ::states::LoadingState_obj::preloadSound((HX_("music/",ea,bf,1b,3f) + music),null(),null(),null());
            				}
            				HX_END_LOCAL_FUNC0(return)

HXLINE( 674)				::String music = _g3->__get(_g2);
HXDLIN( 674)				_g2 = (_g2 + 1);
HXDLIN( 674)				::states::LoadingState_obj::initThread( ::Dynamic(new _hx_Closure_1(music)),(HX_("music ",db,bf,1b,3f) + music));
            			}
            		}
HXLINE( 675)		{
HXLINE( 675)			int _g4 = 0;
HXDLIN( 675)			::Array< ::String > _g5 = ::states::LoadingState_obj::songsToPrepare;
HXDLIN( 675)			while((_g4 < _g5->length)){
            				HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_2,::String,song) HXARGC(0)
            				 ::openfl::media::Sound _hx_run(){
            					HX_STACKFRAME(&_hx_pos_670a7524baf7a379_675__threadFunc)
HXLINE( 675)					return ::states::LoadingState_obj::preloadSound(song,HX_("songs",fe,36,c7,80),true,false);
            				}
            				HX_END_LOCAL_FUNC0(return)

HXLINE( 675)				::String song = _g5->__get(_g4);
HXDLIN( 675)				_g4 = (_g4 + 1);
HXDLIN( 675)				::states::LoadingState_obj::initThread( ::Dynamic(new _hx_Closure_2(song)),(HX_("song ",ab,36,c7,80) + song));
            			}
            		}
HXLINE( 678)		{
HXLINE( 678)			int _g6 = 0;
HXDLIN( 678)			::Array< ::String > _g7 = ::states::LoadingState_obj::imagesToPrepare;
HXDLIN( 678)			while((_g6 < _g7->length)){
            				HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_3,::String,image) HXARGC(0)
            				 ::openfl::display::BitmapData _hx_run(){
            					HX_STACKFRAME(&_hx_pos_670a7524baf7a379_678__threadFunc)
HXLINE( 678)					return ::states::LoadingState_obj::preloadGraphic(image);
            				}
            				HX_END_LOCAL_FUNC0(return)

HXLINE( 678)				::String image = _g7->__get(_g6);
HXDLIN( 678)				_g6 = (_g6 + 1);
HXDLIN( 678)				::states::LoadingState_obj::initThread( ::Dynamic(new _hx_Closure_3(image)),(HX_("image ",65,50,92,fe) + image));
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(LoadingState_obj,_threadFunc,(void))

void LoadingState_obj::initThread( ::Dynamic func,::String traceData){
            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0,::String,traceData, ::Dynamic,func) HXARGC(0)
            		void _hx_run(){
            			HX_STACKFRAME(&_hx_pos_670a7524baf7a379_687_initThread)
HXLINE( 693)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 694)				if (::hx::IsNull( func() )) {
HXLINE( 699)					::haxe::Log_obj::trace(((HX_("ERROR! fail on preloading ",a1,1e,b2,53) + traceData) + HX_(" ",20,00,00,00)),::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),699,HX_("states.LoadingState",c1,f4,c4,7f),HX_("initThread",fa,d5,fe,92)));
            				}
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g = _hx_e;
HXLINE( 701)					{
HXLINE( 701)						null();
            					}
HXDLIN( 701)					 ::Dynamic e = _g;
HXLINE( 702)					{
HXLINE( 702)						 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 702)						::String _hx_tmp1 = ((HX_("ERROR! fail on preloading ",a1,1e,b2,53) + traceData) + HX_(": ",a6,32,00,00));
HXDLIN( 702)						::String _hx_tmp2 = (_hx_tmp1 + ::Std_obj::string(e));
HXDLIN( 702)						_hx_tmp(_hx_tmp2,::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),702,HX_("states.LoadingState",c1,f4,c4,7f),HX_("initThread",fa,d5,fe,92)));
            					}
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
HXLINE( 705)			::states::LoadingState_obj::loaded++;
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_687_initThread)
HXDLIN( 687)		::states::LoadingState_obj::threadPool->run( ::Dynamic(new _hx_Closure_0(traceData,func)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(LoadingState_obj,initThread,(void))

void LoadingState_obj::preloadCharacter(::String _hx_char,::String prefixVocals){
            	HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_712_preloadCharacter)
HXDLIN( 712)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 714)			::String path = ::backend::Paths_obj::getPath(((HX_("characters/",45,3c,bf,be) + _hx_char) + HX_(".json",56,f1,d6,c2)),HX_("TEXT",ad,94,ba,37),null(),null());
HXLINE( 716)			 ::Dynamic character =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::sys::io::File_obj::getContent(path))->doParse();
HXLINE( 721)			bool isAnimateAtlas = false;
HXLINE( 722)			::String img = ( (::String)(character->__Field(HX_("image",5b,1f,69,bd),::hx::paccDynamic)) );
HXLINE( 723)			img = ::StringTools_obj::trim(img);
HXLINE( 725)			::String animToFind = ::backend::Paths_obj::getPath(((HX_("images/",77,50,74,c1) + img) + HX_("/Animation.json",61,fc,54,44)),HX_("TEXT",ad,94,ba,37),null(),null());
HXLINE( 726)			bool _hx_tmp;
HXDLIN( 726)			if (!(::sys::FileSystem_obj::exists(animToFind))) {
HXLINE( 726)				_hx_tmp = ::lime::utils::Assets_obj::exists(animToFind,null());
            			}
            			else {
HXLINE( 726)				_hx_tmp = true;
            			}
HXDLIN( 726)			if (_hx_tmp) {
HXLINE( 727)				isAnimateAtlas = true;
            			}
HXLINE( 730)			if (!(isAnimateAtlas)) {
HXLINE( 732)				::Array< ::String > split = img.split(HX_(",",2c,00,00,00));
HXLINE( 733)				{
HXLINE( 733)					int _g = 0;
HXDLIN( 733)					while((_g < split->length)){
HXLINE( 733)						::String file = split->__get(_g);
HXDLIN( 733)						_g = (_g + 1);
HXLINE( 735)						::Array< ::String > _hx_tmp1 = ::states::LoadingState_obj::imagesToPrepare;
HXDLIN( 735)						_hx_tmp1->push(::StringTools_obj::trim(file));
            					}
            				}
            			}
            			else {
HXLINE( 741)				int _g1 = 0;
HXDLIN( 741)				while((_g1 < 10)){
HXLINE( 741)					_g1 = (_g1 + 1);
HXDLIN( 741)					int i = (_g1 - 1);
HXLINE( 743)					::String st = (HX_("",00,00,00,00) + i);
HXLINE( 744)					if ((i == 0)) {
HXLINE( 744)						st = HX_("",00,00,00,00);
            					}
HXLINE( 746)					if (::backend::Paths_obj::fileExists(((((HX_("images/",77,50,74,c1) + img) + HX_("/spritemap",a8,c1,c8,a3)) + st) + HX_(".png",3b,2d,bd,1e)),HX_("IMAGE",3b,57,57,3b),null(),null())) {
HXLINE( 749)						::states::LoadingState_obj::imagesToPrepare->push((((HX_("",00,00,00,00) + img) + HX_("/spritemap",a8,c1,c8,a3)) + st));
HXLINE( 750)						goto _hx_goto_63;
            					}
            				}
            				_hx_goto_63:;
            			}
HXLINE( 756)			bool _hx_tmp2;
HXDLIN( 756)			bool _hx_tmp3;
HXDLIN( 756)			if (::hx::IsNotNull( prefixVocals )) {
HXLINE( 756)				_hx_tmp3 = ::hx::IsNotNull( character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic) );
            			}
            			else {
HXLINE( 756)				_hx_tmp3 = false;
            			}
HXDLIN( 756)			if (_hx_tmp3) {
HXLINE( 756)				_hx_tmp2 = ::hx::IsGreater(  ::Dynamic(character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic))->__Field(HX_("length",e6,94,07,9f),::hx::paccDynamic),0 );
            			}
            			else {
HXLINE( 756)				_hx_tmp2 = false;
            			}
HXDLIN( 756)			if (_hx_tmp2) {
HXLINE( 758)				::Array< ::String > _hx_tmp4 = ::states::LoadingState_obj::songsToPrepare;
HXDLIN( 758)				_hx_tmp4->push(((prefixVocals + HX_("-",2d,00,00,00)) + ::Std_obj::string( ::Dynamic(character->__Field(HX_("vocals_file",3d,c5,2d,83),::hx::paccDynamic)))));
HXLINE( 759)				if (::hx::IsEq( _hx_char,::states::PlayState_obj::SONG->__Field(HX_("player1",b0,09,15,8a),::hx::paccDynamic) )) {
HXLINE( 759)					::states::LoadingState_obj::dontPreloadDefaultVoices = true;
            				}
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g2 = _hx_e;
HXLINE( 762)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g2);
HXLINE( 764)				{
HXLINE( 764)					 ::Dynamic _hx_tmp5 = ::haxe::Log_obj::trace;
HXDLIN( 764)					::String _hx_tmp6 = e->details();
HXDLIN( 764)					_hx_tmp5(_hx_tmp6,::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),764,HX_("states.LoadingState",c1,f4,c4,7f),HX_("preloadCharacter",a0,b2,b8,0f)));
            				}
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(LoadingState_obj,preloadCharacter,(void))

 ::openfl::media::Sound LoadingState_obj::preloadSound(::String key,::String path, ::Dynamic __o_modsAllowed, ::Dynamic __o_beepOnNull){
            		 ::Dynamic modsAllowed = __o_modsAllowed;
            		if (::hx::IsNull(__o_modsAllowed)) modsAllowed = true;
            		 ::Dynamic beepOnNull = __o_beepOnNull;
            		if (::hx::IsNull(__o_beepOnNull)) beepOnNull = true;
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_770_preloadSound)
HXLINE( 771)		::String key1 = key;
HXDLIN( 771)		::Dynamic this1 = ::backend::Language_obj::phrases;
HXDLIN( 771)		::String str = ( ( ::haxe::ds::StringMap)(this1) )->get_string(::StringTools_obj::trim(key1).toLowerCase());
HXDLIN( 771)		if (::hx::IsNotNull( str )) {
HXLINE( 771)			key1 = str;
            		}
HXDLIN( 771)		::String file = ::backend::Paths_obj::getPath((key1 + (HX_(".",2e,00,00,00) + HX_("ogg",4f,94,54,00))),HX_("SOUND",af,c4,ba,fe),path,modsAllowed);
HXLINE( 774)		if (!(::backend::Paths_obj::currentTrackedSounds->exists(file))) {
HXLINE( 776)			bool _hx_tmp;
HXDLIN( 776)			if (!(::sys::FileSystem_obj::exists(file))) {
HXLINE( 776)				_hx_tmp = ::openfl::utils::Assets_obj::exists(file,HX_("SOUND",af,c4,ba,fe));
            			}
            			else {
HXLINE( 776)				_hx_tmp = true;
            			}
HXDLIN( 776)			if (_hx_tmp) {
HXLINE( 778)				 ::openfl::media::Sound sound = ::openfl::media::Sound_obj::fromFile(file);
HXLINE( 779)				::states::LoadingState_obj::mutex->acquire();
HXLINE( 780)				::backend::Paths_obj::currentTrackedSounds->set(file,sound);
HXLINE( 781)				::states::LoadingState_obj::mutex->release();
            			}
            			else {
HXLINE( 783)				if (( (bool)(beepOnNull) )) {
HXLINE( 785)					::haxe::Log_obj::trace((((HX_("SOUND NOT FOUND: ",2a,60,7a,86) + key) + HX_(", PATH: ",ff,c8,af,a8)) + path),::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),785,HX_("states.LoadingState",c1,f4,c4,7f),HX_("preloadSound",46,dc,30,a0)));
HXLINE( 786)					::flixel::FlxG_obj::log->advanced((((HX_("SOUND NOT FOUND: ",2a,60,7a,86) + key) + HX_(", PATH: ",ff,c8,af,a8)) + path),::flixel::_hx_system::debug::log::LogStyle_obj::ERROR,true);
HXLINE( 787)					return ::flixel::_hx_system::FlxAssets_obj::getSound(HX_("flixel/sounds/beep",e6,b5,a9,33));
            				}
            			}
            		}
HXLINE( 790)		::states::LoadingState_obj::mutex->acquire();
HXLINE( 791)		::backend::Paths_obj::localTrackedAssets->push(file);
HXLINE( 792)		::states::LoadingState_obj::mutex->release();
HXLINE( 794)		return ( ( ::openfl::media::Sound)(::backend::Paths_obj::currentTrackedSounds->get(file)) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(LoadingState_obj,preloadSound,return )

 ::openfl::display::BitmapData LoadingState_obj::preloadGraphic(::String key){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_799_preloadGraphic)
HXLINE( 800)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 801)			::String requestKey = (HX_("images/",77,50,74,c1) + key);
HXLINE( 802)			::String key1 = requestKey;
HXDLIN( 802)			::Dynamic this1 = ::backend::Language_obj::phrases;
HXDLIN( 802)			::String str = ( ( ::haxe::ds::StringMap)(this1) )->get_string(::StringTools_obj::trim(key1).toLowerCase());
HXDLIN( 802)			if (::hx::IsNotNull( str )) {
HXLINE( 802)				key1 = str;
            			}
HXDLIN( 802)			requestKey = key1;
HXLINE( 803)			if ((requestKey.lastIndexOf(HX_(".",2e,00,00,00),null()) < 0)) {
HXLINE( 803)				requestKey = (requestKey + HX_(".png",3b,2d,bd,1e));
            			}
HXLINE( 805)			if (!(::backend::Paths_obj::currentTrackedAssets->exists(requestKey))) {
HXLINE( 807)				::String file = ::backend::Paths_obj::getPath(requestKey,HX_("IMAGE",3b,57,57,3b),null(),null());
HXLINE( 808)				bool _hx_tmp;
HXDLIN( 808)				if (!(::sys::FileSystem_obj::exists(file))) {
HXLINE( 808)					_hx_tmp = ::openfl::utils::Assets_obj::exists(file,HX_("IMAGE",3b,57,57,3b));
            				}
            				else {
HXLINE( 808)					_hx_tmp = true;
            				}
HXDLIN( 808)				if (_hx_tmp) {
HXLINE( 811)					 ::openfl::display::BitmapData bitmap = ::openfl::display::BitmapData_obj::fromFile(file);
HXLINE( 816)					::states::LoadingState_obj::mutex->acquire();
HXLINE( 817)					::states::LoadingState_obj::requestedBitmaps->set(file,bitmap);
HXLINE( 818)					::states::LoadingState_obj::originalBitmapKeys->set(file,requestKey);
HXLINE( 819)					::states::LoadingState_obj::mutex->release();
HXLINE( 820)					return bitmap;
            				}
            				else {
HXLINE( 822)					::haxe::Log_obj::trace(((HX_("no such image ",3f,09,ec,e3) + key) + HX_(" exists",fc,f5,8e,f2)),::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),822,HX_("states.LoadingState",c1,f4,c4,7f),HX_("preloadGraphic",df,b5,b7,70)));
            				}
            			}
HXLINE( 825)			return ( ( ::flixel::graphics::FlxGraphic)(::backend::Paths_obj::currentTrackedAssets->get(requestKey)) )->bitmap;
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE( 829)				::haxe::Log_obj::trace((HX_("ERROR! fail on preloading image ",c6,9d,ae,ce) + key),::hx::SourceInfo(HX_("source/states/LoadingState.hx",b0,0b,1c,f1),829,HX_("states.LoadingState",c1,f4,c4,7f),HX_("preloadGraphic",df,b5,b7,70)));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE( 832)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(LoadingState_obj,preloadGraphic,return )

int LoadingState_obj::getCPUThreadsCount(){
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_842_getCPUThreadsCount)
            	
		return std::thread::hardware_concurrency();
    	

HXDLIN( 842)		return -1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(LoadingState_obj,getCPUThreadsCount,return )


::hx::ObjectPtr< LoadingState_obj > LoadingState_obj::__new( ::flixel::FlxState target,bool stopMusic) {
	::hx::ObjectPtr< LoadingState_obj > __this = new LoadingState_obj();
	__this->__construct(target,stopMusic);
	return __this;
}

::hx::ObjectPtr< LoadingState_obj > LoadingState_obj::__alloc(::hx::Ctx *_hx_ctx, ::flixel::FlxState target,bool stopMusic) {
	LoadingState_obj *__this = (LoadingState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(LoadingState_obj), true, "states.LoadingState"));
	*(void **)__this = LoadingState_obj::_hx_vtable;
	__this->__construct(target,stopMusic);
	return __this;
}

LoadingState_obj::LoadingState_obj()
{
}

void LoadingState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(LoadingState);
	HX_MARK_MEMBER_NAME(target,"target");
	HX_MARK_MEMBER_NAME(stopMusic,"stopMusic");
	HX_MARK_MEMBER_NAME(dontUpdate,"dontUpdate");
	HX_MARK_MEMBER_NAME(barGroup,"barGroup");
	HX_MARK_MEMBER_NAME(bar,"bar");
	HX_MARK_MEMBER_NAME(barWidth,"barWidth");
	HX_MARK_MEMBER_NAME(intendedPercent,"intendedPercent");
	HX_MARK_MEMBER_NAME(curPercent,"curPercent");
	HX_MARK_MEMBER_NAME(stateChangeDelay,"stateChangeDelay");
	HX_MARK_MEMBER_NAME(logo,"logo");
	HX_MARK_MEMBER_NAME(pessy,"pessy");
	HX_MARK_MEMBER_NAME(loadingText,"loadingText");
	HX_MARK_MEMBER_NAME(timePassed,"timePassed");
	HX_MARK_MEMBER_NAME(shakeFl,"shakeFl");
	HX_MARK_MEMBER_NAME(shakeMult,"shakeMult");
	HX_MARK_MEMBER_NAME(isSpinning,"isSpinning");
	HX_MARK_MEMBER_NAME(spawnedPessy,"spawnedPessy");
	HX_MARK_MEMBER_NAME(pressedTimes,"pressedTimes");
	HX_MARK_MEMBER_NAME(hscript,"hscript");
	HX_MARK_MEMBER_NAME(transitioning,"transitioning");
	HX_MARK_MEMBER_NAME(finishedLoading,"finishedLoading");
	 ::backend::MusicBeatState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void LoadingState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(target,"target");
	HX_VISIT_MEMBER_NAME(stopMusic,"stopMusic");
	HX_VISIT_MEMBER_NAME(dontUpdate,"dontUpdate");
	HX_VISIT_MEMBER_NAME(barGroup,"barGroup");
	HX_VISIT_MEMBER_NAME(bar,"bar");
	HX_VISIT_MEMBER_NAME(barWidth,"barWidth");
	HX_VISIT_MEMBER_NAME(intendedPercent,"intendedPercent");
	HX_VISIT_MEMBER_NAME(curPercent,"curPercent");
	HX_VISIT_MEMBER_NAME(stateChangeDelay,"stateChangeDelay");
	HX_VISIT_MEMBER_NAME(logo,"logo");
	HX_VISIT_MEMBER_NAME(pessy,"pessy");
	HX_VISIT_MEMBER_NAME(loadingText,"loadingText");
	HX_VISIT_MEMBER_NAME(timePassed,"timePassed");
	HX_VISIT_MEMBER_NAME(shakeFl,"shakeFl");
	HX_VISIT_MEMBER_NAME(shakeMult,"shakeMult");
	HX_VISIT_MEMBER_NAME(isSpinning,"isSpinning");
	HX_VISIT_MEMBER_NAME(spawnedPessy,"spawnedPessy");
	HX_VISIT_MEMBER_NAME(pressedTimes,"pressedTimes");
	HX_VISIT_MEMBER_NAME(hscript,"hscript");
	HX_VISIT_MEMBER_NAME(transitioning,"transitioning");
	HX_VISIT_MEMBER_NAME(finishedLoading,"finishedLoading");
	 ::backend::MusicBeatState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val LoadingState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"bar") ) { return ::hx::Val( bar ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"logo") ) { return ::hx::Val( logo ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"pessy") ) { return ::hx::Val( pessy ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"target") ) { return ::hx::Val( target ); }
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		if (HX_FIELD_EQ(inName,"onLoad") ) { return ::hx::Val( onLoad_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"shakeFl") ) { return ::hx::Val( shakeFl ); }
		if (HX_FIELD_EQ(inName,"hscript") ) { return ::hx::Val( hscript ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"barGroup") ) { return ::hx::Val( barGroup ); }
		if (HX_FIELD_EQ(inName,"barWidth") ) { return ::hx::Val( barWidth ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"stopMusic") ) { return ::hx::Val( stopMusic ); }
		if (HX_FIELD_EQ(inName,"shakeMult") ) { return ::hx::Val( shakeMult ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"dontUpdate") ) { return ::hx::Val( dontUpdate ); }
		if (HX_FIELD_EQ(inName,"curPercent") ) { return ::hx::Val( curPercent ); }
		if (HX_FIELD_EQ(inName,"timePassed") ) { return ::hx::Val( timePassed ); }
		if (HX_FIELD_EQ(inName,"isSpinning") ) { return ::hx::Val( isSpinning ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"loadingText") ) { return ::hx::Val( loadingText ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"spawnedPessy") ) { return ::hx::Val( spawnedPessy ); }
		if (HX_FIELD_EQ(inName,"pressedTimes") ) { return ::hx::Val( pressedTimes ); }
		if (HX_FIELD_EQ(inName,"addBehindBar") ) { return ::hx::Val( addBehindBar_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"transitioning") ) { return ::hx::Val( transitioning ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"intendedPercent") ) { return ::hx::Val( intendedPercent ); }
		if (HX_FIELD_EQ(inName,"finishedLoading") ) { return ::hx::Val( finishedLoading ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"stateChangeDelay") ) { return ::hx::Val( stateChangeDelay ); }
	}
	return super::__Field(inName,inCallProp);
}

bool LoadingState_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"mutex") ) { outValue = ( mutex ); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"loaded") ) { outValue = ( loaded ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"loadMax") ) { outValue = ( loadMax ); return true; }
		if (HX_FIELD_EQ(inName,"_loaded") ) { outValue = _loaded_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"prepare") ) { outValue = prepare_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"threadPool") ) { outValue = ( threadPool ); return true; }
		if (HX_FIELD_EQ(inName,"_startPool") ) { outValue = _startPool_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"initThread") ) { outValue = initThread_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"checkLoaded") ) { outValue = checkLoaded_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isIntrusive") ) { outValue = ( isIntrusive ); return true; }
		if (HX_FIELD_EQ(inName,"_threadFunc") ) { outValue = _threadFunc_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"getNextState") ) { outValue = getNextState_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"startThreads") ) { outValue = startThreads_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"preloadSound") ) { outValue = preloadSound_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"prepareToSong") ) { outValue = prepareToSong_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"clearInvalids") ) { outValue = clearInvalids_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"musicToPrepare") ) { outValue = ( musicToPrepare ); return true; }
		if (HX_FIELD_EQ(inName,"songsToPrepare") ) { outValue = ( songsToPrepare ); return true; }
		if (HX_FIELD_EQ(inName,"preloadGraphic") ) { outValue = preloadGraphic_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"imagesToPrepare") ) { outValue = ( imagesToPrepare ); return true; }
		if (HX_FIELD_EQ(inName,"soundsToPrepare") ) { outValue = ( soundsToPrepare ); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"requestedBitmaps") ) { outValue = ( requestedBitmaps ); return true; }
		if (HX_FIELD_EQ(inName,"clearInvalidFrom") ) { outValue = clearInvalidFrom_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"preloadCharacter") ) { outValue = preloadCharacter_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"loadNextDirectory") ) { outValue = loadNextDirectory_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"originalBitmapKeys") ) { outValue = ( originalBitmapKeys ); return true; }
		if (HX_FIELD_EQ(inName,"loadAndSwitchState") ) { outValue = loadAndSwitchState_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getCPUThreadsCount") ) { outValue = getCPUThreadsCount_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"initialThreadCompleted") ) { outValue = ( initialThreadCompleted ); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"dontPreloadDefaultVoices") ) { outValue = ( dontPreloadDefaultVoices ); return true; }
	}
	return false;
}

::hx::Val LoadingState_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"bar") ) { bar=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"logo") ) { logo=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"pessy") ) { pessy=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"target") ) { target=inValue.Cast<  ::flixel::FlxState >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"shakeFl") ) { shakeFl=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"hscript") ) { hscript=inValue.Cast<  ::psychlua::HScript >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"barGroup") ) { barGroup=inValue.Cast<  ::flixel::group::FlxTypedSpriteGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"barWidth") ) { barWidth=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"stopMusic") ) { stopMusic=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shakeMult") ) { shakeMult=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"dontUpdate") ) { dontUpdate=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"curPercent") ) { curPercent=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"timePassed") ) { timePassed=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"isSpinning") ) { isSpinning=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"loadingText") ) { loadingText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"spawnedPessy") ) { spawnedPessy=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pressedTimes") ) { pressedTimes=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"transitioning") ) { transitioning=inValue.Cast< bool >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"intendedPercent") ) { intendedPercent=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"finishedLoading") ) { finishedLoading=inValue.Cast< bool >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"stateChangeDelay") ) { stateChangeDelay=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool LoadingState_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"mutex") ) { mutex=ioValue.Cast<  ::sys::thread::Mutex >(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"loaded") ) { loaded=ioValue.Cast< int >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"loadMax") ) { loadMax=ioValue.Cast< int >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"threadPool") ) { threadPool=ioValue.Cast<  ::sys::thread::FixedThreadPool >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"isIntrusive") ) { isIntrusive=ioValue.Cast< bool >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"musicToPrepare") ) { musicToPrepare=ioValue.Cast< ::Array< ::String > >(); return true; }
		if (HX_FIELD_EQ(inName,"songsToPrepare") ) { songsToPrepare=ioValue.Cast< ::Array< ::String > >(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"imagesToPrepare") ) { imagesToPrepare=ioValue.Cast< ::Array< ::String > >(); return true; }
		if (HX_FIELD_EQ(inName,"soundsToPrepare") ) { soundsToPrepare=ioValue.Cast< ::Array< ::String > >(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"requestedBitmaps") ) { requestedBitmaps=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"originalBitmapKeys") ) { originalBitmapKeys=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"initialThreadCompleted") ) { initialThreadCompleted=ioValue.Cast< bool >(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"dontPreloadDefaultVoices") ) { dontPreloadDefaultVoices=ioValue.Cast< bool >(); return true; }
	}
	return false;
}

void LoadingState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("target",51,f3,ec,86));
	outFields->push(HX_("stopMusic",43,09,9d,20));
	outFields->push(HX_("dontUpdate",7a,2d,c4,ba));
	outFields->push(HX_("barGroup",6c,f4,c2,68));
	outFields->push(HX_("bar",d3,b1,4a,00));
	outFields->push(HX_("barWidth",33,f7,30,99));
	outFields->push(HX_("intendedPercent",5a,34,35,a1));
	outFields->push(HX_("curPercent",25,fd,c3,83));
	outFields->push(HX_("stateChangeDelay",62,a9,31,2d));
	outFields->push(HX_("logo",6b,9f,b7,47));
	outFields->push(HX_("pessy",04,2d,fb,bf));
	outFields->push(HX_("loadingText",49,b5,f4,92));
	outFields->push(HX_("timePassed",5d,1b,fb,8b));
	outFields->push(HX_("shakeFl",ac,d9,26,64));
	outFields->push(HX_("shakeMult",d6,4d,79,e3));
	outFields->push(HX_("isSpinning",00,82,4e,f8));
	outFields->push(HX_("spawnedPessy",4a,fb,39,1f));
	outFields->push(HX_("pressedTimes",c4,91,53,7f));
	outFields->push(HX_("hscript",73,8c,18,2c));
	outFields->push(HX_("transitioning",6d,6a,93,94));
	outFields->push(HX_("finishedLoading",2a,95,f4,8e));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo LoadingState_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::FlxState */ ,(int)offsetof(LoadingState_obj,target),HX_("target",51,f3,ec,86)},
	{::hx::fsBool,(int)offsetof(LoadingState_obj,stopMusic),HX_("stopMusic",43,09,9d,20)},
	{::hx::fsBool,(int)offsetof(LoadingState_obj,dontUpdate),HX_("dontUpdate",7a,2d,c4,ba)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedSpriteGroup */ ,(int)offsetof(LoadingState_obj,barGroup),HX_("barGroup",6c,f4,c2,68)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(LoadingState_obj,bar),HX_("bar",d3,b1,4a,00)},
	{::hx::fsInt,(int)offsetof(LoadingState_obj,barWidth),HX_("barWidth",33,f7,30,99)},
	{::hx::fsFloat,(int)offsetof(LoadingState_obj,intendedPercent),HX_("intendedPercent",5a,34,35,a1)},
	{::hx::fsFloat,(int)offsetof(LoadingState_obj,curPercent),HX_("curPercent",25,fd,c3,83)},
	{::hx::fsFloat,(int)offsetof(LoadingState_obj,stateChangeDelay),HX_("stateChangeDelay",62,a9,31,2d)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(LoadingState_obj,logo),HX_("logo",6b,9f,b7,47)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(LoadingState_obj,pessy),HX_("pessy",04,2d,fb,bf)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(LoadingState_obj,loadingText),HX_("loadingText",49,b5,f4,92)},
	{::hx::fsFloat,(int)offsetof(LoadingState_obj,timePassed),HX_("timePassed",5d,1b,fb,8b)},
	{::hx::fsFloat,(int)offsetof(LoadingState_obj,shakeFl),HX_("shakeFl",ac,d9,26,64)},
	{::hx::fsFloat,(int)offsetof(LoadingState_obj,shakeMult),HX_("shakeMult",d6,4d,79,e3)},
	{::hx::fsBool,(int)offsetof(LoadingState_obj,isSpinning),HX_("isSpinning",00,82,4e,f8)},
	{::hx::fsBool,(int)offsetof(LoadingState_obj,spawnedPessy),HX_("spawnedPessy",4a,fb,39,1f)},
	{::hx::fsInt,(int)offsetof(LoadingState_obj,pressedTimes),HX_("pressedTimes",c4,91,53,7f)},
	{::hx::fsObject /*  ::psychlua::HScript */ ,(int)offsetof(LoadingState_obj,hscript),HX_("hscript",73,8c,18,2c)},
	{::hx::fsBool,(int)offsetof(LoadingState_obj,transitioning),HX_("transitioning",6d,6a,93,94)},
	{::hx::fsBool,(int)offsetof(LoadingState_obj,finishedLoading),HX_("finishedLoading",2a,95,f4,8e)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo LoadingState_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &LoadingState_obj::loaded,HX_("loaded",05,48,6f,58)},
	{::hx::fsInt,(void *) &LoadingState_obj::loadMax,HX_("loadMax",1e,84,dd,08)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &LoadingState_obj::originalBitmapKeys,HX_("originalBitmapKeys",34,69,26,36)},
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &LoadingState_obj::requestedBitmaps,HX_("requestedBitmaps",d6,49,28,98)},
	{::hx::fsObject /*  ::sys::thread::Mutex */ ,(void *) &LoadingState_obj::mutex,HX_("mutex",7f,8f,5b,10)},
	{::hx::fsObject /*  ::sys::thread::FixedThreadPool */ ,(void *) &LoadingState_obj::threadPool,HX_("threadPool",c6,54,25,46)},
	{::hx::fsBool,(void *) &LoadingState_obj::isIntrusive,HX_("isIntrusive",6d,3f,d0,0d)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &LoadingState_obj::imagesToPrepare,HX_("imagesToPrepare",74,81,6e,23)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &LoadingState_obj::soundsToPrepare,HX_("soundsToPrepare",e8,c7,04,39)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &LoadingState_obj::musicToPrepare,HX_("musicToPrepare",e7,1b,0f,8f)},
	{::hx::fsObject /* ::Array< ::String > */ ,(void *) &LoadingState_obj::songsToPrepare,HX_("songsToPrepare",6e,a2,c9,36)},
	{::hx::fsBool,(void *) &LoadingState_obj::initialThreadCompleted,HX_("initialThreadCompleted",3d,89,49,b2)},
	{::hx::fsBool,(void *) &LoadingState_obj::dontPreloadDefaultVoices,HX_("dontPreloadDefaultVoices",ca,33,4c,f5)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String LoadingState_obj_sMemberFields[] = {
	HX_("target",51,f3,ec,86),
	HX_("stopMusic",43,09,9d,20),
	HX_("dontUpdate",7a,2d,c4,ba),
	HX_("barGroup",6c,f4,c2,68),
	HX_("bar",d3,b1,4a,00),
	HX_("barWidth",33,f7,30,99),
	HX_("intendedPercent",5a,34,35,a1),
	HX_("curPercent",25,fd,c3,83),
	HX_("stateChangeDelay",62,a9,31,2d),
	HX_("logo",6b,9f,b7,47),
	HX_("pessy",04,2d,fb,bf),
	HX_("loadingText",49,b5,f4,92),
	HX_("timePassed",5d,1b,fb,8b),
	HX_("shakeFl",ac,d9,26,64),
	HX_("shakeMult",d6,4d,79,e3),
	HX_("isSpinning",00,82,4e,f8),
	HX_("spawnedPessy",4a,fb,39,1f),
	HX_("pressedTimes",c4,91,53,7f),
	HX_("hscript",73,8c,18,2c),
	HX_("create",fc,66,0f,7c),
	HX_("addBehindBar",d8,0a,36,c9),
	HX_("transitioning",6d,6a,93,94),
	HX_("update",09,86,05,87),
	HX_("destroy",fa,2c,86,24),
	HX_("finishedLoading",2a,95,f4,8e),
	HX_("onLoad",e5,a2,41,ea),
	::String(null()) };

static void LoadingState_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(LoadingState_obj::loaded,"loaded");
	HX_MARK_MEMBER_NAME(LoadingState_obj::loadMax,"loadMax");
	HX_MARK_MEMBER_NAME(LoadingState_obj::originalBitmapKeys,"originalBitmapKeys");
	HX_MARK_MEMBER_NAME(LoadingState_obj::requestedBitmaps,"requestedBitmaps");
	HX_MARK_MEMBER_NAME(LoadingState_obj::mutex,"mutex");
	HX_MARK_MEMBER_NAME(LoadingState_obj::threadPool,"threadPool");
	HX_MARK_MEMBER_NAME(LoadingState_obj::isIntrusive,"isIntrusive");
	HX_MARK_MEMBER_NAME(LoadingState_obj::imagesToPrepare,"imagesToPrepare");
	HX_MARK_MEMBER_NAME(LoadingState_obj::soundsToPrepare,"soundsToPrepare");
	HX_MARK_MEMBER_NAME(LoadingState_obj::musicToPrepare,"musicToPrepare");
	HX_MARK_MEMBER_NAME(LoadingState_obj::songsToPrepare,"songsToPrepare");
	HX_MARK_MEMBER_NAME(LoadingState_obj::initialThreadCompleted,"initialThreadCompleted");
	HX_MARK_MEMBER_NAME(LoadingState_obj::dontPreloadDefaultVoices,"dontPreloadDefaultVoices");
};

#ifdef HXCPP_VISIT_ALLOCS
static void LoadingState_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(LoadingState_obj::loaded,"loaded");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::loadMax,"loadMax");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::originalBitmapKeys,"originalBitmapKeys");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::requestedBitmaps,"requestedBitmaps");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::mutex,"mutex");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::threadPool,"threadPool");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::isIntrusive,"isIntrusive");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::imagesToPrepare,"imagesToPrepare");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::soundsToPrepare,"soundsToPrepare");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::musicToPrepare,"musicToPrepare");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::songsToPrepare,"songsToPrepare");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::initialThreadCompleted,"initialThreadCompleted");
	HX_VISIT_MEMBER_NAME(LoadingState_obj::dontPreloadDefaultVoices,"dontPreloadDefaultVoices");
};

#endif

::hx::Class LoadingState_obj::__mClass;

static ::String LoadingState_obj_sStaticFields[] = {
	HX_("loaded",05,48,6f,58),
	HX_("loadMax",1e,84,dd,08),
	HX_("originalBitmapKeys",34,69,26,36),
	HX_("requestedBitmaps",d6,49,28,98),
	HX_("mutex",7f,8f,5b,10),
	HX_("threadPool",c6,54,25,46),
	HX_("loadAndSwitchState",ac,5a,a7,a6),
	HX_("_loaded",a4,59,e6,c6),
	HX_("checkLoaded",ed,1a,81,3a),
	HX_("loadNextDirectory",f4,6c,0f,89),
	HX_("isIntrusive",6d,3f,d0,0d),
	HX_("getNextState",a8,2c,a7,3a),
	HX_("imagesToPrepare",74,81,6e,23),
	HX_("soundsToPrepare",e8,c7,04,39),
	HX_("musicToPrepare",e7,1b,0f,8f),
	HX_("songsToPrepare",6e,a2,c9,36),
	HX_("prepare",87,91,dd,37),
	HX_("initialThreadCompleted",3d,89,49,b2),
	HX_("dontPreloadDefaultVoices",ca,33,4c,f5),
	HX_("_startPool",1f,76,f2,5e),
	HX_("prepareToSong",d7,f3,57,48),
	HX_("clearInvalids",49,c0,f4,d6),
	HX_("clearInvalidFrom",74,1b,5c,f5),
	HX_("startThreads",27,da,3d,c5),
	HX_("_threadFunc",4d,8c,17,12),
	HX_("initThread",fa,d5,fe,92),
	HX_("preloadCharacter",a0,b2,b8,0f),
	HX_("preloadSound",46,dc,30,a0),
	HX_("preloadGraphic",df,b5,b7,70),
	HX_("getCPUThreadsCount",f8,4e,d6,d9),
	::String(null())
};

void LoadingState_obj::__register()
{
	LoadingState_obj _hx_dummy;
	LoadingState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("states.LoadingState",c1,f4,c4,7f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &LoadingState_obj::__GetStatic;
	__mClass->mSetStaticField = &LoadingState_obj::__SetStatic;
	__mClass->mMarkFunc = LoadingState_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(LoadingState_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(LoadingState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< LoadingState_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = LoadingState_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = LoadingState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = LoadingState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void LoadingState_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_41_boot)
HXDLIN(  41)		loaded = 0;
            	}
{
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_42_boot)
HXDLIN(  42)		loadMax = 0;
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_44_boot)
HXDLIN(  44)		originalBitmapKeys =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_670a7524baf7a379_45_boot)
HXDLIN(  45)		requestedBitmaps =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
{
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_47_boot)
HXDLIN(  47)		threadPool = null();
            	}
{
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_369_boot)
HXDLIN( 369)		isIntrusive = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_398_boot)
HXDLIN( 398)		imagesToPrepare = ::Array_obj< ::String >::__new(0);
            	}
{
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_399_boot)
HXDLIN( 399)		soundsToPrepare = ::Array_obj< ::String >::__new(0);
            	}
{
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_400_boot)
HXDLIN( 400)		musicToPrepare = ::Array_obj< ::String >::__new(0);
            	}
{
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_401_boot)
HXDLIN( 401)		songsToPrepare = ::Array_obj< ::String >::__new(0);
            	}
{
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_409_boot)
HXDLIN( 409)		initialThreadCompleted = true;
            	}
{
            	HX_STACKFRAME(&_hx_pos_670a7524baf7a379_410_boot)
HXDLIN( 410)		dontPreloadDefaultVoices = false;
            	}
}

} // end namespace states
