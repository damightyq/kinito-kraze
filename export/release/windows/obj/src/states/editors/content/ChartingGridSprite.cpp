// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_backend_MusicBeatState
#include <backend/MusicBeatState.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIEvent
#include <backend/ui/PsychUIEvent.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxGridOverlay
#include <flixel/addons/display/FlxGridOverlay.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_states_editors_ChartingState
#include <states/editors/ChartingState.h>
#endif
#ifndef INCLUDED_states_editors_content_ChartingGridSprite
#include <states/editors/content/ChartingGridSprite.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_66fb301aeed14640_6_new,"states.editors.content.ChartingGridSprite","new",0xe89cc76a,"states.editors.content.ChartingGridSprite.new","states/editors/content/ChartingGridSprite.hx",6,0x8cf25763)
HX_LOCAL_STACK_FRAME(_hx_pos_66fb301aeed14640_43_loadGrid,"states.editors.content.ChartingGridSprite","loadGrid",0xed74ecc2,"states.editors.content.ChartingGridSprite.loadGrid","states/editors/content/ChartingGridSprite.hx",43,0x8cf25763)
static const int _hx_array_data_2ebe8a78_2[] = {
	(int)0,
};
static const int _hx_array_data_2ebe8a78_3[] = {
	(int)1,
};
HX_LOCAL_STACK_FRAME(_hx_pos_66fb301aeed14640_53_draw,"states.editors.content.ChartingGridSprite","draw",0x99ff5dba,"states.editors.content.ChartingGridSprite.draw","states/editors/content/ChartingGridSprite.hx",53,0x8cf25763)
HX_LOCAL_STACK_FRAME(_hx_pos_66fb301aeed14640_98__drawStripes,"states.editors.content.ChartingGridSprite","_drawStripes",0xd38fdb59,"states.editors.content.ChartingGridSprite._drawStripes","states/editors/content/ChartingGridSprite.hx",98,0x8cf25763)
HX_LOCAL_STACK_FRAME(_hx_pos_66fb301aeed14640_109_updateStripes,"states.editors.content.ChartingGridSprite","updateStripes",0x78d75dc7,"states.editors.content.ChartingGridSprite.updateStripes","states/editors/content/ChartingGridSprite.hx",109,0x8cf25763)
HX_LOCAL_STACK_FRAME(_hx_pos_66fb301aeed14640_117_set_rows,"states.editors.content.ChartingGridSprite","set_rows",0xb2304ecc,"states.editors.content.ChartingGridSprite.set_rows","states/editors/content/ChartingGridSprite.hx",117,0x8cf25763)
HX_LOCAL_STACK_FRAME(_hx_pos_66fb301aeed14640_124_set_spacing,"states.editors.content.ChartingGridSprite","set_spacing",0xbc28abb0,"states.editors.content.ChartingGridSprite.set_spacing","states/editors/content/ChartingGridSprite.hx",124,0x8cf25763)
HX_LOCAL_STACK_FRAME(_hx_pos_66fb301aeed14640_131_recalcHeight,"states.editors.content.ChartingGridSprite","recalcHeight",0x0182ab85,"states.editors.content.ChartingGridSprite.recalcHeight","states/editors/content/ChartingGridSprite.hx",131,0x8cf25763)
namespace states{
namespace editors{
namespace content{

void ChartingGridSprite_obj::__construct(int columns, ::Dynamic __o_color1, ::Dynamic __o_color2){
            		 ::Dynamic color1 = __o_color1;
            		if (::hx::IsNull(__o_color1)) color1 = -1644826;
            		 ::Dynamic color2 = __o_color2;
            		if (::hx::IsNull(__o_color2)) color2 = -2565928;
            	HX_GC_STACKFRAME(&_hx_pos_66fb301aeed14640_6_new)
HXLINE(  16)		this->vortexLineSpace = ((Float)0);
HXLINE(  15)		this->vortexLineEnabled = false;
HXLINE(  10)		this->spacing = 0;
HXLINE(   9)		this->columns = 0;
HXLINE(   8)		this->rows = ((Float)16);
HXLINE(  20)		super::__construct(null(),null(),null());
HXLINE(  21)		this->columns = columns;
HXLINE(  22)		this->scrollFactor->set_x(( (Float)(0) ));
HXLINE(  23)		this->set_active(false);
HXLINE(  25)		{
HXLINE(  25)			 ::flixel::math::FlxBasePoint this1 = this->scale;
HXDLIN(  25)			Float y = ( (Float)(::states::editors::ChartingState_obj::GRID_SIZE) );
HXDLIN(  25)			this1->set_x(( (Float)(::states::editors::ChartingState_obj::GRID_SIZE) ));
HXDLIN(  25)			this1->set_y(y);
            		}
HXLINE(  26)		this->loadGrid(( (int)(color1) ),( (int)(color2) ));
HXLINE(  27)		this->updateHitbox();
HXLINE(  28)		this->recalcHeight();
HXLINE(  30)		this->vortexLine =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(1,1,-1,null(),null());
HXLINE(  31)		{
HXLINE(  31)			 ::flixel::math::FlxBasePoint this2 = this->vortexLine->scale;
HXDLIN(  31)			this2->set_x(this->get_width());
            		}
HXLINE(  32)		this->vortexLine->scrollFactor->set_x(( (Float)(0) ));
HXLINE(  33)		this->vortexLine->set_color(-10092544);
HXLINE(  34)		this->vortexLine->updateHitbox();
HXLINE(  36)		this->stripe =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(1,1,-1,null(),null());
HXLINE(  37)		this->stripe->scrollFactor->set_x(( (Float)(0) ));
HXLINE(  38)		this->stripe->set_color(-16777216);
HXLINE(  39)		this->updateStripes();
            	}

Dynamic ChartingGridSprite_obj::__CreateEmpty() { return new ChartingGridSprite_obj; }

void *ChartingGridSprite_obj::_hx_vtable = 0;

Dynamic ChartingGridSprite_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ChartingGridSprite_obj > _hx_result = new ChartingGridSprite_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool ChartingGridSprite_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x66413d84) {
		if (inClassId<=(int)0x2c01639b) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2c01639b;
		} else {
			return inClassId==(int)0x66413d84;
		}
	} else {
		return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
	}
}

void ChartingGridSprite_obj::loadGrid(int color1,int color2){
            	HX_STACKFRAME(&_hx_pos_66fb301aeed14640_43_loadGrid)
HXLINE(  44)		 ::openfl::display::BitmapData _hx_tmp = ::flixel::addons::display::FlxGridOverlay_obj::createGrid(1,1,this->columns,2,true,color1,color2);
HXDLIN(  44)		this->loadGraphic(_hx_tmp,true,this->columns,1,null(),null());
HXLINE(  45)		this->animation->add(HX_("odd",af,91,54,00),::Array_obj< int >::fromData( _hx_array_data_2ebe8a78_2,1),null(),false,null(),null());
HXLINE(  46)		this->animation->add(HX_("even",1a,6f,1c,43),::Array_obj< int >::fromData( _hx_array_data_2ebe8a78_3,1),null(),false,null(),null());
HXLINE(  47)		this->animation->play(HX_("even",1a,6f,1c,43),true,null(),null());
HXLINE(  48)		this->updateHitbox();
HXLINE(  49)		this->recalcHeight();
            	}


HX_DEFINE_DYNAMIC_FUNC2(ChartingGridSprite_obj,loadGrid,(void))

void ChartingGridSprite_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_66fb301aeed14640_53_draw)
HXLINE(  54)		bool _hx_tmp;
HXDLIN(  54)		bool _hx_tmp1;
HXDLIN(  54)		if (this->visible) {
HXLINE(  54)			_hx_tmp1 = (this->alpha == 0);
            		}
            		else {
HXLINE(  54)			_hx_tmp1 = true;
            		}
HXDLIN(  54)		if (!(_hx_tmp1)) {
HXLINE(  54)			Float _hx_tmp2 = this->y;
HXDLIN(  54)			Float _hx_tmp3 = (_hx_tmp2 - this->get_camera()->scroll->y);
HXDLIN(  54)			_hx_tmp = (_hx_tmp3 >= ::flixel::FlxG_obj::height);
            		}
            		else {
HXLINE(  54)			_hx_tmp = true;
            		}
HXDLIN(  54)		if (_hx_tmp) {
HXLINE(  54)			return;
            		}
HXLINE(  55)		this->scale->set_y((( (Float)(::states::editors::ChartingState_obj::GRID_SIZE) ) * ::Math_obj::min(( (Float)(1) ),this->rows)));
HXLINE(  56)		this->offset->set_y((((Float)-0.5) * (this->scale->y - ( (Float)(1) ))));
HXLINE(  58)		this->super::draw();
HXLINE(  59)		if ((this->rows <= 1)) {
HXLINE(  61)			this->_drawStripes();
HXLINE(  62)			return;
            		}
HXLINE(  65)		Float initialY = this->y;
HXLINE(  66)		{
HXLINE(  66)			int _g = 1;
HXDLIN(  66)			int _g1 = ::Math_obj::ceil(this->rows);
HXDLIN(  66)			while((_g < _g1)){
HXLINE(  66)				_g = (_g + 1);
HXDLIN(  66)				int i = (_g - 1);
HXLINE(  68)				this->set_y((this->y + (::states::editors::ChartingState_obj::GRID_SIZE + this->spacing)));
HXLINE(  69)				Float _hx_tmp4 = this->y;
HXDLIN(  69)				Float _hx_tmp5 = (_hx_tmp4 - this->get_camera()->scroll->y);
HXDLIN(  69)				if ((_hx_tmp5 >= ::flixel::FlxG_obj::height)) {
HXLINE(  70)					goto _hx_goto_4;
            				}
HXLINE(  72)				::String _hx_tmp6;
HXDLIN(  72)				if ((::hx::Mod(i,2) == 1)) {
HXLINE(  72)					_hx_tmp6 = HX_("odd",af,91,54,00);
            				}
            				else {
HXLINE(  72)					_hx_tmp6 = HX_("even",1a,6f,1c,43);
            				}
HXDLIN(  72)				this->animation->play(_hx_tmp6,true,null(),null());
HXLINE(  73)				this->scale->set_y((( (Float)(::states::editors::ChartingState_obj::GRID_SIZE) ) * ::Math_obj::min(( (Float)(1) ),(this->rows - ( (Float)(i) )))));
HXLINE(  74)				this->offset->set_y((((Float)-0.5) * (this->scale->y - ( (Float)(1) ))));
HXLINE(  75)				this->super::draw();
            			}
            			_hx_goto_4:;
            		}
HXLINE(  77)		this->animation->play(HX_("even",1a,6f,1c,43),true,null(),null());
HXLINE(  78)		this->set_y(initialY);
HXLINE(  80)		this->_drawStripes();
HXLINE(  82)		if (this->vortexLineEnabled) {
HXLINE(  84)			this->vortexLine->set_x(this->x);
HXLINE(  85)			this->vortexLine->set_y((this->y - ( (Float)(1) )));
HXLINE(  86)			while(true){
HXLINE(  88)				 ::flixel::FlxSprite fh = this->vortexLine;
HXDLIN(  88)				fh->set_y((fh->y + this->vortexLineSpace));
HXLINE(  89)				Float _hx_tmp7 = this->vortexLine->y;
HXDLIN(  89)				Float _hx_tmp8 = this->y;
HXDLIN(  89)				if ((_hx_tmp7 >= (_hx_tmp8 + this->get_height()))) {
HXLINE(  89)					goto _hx_goto_5;
            				}
HXLINE(  91)				this->vortexLine->draw();
            			}
            			_hx_goto_5:;
            		}
            	}


void ChartingGridSprite_obj::_drawStripes(){
            	HX_STACKFRAME(&_hx_pos_66fb301aeed14640_98__drawStripes)
HXDLIN(  98)		int _g_current = 0;
HXDLIN(  98)		::Array< int > _g_array = this->stripes;
HXDLIN(  98)		while((_g_current < _g_array->length)){
HXDLIN(  98)			int _g_value = _g_array->__get(_g_current);
HXDLIN(  98)			_g_current = (_g_current + 1);
HXDLIN(  98)			int _g_key = (_g_current - 1);
HXDLIN(  98)			int i = _g_key;
HXDLIN(  98)			int column = _g_value;
HXLINE(  99)			{
HXLINE( 100)				if ((column == 0)) {
HXLINE( 101)					this->stripe->set_x(this->x);
            				}
            				else {
HXLINE( 103)					 ::flixel::FlxSprite _hx_tmp = this->stripe;
HXDLIN( 103)					Float _hx_tmp1 = (this->x + (::states::editors::ChartingState_obj::GRID_SIZE * column));
HXDLIN( 103)					_hx_tmp->set_x((_hx_tmp1 - (this->stripe->get_width() / ( (Float)(2) ))));
            				}
HXLINE( 104)				this->stripe->draw();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(ChartingGridSprite_obj,_drawStripes,(void))

void ChartingGridSprite_obj::updateStripes(){
            	HX_STACKFRAME(&_hx_pos_66fb301aeed14640_109_updateStripes)
HXLINE( 110)		bool _hx_tmp;
HXDLIN( 110)		if (::hx::IsNotNull( this->stripe )) {
HXLINE( 110)			_hx_tmp = !(this->stripe->exists);
            		}
            		else {
HXLINE( 110)			_hx_tmp = true;
            		}
HXDLIN( 110)		if (_hx_tmp) {
HXLINE( 110)			return;
            		}
HXLINE( 111)		this->stripe->set_y(this->y);
HXLINE( 112)		 ::flixel::FlxSprite _hx_tmp1 = this->stripe;
HXDLIN( 112)		_hx_tmp1->setGraphicSize(2,this->get_height());
HXLINE( 113)		this->stripe->updateHitbox();
            	}


HX_DEFINE_DYNAMIC_FUNC0(ChartingGridSprite_obj,updateStripes,(void))

Float ChartingGridSprite_obj::set_rows(Float v){
            	HX_STACKFRAME(&_hx_pos_66fb301aeed14640_117_set_rows)
HXLINE( 118)		this->rows = v;
HXLINE( 119)		this->recalcHeight();
HXLINE( 120)		return this->rows;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ChartingGridSprite_obj,set_rows,return )

int ChartingGridSprite_obj::set_spacing(int v){
            	HX_STACKFRAME(&_hx_pos_66fb301aeed14640_124_set_spacing)
HXLINE( 125)		this->spacing = v;
HXLINE( 126)		this->recalcHeight();
HXLINE( 127)		return this->spacing;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ChartingGridSprite_obj,set_spacing,return )

void ChartingGridSprite_obj::recalcHeight(){
            	HX_STACKFRAME(&_hx_pos_66fb301aeed14640_131_recalcHeight)
HXLINE( 132)		this->set_height(((( (Float)((::states::editors::ChartingState_obj::GRID_SIZE + this->spacing)) ) * this->rows) - ( (Float)(this->spacing) )));
HXLINE( 133)		this->updateStripes();
            	}


HX_DEFINE_DYNAMIC_FUNC0(ChartingGridSprite_obj,recalcHeight,(void))


::hx::ObjectPtr< ChartingGridSprite_obj > ChartingGridSprite_obj::__new(int columns, ::Dynamic __o_color1, ::Dynamic __o_color2) {
	::hx::ObjectPtr< ChartingGridSprite_obj > __this = new ChartingGridSprite_obj();
	__this->__construct(columns,__o_color1,__o_color2);
	return __this;
}

::hx::ObjectPtr< ChartingGridSprite_obj > ChartingGridSprite_obj::__alloc(::hx::Ctx *_hx_ctx,int columns, ::Dynamic __o_color1, ::Dynamic __o_color2) {
	ChartingGridSprite_obj *__this = (ChartingGridSprite_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(ChartingGridSprite_obj), true, "states.editors.content.ChartingGridSprite"));
	*(void **)__this = ChartingGridSprite_obj::_hx_vtable;
	__this->__construct(columns,__o_color1,__o_color2);
	return __this;
}

ChartingGridSprite_obj::ChartingGridSprite_obj()
{
}

void ChartingGridSprite_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ChartingGridSprite);
	HX_MARK_MEMBER_NAME(rows,"rows");
	HX_MARK_MEMBER_NAME(columns,"columns");
	HX_MARK_MEMBER_NAME(spacing,"spacing");
	HX_MARK_MEMBER_NAME(stripe,"stripe");
	HX_MARK_MEMBER_NAME(stripes,"stripes");
	HX_MARK_MEMBER_NAME(vortexLine,"vortexLine");
	HX_MARK_MEMBER_NAME(vortexLineEnabled,"vortexLineEnabled");
	HX_MARK_MEMBER_NAME(vortexLineSpace,"vortexLineSpace");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void ChartingGridSprite_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(rows,"rows");
	HX_VISIT_MEMBER_NAME(columns,"columns");
	HX_VISIT_MEMBER_NAME(spacing,"spacing");
	HX_VISIT_MEMBER_NAME(stripe,"stripe");
	HX_VISIT_MEMBER_NAME(stripes,"stripes");
	HX_VISIT_MEMBER_NAME(vortexLine,"vortexLine");
	HX_VISIT_MEMBER_NAME(vortexLineEnabled,"vortexLineEnabled");
	HX_VISIT_MEMBER_NAME(vortexLineSpace,"vortexLineSpace");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val ChartingGridSprite_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"rows") ) { return ::hx::Val( rows ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"stripe") ) { return ::hx::Val( stripe ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"columns") ) { return ::hx::Val( columns ); }
		if (HX_FIELD_EQ(inName,"spacing") ) { return ::hx::Val( spacing ); }
		if (HX_FIELD_EQ(inName,"stripes") ) { return ::hx::Val( stripes ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"loadGrid") ) { return ::hx::Val( loadGrid_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_rows") ) { return ::hx::Val( set_rows_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"vortexLine") ) { return ::hx::Val( vortexLine ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"set_spacing") ) { return ::hx::Val( set_spacing_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_drawStripes") ) { return ::hx::Val( _drawStripes_dyn() ); }
		if (HX_FIELD_EQ(inName,"recalcHeight") ) { return ::hx::Val( recalcHeight_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"updateStripes") ) { return ::hx::Val( updateStripes_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"vortexLineSpace") ) { return ::hx::Val( vortexLineSpace ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"vortexLineEnabled") ) { return ::hx::Val( vortexLineEnabled ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val ChartingGridSprite_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"rows") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_rows(inValue.Cast< Float >()) );rows=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"stripe") ) { stripe=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"columns") ) { columns=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"spacing") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_spacing(inValue.Cast< int >()) );spacing=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"stripes") ) { stripes=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"vortexLine") ) { vortexLine=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"vortexLineSpace") ) { vortexLineSpace=inValue.Cast< Float >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"vortexLineEnabled") ) { vortexLineEnabled=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void ChartingGridSprite_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("rows",19,f5,ae,4b));
	outFields->push(HX_("columns",dd,ac,59,f3));
	outFields->push(HX_("spacing",83,33,bb,91));
	outFields->push(HX_("stripe",8d,2a,30,11));
	outFields->push(HX_("stripes",46,11,f5,f8));
	outFields->push(HX_("vortexLine",82,bb,dd,15));
	outFields->push(HX_("vortexLineEnabled",1f,c5,3f,40));
	outFields->push(HX_("vortexLineSpace",e4,49,75,54));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo ChartingGridSprite_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(ChartingGridSprite_obj,rows),HX_("rows",19,f5,ae,4b)},
	{::hx::fsInt,(int)offsetof(ChartingGridSprite_obj,columns),HX_("columns",dd,ac,59,f3)},
	{::hx::fsInt,(int)offsetof(ChartingGridSprite_obj,spacing),HX_("spacing",83,33,bb,91)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(ChartingGridSprite_obj,stripe),HX_("stripe",8d,2a,30,11)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(ChartingGridSprite_obj,stripes),HX_("stripes",46,11,f5,f8)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(ChartingGridSprite_obj,vortexLine),HX_("vortexLine",82,bb,dd,15)},
	{::hx::fsBool,(int)offsetof(ChartingGridSprite_obj,vortexLineEnabled),HX_("vortexLineEnabled",1f,c5,3f,40)},
	{::hx::fsFloat,(int)offsetof(ChartingGridSprite_obj,vortexLineSpace),HX_("vortexLineSpace",e4,49,75,54)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *ChartingGridSprite_obj_sStaticStorageInfo = 0;
#endif

static ::String ChartingGridSprite_obj_sMemberFields[] = {
	HX_("rows",19,f5,ae,4b),
	HX_("columns",dd,ac,59,f3),
	HX_("spacing",83,33,bb,91),
	HX_("stripe",8d,2a,30,11),
	HX_("stripes",46,11,f5,f8),
	HX_("vortexLine",82,bb,dd,15),
	HX_("vortexLineEnabled",1f,c5,3f,40),
	HX_("vortexLineSpace",e4,49,75,54),
	HX_("loadGrid",0c,a8,0b,b5),
	HX_("draw",04,2c,70,42),
	HX_("_drawStripes",a3,03,47,a8),
	HX_("updateStripes",3d,76,63,c4),
	HX_("set_rows",16,0a,c7,79),
	HX_("set_spacing",a6,9a,22,22),
	HX_("recalcHeight",cf,d3,39,d6),
	::String(null()) };

::hx::Class ChartingGridSprite_obj::__mClass;

void ChartingGridSprite_obj::__register()
{
	ChartingGridSprite_obj _hx_dummy;
	ChartingGridSprite_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("states.editors.content.ChartingGridSprite",78,8a,be,2e);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(ChartingGridSprite_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< ChartingGridSprite_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ChartingGridSprite_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ChartingGridSprite_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace states
} // end namespace editors
} // end namespace content
