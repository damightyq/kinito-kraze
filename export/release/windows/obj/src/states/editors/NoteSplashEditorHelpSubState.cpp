// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_backend_Controls
#include <backend/Controls.h>
#endif
#ifndef INCLUDED_backend_MusicBeatSubstate
#include <backend/MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_states_editors_NoteSplashEditorHelpSubState
#include <states/editors/NoteSplashEditorHelpSubState.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e60d9ab549b0e2a2_931_new,"states.editors.NoteSplashEditorHelpSubState","new",0x05de87fe,"states.editors.NoteSplashEditorHelpSubState.new","states/editors/NoteSplashEditorState.hx",931,0x384b3409)
static const ::String _hx_array_data_0747710c_2[] = {
	HX_("Click on a Strum or Press Space",cb,c9,fe,b2),HX_("to spawn a Splash",f0,62,f6,ed),HX_("",00,00,00,00),HX_("Arrow Keys - Move Offset",5a,b1,3f,a8),HX_("Hold Shift - Move Offsets 10x faster",ed,e3,6d,e4),HX_("",00,00,00,00),HX_("Ctrl + C - Copy Current Offset",2b,cb,75,2f),HX_("Ctrl + V - Paste Copied Offset on Current Splash",2a,3b,62,40),HX_("Ctrl + R - Reset Current Offset",d6,1c,dc,bf),HX_("",00,00,00,00),HX_("On every 4 subsequent note datas",54,c1,85,38),HX_("an extra set of animations will be added",28,b6,4e,1d),
};
HX_LOCAL_STACK_FRAME(_hx_pos_e60d9ab549b0e2a2_978_update,"states.editors.NoteSplashEditorHelpSubState","update",0x7236e52b,"states.editors.NoteSplashEditorHelpSubState.update","states/editors/NoteSplashEditorState.hx",978,0x384b3409)
namespace states{
namespace editors{

void NoteSplashEditorHelpSubState_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_e60d9ab549b0e2a2_931_new)
HXLINE( 932)		super::__construct();
HXLINE( 934)		 ::flixel::FlxSprite bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(::flixel::FlxG_obj::width,::flixel::FlxG_obj::height,-16777216,null(),null());
HXLINE( 935)		bg->set_alpha(((Float)0.6));
HXLINE( 936)		this->add(bg);
HXLINE( 938)		::Array< ::String > str = ::Array_obj< ::String >::fromData( _hx_array_data_0747710c_2,12);
HXLINE( 951)		 ::flixel::group::FlxTypedSpriteGroup helpTexts =  ::flixel::group::FlxTypedSpriteGroup_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE( 952)		{
HXLINE( 952)			int _g_current = 0;
HXDLIN( 952)			::Array< ::String > _g_array = str;
HXDLIN( 952)			while((_g_current < _g_array->length)){
HXLINE( 952)				::String _g_value = _g_array->__get(_g_current);
HXDLIN( 952)				_g_current = (_g_current + 1);
HXDLIN( 952)				int _g_key = (_g_current - 1);
HXDLIN( 952)				int i = _g_key;
HXDLIN( 952)				::String txt = _g_value;
HXLINE( 953)				{
HXLINE( 954)					if ((txt.length < 1)) {
HXLINE( 954)						continue;
            					}
HXLINE( 956)					 ::flixel::text::FlxText helpText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,0,0,txt,24,null());
HXLINE( 957)					helpText->setFormat(null(),24,-1,HX_("center",d5,25,db,05),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn(),-16777216,null());
HXLINE( 958)					helpText->set_borderColor(-16777216);
HXLINE( 959)					{
HXLINE( 959)						 ::flixel::math::FlxBasePoint this1 = helpText->scrollFactor;
HXDLIN( 959)						this1->set_x(( (Float)(0) ));
HXDLIN( 959)						this1->set_y(( (Float)(0) ));
            					}
HXLINE( 960)					helpText->set_borderSize(( (Float)(1) ));
HXLINE( 961)					{
HXLINE( 961)						int axes = 17;
HXDLIN( 961)						bool _hx_tmp;
HXDLIN( 961)						if ((axes != 1)) {
HXLINE( 961)							_hx_tmp = (axes == 17);
            						}
            						else {
HXLINE( 961)							_hx_tmp = true;
            						}
HXDLIN( 961)						if (_hx_tmp) {
HXLINE( 961)							int _hx_tmp1 = ::flixel::FlxG_obj::width;
HXDLIN( 961)							helpText->set_x(((( (Float)(_hx_tmp1) ) - helpText->get_width()) / ( (Float)(2) )));
            						}
HXDLIN( 961)						bool _hx_tmp2;
HXDLIN( 961)						if ((axes != 16)) {
HXLINE( 961)							_hx_tmp2 = (axes == 17);
            						}
            						else {
HXLINE( 961)							_hx_tmp2 = true;
            						}
HXDLIN( 961)						if (_hx_tmp2) {
HXLINE( 961)							int _hx_tmp3 = ::flixel::FlxG_obj::height;
HXDLIN( 961)							helpText->set_y(((( (Float)(_hx_tmp3) ) - helpText->get_height()) / ( (Float)(2) )));
            						}
            					}
HXLINE( 962)					this->add(helpText);
HXLINE( 963)					helpText->set_y((helpText->y + (((( (Float)(i) ) - (( (Float)(str->length) ) / ( (Float)(2) ))) * ( (Float)(32) )) + 16)));
HXLINE( 964)					helpTexts->add(helpText).StaticCast<  ::flixel::FlxSprite >();
            				}
            			}
            		}
HXLINE( 966)		this->add(helpTexts);
HXLINE( 968)		 ::flixel::text::FlxText noteDataText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 969)		noteDataText->setFormat(null(),24,-1,HX_("right",dc,0b,64,e9),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn(),-16777216,null());
HXLINE( 970)		noteDataText->set_text(HX_("NOTE DATAS:\nLEFT: 0\nDOWN: 1\nUP: 2\nRIGHT: 3",bd,7a,df,71));
HXLINE( 971)		int _hx_tmp4 = ::flixel::FlxG_obj::width;
HXDLIN( 971)		noteDataText->set_x(((( (Float)(_hx_tmp4) ) - noteDataText->get_width()) - ( (Float)(5) )));
HXLINE( 972)		int _hx_tmp5 = ::flixel::FlxG_obj::height;
HXDLIN( 972)		noteDataText->set_y(((( (Float)(_hx_tmp5) ) - noteDataText->get_height()) - ( (Float)(5) )));
HXLINE( 974)		this->add(noteDataText);
            	}

Dynamic NoteSplashEditorHelpSubState_obj::__CreateEmpty() { return new NoteSplashEditorHelpSubState_obj; }

void *NoteSplashEditorHelpSubState_obj::_hx_vtable = 0;

Dynamic NoteSplashEditorHelpSubState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< NoteSplashEditorHelpSubState_obj > _hx_result = new NoteSplashEditorHelpSubState_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool NoteSplashEditorHelpSubState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x5661ffbf) {
		if (inClassId<=(int)0x3c0818b8) {
			if (inClassId<=(int)0x3058f3fc) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x3058f3fc;
			} else {
				return inClassId==(int)0x3c0818b8;
			}
		} else {
			return inClassId==(int)0x5661ffbf;
		}
	} else {
		if (inClassId<=(int)0x7c795c9f) {
			return inClassId==(int)0x62817b24 || inClassId==(int)0x7c795c9f;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	}
}

void NoteSplashEditorHelpSubState_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_e60d9ab549b0e2a2_978_update)
HXLINE( 979)		this->super::update(elapsed);
HXLINE( 981)		bool _hx_tmp;
HXDLIN( 981)		if (!(::backend::Controls_obj::instance->get_BACK())) {
HXLINE( 981)			 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 981)			_hx_tmp = _this->keyManager->checkStatusUnsafe(112,_this->status);
            		}
            		else {
HXLINE( 981)			_hx_tmp = true;
            		}
HXDLIN( 981)		if (_hx_tmp) {
HXLINE( 982)			this->close();
            		}
            	}



::hx::ObjectPtr< NoteSplashEditorHelpSubState_obj > NoteSplashEditorHelpSubState_obj::__new() {
	::hx::ObjectPtr< NoteSplashEditorHelpSubState_obj > __this = new NoteSplashEditorHelpSubState_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< NoteSplashEditorHelpSubState_obj > NoteSplashEditorHelpSubState_obj::__alloc(::hx::Ctx *_hx_ctx) {
	NoteSplashEditorHelpSubState_obj *__this = (NoteSplashEditorHelpSubState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(NoteSplashEditorHelpSubState_obj), true, "states.editors.NoteSplashEditorHelpSubState"));
	*(void **)__this = NoteSplashEditorHelpSubState_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

NoteSplashEditorHelpSubState_obj::NoteSplashEditorHelpSubState_obj()
{
}

::hx::Val NoteSplashEditorHelpSubState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *NoteSplashEditorHelpSubState_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *NoteSplashEditorHelpSubState_obj_sStaticStorageInfo = 0;
#endif

static ::String NoteSplashEditorHelpSubState_obj_sMemberFields[] = {
	HX_("update",09,86,05,87),
	::String(null()) };

::hx::Class NoteSplashEditorHelpSubState_obj::__mClass;

void NoteSplashEditorHelpSubState_obj::__register()
{
	NoteSplashEditorHelpSubState_obj _hx_dummy;
	NoteSplashEditorHelpSubState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("states.editors.NoteSplashEditorHelpSubState",0c,71,47,07);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(NoteSplashEditorHelpSubState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< NoteSplashEditorHelpSubState_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = NoteSplashEditorHelpSubState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = NoteSplashEditorHelpSubState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace states
} // end namespace editors
