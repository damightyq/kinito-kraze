// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_MusicBeatState
#include <backend/MusicBeatState.h>
#endif
#ifndef INCLUDED_backend_MusicBeatSubstate
#include <backend/MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIBox
#include <backend/ui/PsychUIBox.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIButton
#include <backend/ui/PsychUIButton.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUICheckBox
#include <backend/ui/PsychUICheckBox.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIDropDownMenu
#include <backend/ui/PsychUIDropDownMenu.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIEvent
#include <backend/ui/PsychUIEvent.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIInputText
#include <backend/ui/PsychUIInputText.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUINumericStepper
#include <backend/ui/PsychUINumericStepper.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUITab
#include <backend/ui/PsychUITab.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxBackdrop
#include <flixel/addons/display/FlxBackdrop.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxGridOverlay
#include <flixel/addons/display/FlxGridOverlay.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroupIterator
#include <flixel/group/FlxTypedGroupIterator.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMath
#include <flixel/math/FlxMath.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_psychlua_ModchartSprite
#include <psychlua/ModchartSprite.h>
#endif
#ifndef INCLUDED_states_editors_StageEditorAnimationSubstate
#include <states/editors/StageEditorAnimationSubstate.h>
#endif
#ifndef INCLUDED_states_editors_StageEditorMetaSprite
#include <states/editors/StageEditorMetaSprite.h>
#endif
#ifndef INCLUDED_states_editors_StageEditorState
#include <states/editors/StageEditorState.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9b82f77f5e054157_2021_new,"states.editors.StageEditorAnimationSubstate","new",0xc2aeee30,"states.editors.StageEditorAnimationSubstate.new","states/editors/StageEditorState.hx",2021,0xcafb7822)
HX_DEFINE_STACK_FRAME(_hx_pos_9b82f77f5e054157_2039_new,"states.editors.StageEditorAnimationSubstate","new",0xc2aeee30,"states.editors.StageEditorAnimationSubstate.new","states/editors/StageEditorState.hx",2039,0xcafb7822)
HX_DEFINE_STACK_FRAME(_hx_pos_9b82f77f5e054157_1989_new,"states.editors.StageEditorAnimationSubstate","new",0xc2aeee30,"states.editors.StageEditorAnimationSubstate.new","states/editors/StageEditorState.hx",1989,0xcafb7822)
static const ::String _hx_array_data_7f38563e_3[] = {
	HX_("Animations",0f,39,cd,79),
};
HX_LOCAL_STACK_FRAME(_hx_pos_9b82f77f5e054157_2074_addAnimationsUI,"states.editors.StageEditorAnimationSubstate","addAnimationsUI",0x0a0eda94,"states.editors.StageEditorAnimationSubstate.addAnimationsUI","states/editors/StageEditorState.hx",2074,0xcafb7822)
HX_LOCAL_STACK_FRAME(_hx_pos_9b82f77f5e054157_2088_addAnimationsUI,"states.editors.StageEditorAnimationSubstate","addAnimationsUI",0x0a0eda94,"states.editors.StageEditorAnimationSubstate.addAnimationsUI","states/editors/StageEditorState.hx",2088,0xcafb7822)
HX_LOCAL_STACK_FRAME(_hx_pos_9b82f77f5e054157_2098_addAnimationsUI,"states.editors.StageEditorAnimationSubstate","addAnimationsUI",0x0a0eda94,"states.editors.StageEditorAnimationSubstate.addAnimationsUI","states/editors/StageEditorState.hx",2098,0xcafb7822)
HX_LOCAL_STACK_FRAME(_hx_pos_9b82f77f5e054157_2148_addAnimationsUI,"states.editors.StageEditorAnimationSubstate","addAnimationsUI",0x0a0eda94,"states.editors.StageEditorAnimationSubstate.addAnimationsUI","states/editors/StageEditorState.hx",2148,0xcafb7822)
HX_LOCAL_STACK_FRAME(_hx_pos_9b82f77f5e054157_2065_addAnimationsUI,"states.editors.StageEditorAnimationSubstate","addAnimationsUI",0x0a0eda94,"states.editors.StageEditorAnimationSubstate.addAnimationsUI","states/editors/StageEditorState.hx",2065,0xcafb7822)
static const ::String _hx_array_data_7f38563e_14[] = {
	HX_("",00,00,00,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_9b82f77f5e054157_2195_reloadAnimList,"states.editors.StageEditorAnimationSubstate","reloadAnimList",0xfb0b4fb8,"states.editors.StageEditorAnimationSubstate.reloadAnimList","states/editors/StageEditorState.hx",2195,0xcafb7822)
HX_LOCAL_STACK_FRAME(_hx_pos_9b82f77f5e054157_2238_reloadAnimationDropDown,"states.editors.StageEditorAnimationSubstate","reloadAnimationDropDown",0x236ded8c,"states.editors.StageEditorAnimationSubstate.reloadAnimationDropDown","states/editors/StageEditorState.hx",2238,0xcafb7822)
HX_LOCAL_STACK_FRAME(_hx_pos_9b82f77f5e054157_2248_updateTextColors,"states.editors.StageEditorAnimationSubstate","updateTextColors",0xb76d95d6,"states.editors.StageEditorAnimationSubstate.updateTextColors","states/editors/StageEditorState.hx",2248,0xcafb7822)
HX_LOCAL_STACK_FRAME(_hx_pos_9b82f77f5e054157_2256_playAnim,"states.editors.StageEditorAnimationSubstate","playAnim",0x87fbba55,"states.editors.StageEditorAnimationSubstate.playAnim","states/editors/StageEditorState.hx",2256,0xcafb7822)
HX_LOCAL_STACK_FRAME(_hx_pos_9b82f77f5e054157_2269_update,"states.editors.StageEditorAnimationSubstate","update",0x2436ea39,"states.editors.StageEditorAnimationSubstate.update","states/editors/StageEditorState.hx",2269,0xcafb7822)
namespace states{
namespace editors{

void StageEditorAnimationSubstate_obj::__construct(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::states::editors::StageEditorAnimationSubstate,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_9b82f77f5e054157_2021_new)
HXLINE(2022)			_gthis->curAnim = 0;
HXLINE(2023)			_gthis->originalZoom = ::flixel::FlxG_obj::camera->zoom;
HXLINE(2024)			Float x = ::flixel::FlxG_obj::camera->scroll->x;
HXDLIN(2024)			Float y = ::flixel::FlxG_obj::camera->scroll->y;
HXDLIN(2024)			 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN(2024)			point->_inPool = false;
HXDLIN(2024)			 ::flixel::math::FlxBasePoint point1 = point;
HXDLIN(2024)			point1->_weak = true;
HXDLIN(2024)			_gthis->originalCamPoint = point1;
HXLINE(2025)			Float x1 = _gthis->target->get_x();
HXDLIN(2025)			Float y1 = _gthis->target->get_y();
HXDLIN(2025)			 ::flixel::math::FlxBasePoint point2 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x1,y1);
HXDLIN(2025)			point2->_inPool = false;
HXDLIN(2025)			 ::flixel::math::FlxBasePoint point3 = point2;
HXDLIN(2025)			point3->_weak = true;
HXDLIN(2025)			_gthis->originalPosition = point3;
HXLINE(2026)			_gthis->originalCamTarget = ::flixel::FlxG_obj::camera->target;
HXLINE(2027)			_gthis->originalAlpha = _gthis->target->get_alpha();
HXLINE(2028)			::flixel::FlxG_obj::camera->set_zoom(((Float)0.5));
HXLINE(2029)			{
HXLINE(2029)				 ::flixel::math::FlxBasePoint this1 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN(2029)				this1->set_x(( (Float)(0) ));
HXDLIN(2029)				this1->set_y(( (Float)(0) ));
            			}
HXLINE(2031)			_gthis->target->set_alpha(( (Float)(1) ));
HXLINE(2032)			{
HXLINE(2032)				 ::flixel::FlxSprite _this = _gthis->target->sprite;
HXDLIN(2032)				int axes = 17;
HXDLIN(2032)				bool _hx_tmp;
HXDLIN(2032)				if ((axes != 1)) {
HXLINE(2032)					_hx_tmp = (axes == 17);
            				}
            				else {
HXLINE(2032)					_hx_tmp = true;
            				}
HXDLIN(2032)				if (_hx_tmp) {
HXLINE(2032)					int _hx_tmp1 = ::flixel::FlxG_obj::width;
HXDLIN(2032)					_this->set_x(((( (Float)(_hx_tmp1) ) - _this->get_width()) / ( (Float)(2) )));
            				}
HXDLIN(2032)				bool _hx_tmp2;
HXDLIN(2032)				if ((axes != 16)) {
HXLINE(2032)					_hx_tmp2 = (axes == 17);
            				}
            				else {
HXLINE(2032)					_hx_tmp2 = true;
            				}
HXDLIN(2032)				if (_hx_tmp2) {
HXLINE(2032)					int _hx_tmp3 = ::flixel::FlxG_obj::height;
HXDLIN(2032)					_this->set_y(((( (Float)(_hx_tmp3) ) - _this->get_height()) / ( (Float)(2) )));
            				}
            			}
HXLINE(2033)			_gthis->add(_gthis->target->sprite).StaticCast<  ::flixel::FlxBasic >();
HXLINE(2034)			_gthis->reloadAnimList();
HXLINE(2035)			::haxe::Log_obj::trace(HX_("Opened substate",c8,04,af,a3),::hx::SourceInfo(HX_("source/states/editors/StageEditorState.hx",16,7c,21,9d),2035,HX_("states.editors.StageEditorAnimationSubstate",3e,56,38,7f),HX_("new",60,d0,53,00)));
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::states::editors::StageEditorAnimationSubstate,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_9b82f77f5e054157_2039_new)
HXLINE(2040)			::flixel::FlxG_obj::camera->set_zoom(_gthis->originalZoom);
HXLINE(2041)			{
HXLINE(2041)				 ::flixel::math::FlxBasePoint this1 = ::flixel::FlxG_obj::camera->scroll;
HXDLIN(2041)				Float y = _gthis->originalCamPoint->y;
HXDLIN(2041)				this1->set_x(_gthis->originalCamPoint->x);
HXDLIN(2041)				this1->set_y(y);
            			}
HXLINE(2042)			::flixel::FlxG_obj::camera->target = _gthis->originalCamTarget;
HXLINE(2044)			_gthis->target->set_x(_gthis->originalPosition->x);
HXLINE(2045)			_gthis->target->set_y(_gthis->originalPosition->y);
HXLINE(2046)			_gthis->target->set_alpha(_gthis->originalAlpha);
HXLINE(2047)			_gthis->remove(_gthis->target->sprite,null()).StaticCast<  ::flixel::FlxBasic >();
HXLINE(2049)			if ((_gthis->target->animations->length > 0)) {
HXLINE(2051)				if (::hx::IsNull( _gthis->target->firstAnimation )) {
HXLINE(2051)					_gthis->target->firstAnimation = ( (::String)(_gthis->target->animations->__get(0)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) );
            				}
HXLINE(2052)				_gthis->playAnim(_gthis->target->firstAnimation,null());
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_9b82f77f5e054157_1989_new)
HXLINE(2267)		this->holdingFrameElapsed = ((Float)0);
HXLINE(2266)		this->holdingFrameTime = ((Float)0);
HXLINE(2265)		this->holdingArrowsElapsed = ((Float)0);
HXLINE(2264)		this->holdingArrowsTime = ((Float)0);
HXLINE(2263)		this->maxZoom = 2;
HXLINE(2262)		this->minZoom = ((Float)0.25);
HXLINE(2002)		this->camHUD = ::hx::TCast<  ::states::editors::StageEditorState >::cast(::flixel::FlxG_obj::game->_state)->camHUD;
HXLINE(1998)		this->curAnim = 0;
HXLINE(1995)		this->originalAlpha = ((Float)1);
HXLINE(2004)		 ::states::editors::StageEditorAnimationSubstate _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE(2005)		super::__construct();
HXLINE(2007)		 ::flixel::addons::display::FlxBackdrop grid =  ::flixel::addons::display::FlxBackdrop_obj::__alloc( HX_CTX ,::flixel::addons::display::FlxGridOverlay_obj::createGrid(50,50,100,100,true,-5592406,-10066330),null(),null(),null());
HXLINE(2008)		this->add(grid);
HXLINE(2010)		this->animsTxtGroup =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(2011)		this->animsTxtGroup->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE(2012)		this->add(this->animsTxtGroup);
HXLINE(2014)		this->UI_animationbox =  ::backend::ui::PsychUIBox_obj::__alloc( HX_CTX ,( (Float)((::flixel::FlxG_obj::width - 320)) ),( (Float)(20) ),300,250,::Array_obj< ::String >::fromData( _hx_array_data_7f38563e_3,1));
HXLINE(2015)		this->UI_animationbox->set_cameras(::Array_obj< ::Dynamic>::__new(1)->init(0,this->camHUD));
HXLINE(2016)		{
HXLINE(2016)			 ::flixel::math::FlxBasePoint this1 = this->UI_animationbox->scrollFactor;
HXDLIN(2016)			this1->set_x(( (Float)(0) ));
HXDLIN(2016)			this1->set_y(( (Float)(0) ));
            		}
HXLINE(2017)		this->add(this->UI_animationbox);
HXLINE(2018)		this->addAnimationsUI();
HXLINE(2020)		this->openCallback =  ::Dynamic(new _hx_Closure_0(_gthis));
HXLINE(2038)		this->closeCallback =  ::Dynamic(new _hx_Closure_1(_gthis));
            	}

Dynamic StageEditorAnimationSubstate_obj::__CreateEmpty() { return new StageEditorAnimationSubstate_obj; }

void *StageEditorAnimationSubstate_obj::_hx_vtable = 0;

Dynamic StageEditorAnimationSubstate_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< StageEditorAnimationSubstate_obj > _hx_result = new StageEditorAnimationSubstate_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool StageEditorAnimationSubstate_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x5661ffbf) {
		if (inClassId<=(int)0x3c0818b8) {
			if (inClassId<=(int)0x1577d9ba) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x1577d9ba;
			} else {
				return inClassId==(int)0x3c0818b8;
			}
		} else {
			return inClassId==(int)0x5661ffbf;
		}
	} else {
		if (inClassId<=(int)0x7c795c9f) {
			return inClassId==(int)0x62817b24 || inClassId==(int)0x7c795c9f;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	}
}

void StageEditorAnimationSubstate_obj::addAnimationsUI(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::states::editors::StageEditorAnimationSubstate,_gthis) HXARGC(2)
            		void _hx_run(int selectedAnimation,::String pressed){
            			HX_GC_STACKFRAME(&_hx_pos_9b82f77f5e054157_2074_addAnimationsUI)
HXLINE(2075)			 ::Dynamic anim = _gthis->target->animations->__get(selectedAnimation);
HXLINE(2076)			if (::hx::IsNull( anim )) {
HXLINE(2076)				return;
            			}
HXLINE(2078)			_gthis->animationInputText->set_text(( (::String)(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ));
HXLINE(2079)			_gthis->animationNameInputText->set_text(( (::String)(anim->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic)) ));
HXLINE(2080)			_gthis->animationLoopCheckBox->set_checked( ::Dynamic(anim->__Field(HX_("loop",64,a6,b7,47),::hx::paccDynamic)));
HXLINE(2081)			_gthis->animationFramerate->set_value(( (Float)(anim->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic)) ));
HXLINE(2083)			::String indicesStr = ( (::Array< int >)(anim->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) )->toString();
HXLINE(2084)			 ::backend::ui::PsychUIInputText _gthis1 = _gthis->animationIndicesInputText;
HXDLIN(2084)			_gthis1->set_text(indicesStr.substr(1,(indicesStr.length - 2)));
            		}
            		HX_END_LOCAL_FUNC2((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::states::editors::StageEditorAnimationSubstate,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_9b82f77f5e054157_2088_addAnimationsUI)
HXLINE(2089)			 ::Dynamic anim = _gthis->target->animations->__get(_gthis->curAnim);
HXLINE(2090)			if (::hx::IsNull( anim )) {
HXLINE(2090)				return;
            			}
HXLINE(2092)			_gthis->mainAnimTxt->set_text(( (::String)((HX_("Main Anim.: ",fc,45,e6,8a) + anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic))) ));
HXLINE(2093)			_gthis->target->firstAnimation = ( (::String)(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) );
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_2, ::states::editors::StageEditorAnimationSubstate,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_9b82f77f5e054157_2098_addAnimationsUI)
HXLINE(2099)			if ((_gthis->animationInputText->text == HX_("",00,00,00,00))) {
HXLINE(2099)				return;
            			}
HXLINE(2101)			::Array< int > indices = ::Array_obj< int >::__new(0);
HXLINE(2102)			::Array< ::String > indicesStr = ::StringTools_obj::trim(_gthis->animationIndicesInputText->text).split(HX_(",",2c,00,00,00));
HXLINE(2103)			if ((indicesStr->length > 1)) {
HXLINE(2104)				int _g = 0;
HXDLIN(2104)				int _g1 = indicesStr->length;
HXDLIN(2104)				while((_g < _g1)){
HXLINE(2104)					_g = (_g + 1);
HXDLIN(2104)					int i = (_g - 1);
HXLINE(2105)					int index = ( (int)(::Std_obj::parseInt(indicesStr->__get(i))) );
HXLINE(2106)					bool addUpdateButton;
HXDLIN(2106)					bool addUpdateButton1;
HXDLIN(2106)					bool addUpdateButton2;
HXDLIN(2106)					if (::hx::IsNotNull( indicesStr->__get(i) )) {
HXLINE(2106)						addUpdateButton2 = (indicesStr->__get(i) != HX_("",00,00,00,00));
            					}
            					else {
HXLINE(2106)						addUpdateButton2 = false;
            					}
HXDLIN(2106)					if (addUpdateButton2) {
HXLINE(2106)						addUpdateButton1 = !(::Math_obj::isNaN(( (Float)(index) )));
            					}
            					else {
HXLINE(2106)						addUpdateButton1 = false;
            					}
HXDLIN(2106)					if (addUpdateButton1) {
HXLINE(2106)						addUpdateButton = (index > -1);
            					}
            					else {
HXLINE(2106)						addUpdateButton = false;
            					}
HXDLIN(2106)					if (addUpdateButton) {
HXLINE(2107)						indices->push(index);
            					}
            				}
            			}
HXLINE(2112)			::String lastAnim;
HXDLIN(2112)			if (::hx::IsNotNull( _gthis->target->animations->__get(_gthis->curAnim) )) {
HXLINE(2112)				lastAnim = ( (::String)(_gthis->target->animations->__get(_gthis->curAnim)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) );
            			}
            			else {
HXLINE(2112)				lastAnim = HX_("",00,00,00,00);
            			}
HXLINE(2113)			::Array< int > lastOffsets = null();
HXLINE(2114)			{
HXLINE(2114)				int _g2 = 0;
HXDLIN(2114)				::Array< ::Dynamic> _g3 = _gthis->target->animations;
HXDLIN(2114)				while((_g2 < _g3->length)){
HXLINE(2114)					 ::Dynamic anim = _g3->__get(_g2);
HXDLIN(2114)					_g2 = (_g2 + 1);
HXLINE(2115)					if (::hx::IsEq( _gthis->animationInputText->text,anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) )) {
HXLINE(2117)						lastOffsets = ( (::Array< int >)(anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) );
HXLINE(2118)						::hx::TCast<  ::psychlua::ModchartSprite >::cast(_gthis->target->sprite)->animOffsets->remove(_gthis->animationInputText->text);
HXLINE(2119)						_gthis->target->sprite->animation->remove(_gthis->animationInputText->text);
HXLINE(2120)						_gthis->target->animations->remove(anim);
            					}
            				}
            			}
HXLINE(2123)			 ::Dynamic addedAnim =  ::Dynamic(::hx::Anon_obj::Create(6)
            				->setFixed(0,HX_("offsets",80,09,65,d7),lastOffsets)
            				->setFixed(1,HX_("indices",27,47,54,e3),indices)
            				->setFixed(2,HX_("fps",e9,c7,4d,00),::Math_obj::round(_gthis->animationFramerate->value))
            				->setFixed(3,HX_("anim",11,86,71,40),_gthis->animationInputText->text)
            				->setFixed(4,HX_("loop",64,a6,b7,47),_gthis->animationLoopCheckBox->checked)
            				->setFixed(5,HX_("name",4b,72,ff,48),_gthis->animationNameInputText->text));
HXLINE(2132)			bool addUpdateButton3;
HXDLIN(2132)			if (::hx::IsNotNull( addedAnim->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic) )) {
HXLINE(2132)				addUpdateButton3 = (( (::Array< int >)(addedAnim->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) )->length > 0);
            			}
            			else {
HXLINE(2132)				addUpdateButton3 = false;
            			}
HXDLIN(2132)			if (addUpdateButton3) {
HXLINE(2133)				_gthis->target->sprite->animation->addByIndices(( (::String)(addedAnim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),( (::String)(addedAnim->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic)) ),( (::Array< int >)(addedAnim->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) ),HX_("",00,00,00,00),addedAnim->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic),addedAnim->__Field(HX_("loop",64,a6,b7,47),::hx::paccDynamic),null(),null());
            			}
            			else {
HXLINE(2135)				_gthis->target->sprite->animation->addByPrefix(( (::String)(addedAnim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),( (::String)(addedAnim->__Field(HX_("name",4b,72,ff,48),::hx::paccDynamic)) ),addedAnim->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic),addedAnim->__Field(HX_("loop",64,a6,b7,47),::hx::paccDynamic),null(),null());
            			}
HXLINE(2137)			_gthis->target->animations->push(addedAnim);
HXLINE(2138)			_gthis->reloadAnimList();
HXLINE(2139)			_gthis->playAnim(( (::String)(addedAnim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true);
HXLINE(2141)			_gthis->curAnim = (_gthis->target->animations->length - 1);
HXLINE(2142)			{
HXLINE(2142)				int _g_current = 0;
HXDLIN(2142)				::Array< ::Dynamic> _g_array = _gthis->animsTxtGroup->members;
HXDLIN(2142)				while((_g_current < _g_array->length)){
HXLINE(2142)					 ::flixel::text::FlxText _g_value = _g_array->__get(_g_current).StaticCast<  ::flixel::text::FlxText >();
HXDLIN(2142)					_g_current = (_g_current + 1);
HXDLIN(2142)					int _g_key = (_g_current - 1);
HXDLIN(2142)					int num = _g_key;
HXDLIN(2142)					 ::flixel::text::FlxText text = _g_value;
HXDLIN(2142)					{
HXLINE(2142)						text->set_color(-1);
HXDLIN(2142)						if ((num == _gthis->curAnim)) {
HXLINE(2142)							text->set_color(-16711936);
            						}
            					}
            				}
            			}
HXLINE(2143)			::haxe::Log_obj::trace((HX_("Added/Updated animation: ",f6,52,6a,23) + _gthis->animationInputText->text),::hx::SourceInfo(HX_("source/states/editors/StageEditorState.hx",16,7c,21,9d),2143,HX_("states.editors.StageEditorAnimationSubstate",3e,56,38,7f),HX_("addAnimationsUI",c4,44,96,30)));
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_3, ::states::editors::StageEditorAnimationSubstate,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_9b82f77f5e054157_2148_addAnimationsUI)
HXLINE(2148)			int _g = 0;
HXDLIN(2148)			::Array< ::Dynamic> _g1 = _gthis->target->animations;
HXDLIN(2148)			while((_g < _g1->length)){
HXLINE(2148)				 ::Dynamic anim = _g1->__get(_g);
HXDLIN(2148)				_g = (_g + 1);
HXLINE(2150)				if (::hx::IsEq( _gthis->animationInputText->text,anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic) )) {
HXLINE(2152)					 ::psychlua::ModchartSprite targetSprite = ::hx::TCast<  ::psychlua::ModchartSprite >::cast(_gthis->target->sprite);
HXLINE(2153)					bool resetAnim = false;
HXLINE(2154)					bool removeButton;
HXDLIN(2154)					if (::hx::IsNotNull( targetSprite->animation->_curAnim )) {
HXLINE(2154)						removeButton = ::hx::IsEq( anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic),targetSprite->animation->_curAnim->name );
            					}
            					else {
HXLINE(2154)						removeButton = false;
            					}
HXDLIN(2154)					if (removeButton) {
HXLINE(2154)						resetAnim = true;
            					}
HXLINE(2156)					if (targetSprite->animOffsets->exists(( (::String)(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ))) {
HXLINE(2157)						targetSprite->animOffsets->remove(( (::String)(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ));
            					}
HXLINE(2159)					_gthis->target->animations->remove(anim);
HXLINE(2160)					targetSprite->animation->remove(( (::String)(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ));
HXLINE(2162)					bool removeButton1;
HXDLIN(2162)					if (resetAnim) {
HXLINE(2162)						removeButton1 = (_gthis->target->animations->length > 0);
            					}
            					else {
HXLINE(2162)						removeButton1 = false;
            					}
HXDLIN(2162)					if (removeButton1) {
HXLINE(2164)						_gthis->curAnim = ::flixel::math::FlxMath_obj::wrap(_gthis->curAnim,0,(_gthis->target->animations->length - 1));
HXLINE(2165)						_gthis->playAnim(( (::String)(_gthis->target->animations->__get(_gthis->curAnim)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true);
HXLINE(2166)						{
HXLINE(2166)							int _g_current = 0;
HXDLIN(2166)							::Array< ::Dynamic> _g_array = _gthis->animsTxtGroup->members;
HXDLIN(2166)							while((_g_current < _g_array->length)){
HXLINE(2166)								 ::flixel::text::FlxText _g_value = _g_array->__get(_g_current).StaticCast<  ::flixel::text::FlxText >();
HXDLIN(2166)								_g_current = (_g_current + 1);
HXDLIN(2166)								int _g_key = (_g_current - 1);
HXDLIN(2166)								int num = _g_key;
HXDLIN(2166)								 ::flixel::text::FlxText text = _g_value;
HXDLIN(2166)								{
HXLINE(2166)									text->set_color(-1);
HXDLIN(2166)									if ((num == _gthis->curAnim)) {
HXLINE(2166)										text->set_color(-16711936);
            									}
            								}
            							}
            						}
            					}
            					else {
HXLINE(2168)						if ((_gthis->target->animations->length < 1)) {
HXLINE(2169)							 ::flixel::animation::FlxAnimationController _this = _gthis->target->sprite->animation;
HXDLIN(2169)							 ::flixel::animation::FlxAnimation anim1 = null();
HXDLIN(2169)							if (::hx::IsInstanceNotEq( anim1,_this->_curAnim )) {
HXLINE(2169)								if (::hx::IsNotNull( _this->_curAnim )) {
HXLINE(2169)									_this->_curAnim->stop();
            								}
HXDLIN(2169)								if (::hx::IsNotNull( anim1 )) {
HXLINE(2169)									anim1->play(null(),null(),null());
            								}
            							}
HXDLIN(2169)							_this->_curAnim = anim1;
            						}
            					}
HXLINE(2171)					::haxe::Log_obj::trace((HX_("Removed animation: ",0a,26,5e,26) + _gthis->animationInputText->text),::hx::SourceInfo(HX_("source/states/editors/StageEditorState.hx",16,7c,21,9d),2171,HX_("states.editors.StageEditorAnimationSubstate",3e,56,38,7f),HX_("addAnimationsUI",c4,44,96,30)));
HXLINE(2172)					_gthis->reloadAnimList();
HXLINE(2173)					goto _hx_goto_7;
            				}
            			}
            			_hx_goto_7:;
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_9b82f77f5e054157_2065_addAnimationsUI)
HXDLIN(2065)		 ::states::editors::StageEditorAnimationSubstate _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE(2066)		 ::flixel::group::FlxTypedSpriteGroup tab_group = this->UI_animationbox->getTab(HX_("Animations",0f,39,cd,79))->menu;
HXLINE(2068)		this->animationInputText =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,15,85,80,HX_("",00,00,00,00),8);
HXLINE(2069)		this->animationNameInputText =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,this->animationInputText->x,(this->animationInputText->y + 35),150,HX_("",00,00,00,00),8);
HXLINE(2070)		this->animationIndicesInputText =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,this->animationNameInputText->x,(this->animationNameInputText->y + 40),250,HX_("",00,00,00,00),8);
HXLINE(2071)		this->animationFramerate =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,(this->animationInputText->x + 170),this->animationInputText->y,1,24,0,240,0,null(),null());
HXLINE(2072)		this->animationLoopCheckBox =  ::backend::ui::PsychUICheckBox_obj::__alloc( HX_CTX ,(this->animationNameInputText->x + 170),(this->animationNameInputText->y - ( (Float)(1) )),HX_("Should it Loop?",b3,ec,08,ad),100,null());
HXLINE(2074)		this->animationDropDown =  ::backend::ui::PsychUIDropDownMenu_obj::__alloc( HX_CTX ,( (Float)(15) ),(this->animationInputText->y - ( (Float)(55) )),::Array_obj< ::String >::fromData( _hx_array_data_7f38563e_14,1), ::Dynamic(new _hx_Closure_0(_gthis)),null());
HXLINE(2087)		this->mainAnimTxt =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,160,(this->animationDropDown->y - ( (Float)(18) )),0,HX_("Main Anim.: ",fc,45,e6,8a),null(),null());
HXLINE(2088)		 ::backend::ui::PsychUIButton initAnimButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,160,this->animationDropDown->y,HX_("Main Animation",5d,78,7e,49), ::Dynamic(new _hx_Closure_1(_gthis)),null(),null());
HXLINE(2095)		tab_group->add(this->mainAnimTxt).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2096)		tab_group->add(initAnimButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2098)		 ::backend::ui::PsychUIButton addUpdateButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,40,(this->animationIndicesInputText->y + 35),HX_("Add/Update",b7,cf,f4,ee), ::Dynamic(new _hx_Closure_2(_gthis)),null(),null());
HXLINE(2146)		 ::backend::ui::PsychUIButton removeButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,160,(this->animationIndicesInputText->y + 35),HX_("Remove",64,10,1d,39), ::Dynamic(new _hx_Closure_3(_gthis)),null(),null());
HXLINE(2178)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->animationDropDown->x,(this->animationDropDown->y - ( (Float)(18) )),0,HX_("Animations:",4b,b4,c4,19),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2179)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->animationInputText->x,(this->animationInputText->y - ( (Float)(18) )),0,HX_("Animation name:",53,2d,e4,9c),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2180)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->animationFramerate->x,(this->animationFramerate->y - ( (Float)(18) )),0,HX_("Framerate:",2d,fa,cd,2a),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2181)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->animationNameInputText->x,(this->animationNameInputText->y - ( (Float)(18) )),0,HX_("Animation Symbol Name/Tag:",38,f8,f7,f4),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2182)		tab_group->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,this->animationIndicesInputText->x,(this->animationIndicesInputText->y - ( (Float)(18) )),0,HX_("ADVANCED - Animation Indices:",60,cb,cb,a8),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2184)		tab_group->add(this->animationInputText).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2185)		tab_group->add(this->animationNameInputText).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2186)		tab_group->add(this->animationIndicesInputText).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2187)		tab_group->add(this->animationFramerate).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2188)		tab_group->add(this->animationLoopCheckBox).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2189)		tab_group->add(addUpdateButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2190)		tab_group->add(removeButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE(2191)		tab_group->add(this->animationDropDown).StaticCast<  ::flixel::FlxSprite >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(StageEditorAnimationSubstate_obj,addAnimationsUI,(void))

void StageEditorAnimationSubstate_obj::reloadAnimList(){
            	HX_GC_STACKFRAME(&_hx_pos_9b82f77f5e054157_2195_reloadAnimList)
HXLINE(2196)		if (::hx::IsNull( this->target->animations )) {
HXLINE(2196)			this->target->animations = ::Array_obj< ::Dynamic>::__new(0);
            		}
            		else {
HXLINE(2197)			if ((this->target->animations->length > 0)) {
HXLINE(2197)				this->playAnim(( (::String)(this->target->animations->__get(0)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true);
            			}
            		}
HXLINE(2198)		this->curAnim = 0;
HXLINE(2200)		{
HXLINE(2200)			 ::Dynamic filter = null();
HXDLIN(2200)			 ::flixel::group::FlxTypedGroupIterator text =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->animsTxtGroup->members,filter);
HXDLIN(2200)			while(text->hasNext()){
HXLINE(2200)				 ::flixel::text::FlxText text1 = text->next().StaticCast<  ::flixel::text::FlxText >();
HXLINE(2201)				text1->kill();
            			}
            		}
HXLINE(2203)		 ::psychlua::ModchartSprite spr = ::hx::TCast<  ::psychlua::ModchartSprite >::cast(this->target->sprite);
HXLINE(2204)		if ((this->target->animations->length > 0)) {
HXLINE(2206)			bool _hx_tmp;
HXDLIN(2206)			if (::hx::IsNotNull( this->target->firstAnimation )) {
HXLINE(2206)				_hx_tmp = !(this->target->sprite->animation->exists(this->target->firstAnimation));
            			}
            			else {
HXLINE(2206)				_hx_tmp = true;
            			}
HXDLIN(2206)			if (_hx_tmp) {
HXLINE(2207)				this->target->firstAnimation = ( (::String)(this->target->animations->__get(0)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) );
            			}
HXLINE(2209)			this->mainAnimTxt->set_text((HX_("Main Anim.: ",fc,45,e6,8a) + this->target->firstAnimation));
            		}
            		else {
HXLINE(2213)			this->target->firstAnimation = null();
HXLINE(2214)			this->mainAnimTxt->set_text(HX_("(No Main Animation)",95,fd,65,17));
            		}
HXLINE(2217)		{
HXLINE(2217)			int _g_current = 0;
HXDLIN(2217)			::Array< ::Dynamic> _g_array = this->target->animations;
HXDLIN(2217)			while((_g_current < _g_array->length)){
HXLINE(2217)				 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN(2217)				_g_current = (_g_current + 1);
HXDLIN(2217)				int _g_key = (_g_current - 1);
HXDLIN(2217)				int num = _g_key;
HXDLIN(2217)				 ::Dynamic anim = _g_value;
HXLINE(2218)				{
HXLINE(2219)					 ::flixel::text::FlxText text2 = this->animsTxtGroup->recycle(::hx::ClassOf< ::flixel::text::FlxText >(),null(),null(),null()).StaticCast<  ::flixel::text::FlxText >();
HXLINE(2220)					text2->set_x(( (Float)(10) ));
HXLINE(2221)					text2->set_y(( (Float)((32 + (20 * num))) ));
HXLINE(2222)					text2->set_fieldWidth(( (Float)(400) ));
HXLINE(2223)					text2->set_fieldHeight(( (Float)(20) ));
HXLINE(2224)					if (::hx::IsNotNull( anim->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic) )) {
HXLINE(2225)						::String _hx_tmp1 = ( (::String)(((HX_("",00,00,00,00) + anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) + HX_(": ",a6,32,00,00))) );
HXDLIN(2225)						text2->set_text((_hx_tmp1 + ::Std_obj::string(spr->animOffsets->get( ::Dynamic(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic))))));
            					}
            					else {
HXLINE(2227)						text2->set_text(( (::String)(((HX_("",00,00,00,00) + anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) + HX_(": No offsets",e7,98,3c,0c))) ));
            					}
HXLINE(2229)					text2->setFormat(null(),16,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_FAST_dyn(),-16777216,null());
HXLINE(2230)					{
HXLINE(2230)						 ::flixel::math::FlxBasePoint this1 = text2->scrollFactor;
HXDLIN(2230)						this1->set_x(( (Float)(0) ));
HXDLIN(2230)						this1->set_y(( (Float)(0) ));
            					}
HXLINE(2231)					text2->set_borderSize(( (Float)(1) ));
HXLINE(2232)					this->animsTxtGroup->add(text2).StaticCast<  ::flixel::text::FlxText >();
            				}
            			}
            		}
HXLINE(2234)		{
HXLINE(2234)			int _g_current1 = 0;
HXDLIN(2234)			::Array< ::Dynamic> _g_array1 = this->animsTxtGroup->members;
HXDLIN(2234)			while((_g_current1 < _g_array1->length)){
HXLINE(2234)				 ::flixel::text::FlxText _g_value1 = _g_array1->__get(_g_current1).StaticCast<  ::flixel::text::FlxText >();
HXDLIN(2234)				_g_current1 = (_g_current1 + 1);
HXDLIN(2234)				int _g_key1 = (_g_current1 - 1);
HXDLIN(2234)				int num1 = _g_key1;
HXDLIN(2234)				 ::flixel::text::FlxText text3 = _g_value1;
HXDLIN(2234)				{
HXLINE(2234)					text3->set_color(-1);
HXDLIN(2234)					if ((num1 == this->curAnim)) {
HXLINE(2234)						text3->set_color(-16711936);
            					}
            				}
            			}
            		}
HXLINE(2235)		this->reloadAnimationDropDown();
            	}


HX_DEFINE_DYNAMIC_FUNC0(StageEditorAnimationSubstate_obj,reloadAnimList,(void))

void StageEditorAnimationSubstate_obj::reloadAnimationDropDown(){
            	HX_STACKFRAME(&_hx_pos_9b82f77f5e054157_2238_reloadAnimationDropDown)
HXLINE(2239)		::Array< ::String > animList = ::Array_obj< ::String >::__new(0);
HXLINE(2240)		{
HXLINE(2240)			int _g = 0;
HXDLIN(2240)			::Array< ::Dynamic> _g1 = this->target->animations;
HXDLIN(2240)			while((_g < _g1->length)){
HXLINE(2240)				 ::Dynamic anim = _g1->__get(_g);
HXDLIN(2240)				_g = (_g + 1);
HXDLIN(2240)				animList->push( ::Dynamic(anim->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)));
            			}
            		}
HXLINE(2241)		if ((animList->length < 1)) {
HXLINE(2241)			animList->push(HX_("NO ANIMATIONS",6e,22,ac,1b));
            		}
HXLINE(2243)		this->animationDropDown->set_list(animList);
            	}


HX_DEFINE_DYNAMIC_FUNC0(StageEditorAnimationSubstate_obj,reloadAnimationDropDown,(void))

void StageEditorAnimationSubstate_obj::updateTextColors(){
            	HX_STACKFRAME(&_hx_pos_9b82f77f5e054157_2248_updateTextColors)
HXDLIN(2248)		int _g_current = 0;
HXDLIN(2248)		::Array< ::Dynamic> _g_array = this->animsTxtGroup->members;
HXDLIN(2248)		while((_g_current < _g_array->length)){
HXDLIN(2248)			 ::flixel::text::FlxText _g_value = _g_array->__get(_g_current).StaticCast<  ::flixel::text::FlxText >();
HXDLIN(2248)			_g_current = (_g_current + 1);
HXDLIN(2248)			int _g_key = (_g_current - 1);
HXDLIN(2248)			int num = _g_key;
HXDLIN(2248)			 ::flixel::text::FlxText text = _g_value;
HXLINE(2249)			{
HXLINE(2250)				text->set_color(-1);
HXLINE(2251)				if ((num == this->curAnim)) {
HXLINE(2251)					text->set_color(-16711936);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(StageEditorAnimationSubstate_obj,updateTextColors,(void))

void StageEditorAnimationSubstate_obj::playAnim(::String name,::hx::Null< bool >  __o_force){
            		bool force = __o_force.Default(false);
            	HX_STACKFRAME(&_hx_pos_9b82f77f5e054157_2256_playAnim)
HXLINE(2257)		 ::psychlua::ModchartSprite spr = ::hx::TCast<  ::psychlua::ModchartSprite >::cast(this->target->sprite);
HXLINE(2258)		spr->playAnim(name,force,null(),null());
HXLINE(2259)		if (!(spr->animOffsets->exists(name))) {
HXLINE(2259)			spr->updateHitbox();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(StageEditorAnimationSubstate_obj,playAnim,(void))

void StageEditorAnimationSubstate_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_9b82f77f5e054157_2269_update)
HXLINE(2270)		this->super::update(elapsed);
HXLINE(2272)		if (::hx::IsNotNull( ::backend::ui::PsychUIInputText_obj::focusOn )) {
HXLINE(2272)			return;
            		}
HXLINE(2275)		if ((this->target->animations->length > 1)) {
HXLINE(2277)			bool changedAnim = false;
HXLINE(2278)			bool _hx_tmp;
HXDLIN(2278)			 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(2278)			if (_this->keyManager->checkStatusUnsafe(87,_this->status)) {
HXLINE(2278)				changedAnim = true;
HXDLIN(2278)				_hx_tmp = changedAnim;
            			}
            			else {
HXLINE(2278)				_hx_tmp = false;
            			}
HXDLIN(2278)			if (_hx_tmp) {
HXLINE(2278)				this->curAnim--;
            			}
            			else {
HXLINE(2279)				bool _hx_tmp1;
HXDLIN(2279)				 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(2279)				if (_this1->keyManager->checkStatusUnsafe(83,_this1->status)) {
HXLINE(2279)					changedAnim = true;
HXDLIN(2279)					_hx_tmp1 = changedAnim;
            				}
            				else {
HXLINE(2279)					_hx_tmp1 = false;
            				}
HXDLIN(2279)				if (_hx_tmp1) {
HXLINE(2279)					this->curAnim++;
            				}
            				else {
HXLINE(2280)					 ::flixel::input::keyboard::FlxKeyList _this2 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(2280)					if (_this2->keyManager->checkStatusUnsafe(32,_this2->status)) {
HXLINE(2280)						changedAnim = true;
            					}
            				}
            			}
HXLINE(2282)			if (changedAnim) {
HXLINE(2284)				this->curAnim = ::flixel::math::FlxMath_obj::wrap(this->curAnim,0,(this->target->animations->length - 1));
HXLINE(2285)				this->playAnim(( (::String)(this->target->animations->__get(this->curAnim)->__Field(HX_("anim",11,86,71,40),::hx::paccDynamic)) ),true);
HXLINE(2286)				{
HXLINE(2286)					int _g_current = 0;
HXDLIN(2286)					::Array< ::Dynamic> _g_array = this->animsTxtGroup->members;
HXDLIN(2286)					while((_g_current < _g_array->length)){
HXLINE(2286)						 ::flixel::text::FlxText _g_value = _g_array->__get(_g_current).StaticCast<  ::flixel::text::FlxText >();
HXDLIN(2286)						_g_current = (_g_current + 1);
HXDLIN(2286)						int _g_key = (_g_current - 1);
HXDLIN(2286)						int num = _g_key;
HXDLIN(2286)						 ::flixel::text::FlxText text = _g_value;
HXDLIN(2286)						{
HXLINE(2286)							text->set_color(-1);
HXDLIN(2286)							if ((num == this->curAnim)) {
HXLINE(2286)								text->set_color(-16711936);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(2290)		Float shiftMult = ( (Float)(1) );
HXLINE(2291)		Float ctrlMult = ( (Float)(1) );
HXLINE(2292)		Float shiftMultBig = ( (Float)(1) );
HXLINE(2293)		 ::flixel::input::keyboard::FlxKeyList _this3 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2293)		if (_this3->keyManager->checkStatusUnsafe(16,_this3->status)) {
HXLINE(2295)			shiftMult = ( (Float)(4) );
HXLINE(2296)			shiftMultBig = ( (Float)(10) );
            		}
HXLINE(2298)		 ::flixel::input::keyboard::FlxKeyList _this4 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2298)		if (_this4->keyManager->checkStatusUnsafe(17,_this4->status)) {
HXLINE(2298)			ctrlMult = ((Float)0.25);
            		}
HXLINE(2301)		if (::hx::IsNotNull( this->target->sprite->animation->_curAnim )) {
HXLINE(2303)			 ::psychlua::ModchartSprite spr = ::hx::TCast<  ::psychlua::ModchartSprite >::cast(this->target->sprite);
HXLINE(2304)			::String anim = spr->animation->_curAnim->name;
HXLINE(2305)			bool changedOffset = false;
HXLINE(2306)			 ::flixel::input::keyboard::FlxKeyList _this5 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(2306)			bool moveKeysP = _this5->keyManager->checkStatusUnsafe(37,_this5->status);
HXDLIN(2306)			 ::flixel::input::keyboard::FlxKeyList _this6 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(2306)			bool moveKeysP1 = _this6->keyManager->checkStatusUnsafe(39,_this6->status);
HXDLIN(2306)			 ::flixel::input::keyboard::FlxKeyList _this7 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(2306)			bool moveKeysP2 = _this7->keyManager->checkStatusUnsafe(38,_this7->status);
HXDLIN(2306)			 ::flixel::input::keyboard::FlxKeyList _this8 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(2306)			::Array< bool > moveKeysP3 = ::Array_obj< bool >::__new(4)->init(0,moveKeysP)->init(1,moveKeysP1)->init(2,moveKeysP2)->init(3,_this8->keyManager->checkStatusUnsafe(40,_this8->status));
HXLINE(2307)			 ::flixel::input::keyboard::FlxKeyList _this9 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2307)			bool moveKeys = _this9->keyManager->checkStatusUnsafe(37,_this9->status);
HXDLIN(2307)			 ::flixel::input::keyboard::FlxKeyList _this10 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2307)			bool moveKeys1 = _this10->keyManager->checkStatusUnsafe(39,_this10->status);
HXDLIN(2307)			 ::flixel::input::keyboard::FlxKeyList _this11 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2307)			bool moveKeys2 = _this11->keyManager->checkStatusUnsafe(38,_this11->status);
HXDLIN(2307)			 ::flixel::input::keyboard::FlxKeyList _this12 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2307)			::Array< bool > moveKeys3 = ::Array_obj< bool >::__new(4)->init(0,moveKeys)->init(1,moveKeys1)->init(2,moveKeys2)->init(3,_this12->keyManager->checkStatusUnsafe(40,_this12->status));
HXLINE(2308)			if (moveKeysP3->contains(true)) {
HXLINE(2310)				if (::hx::IsNotNull( spr->animOffsets->get(anim) )) {
HXLINE(2312)					{
HXLINE(2312)						int x;
HXDLIN(2312)						if (moveKeysP3->__get(0)) {
HXLINE(2312)							x = 1;
            						}
            						else {
HXLINE(2312)							x = 0;
            						}
HXDLIN(2312)						int x1;
HXDLIN(2312)						if (moveKeysP3->__get(1)) {
HXLINE(2312)							x1 = 1;
            						}
            						else {
HXLINE(2312)							x1 = 0;
            						}
HXDLIN(2312)						spr->offset->set_x((spr->offset->x + (( (Float)((x - x1)) ) * shiftMultBig)));
            					}
HXLINE(2313)					{
HXLINE(2313)						int y;
HXDLIN(2313)						if (moveKeysP3->__get(2)) {
HXLINE(2313)							y = 1;
            						}
            						else {
HXLINE(2313)							y = 0;
            						}
HXDLIN(2313)						int y1;
HXDLIN(2313)						if (moveKeysP3->__get(3)) {
HXLINE(2313)							y1 = 1;
            						}
            						else {
HXLINE(2313)							y1 = 0;
            						}
HXDLIN(2313)						spr->offset->set_y((spr->offset->y + (( (Float)((y - y1)) ) * shiftMultBig)));
            					}
            				}
            				else {
HXLINE(2315)					 ::flixel::math::FlxBasePoint this1 = spr->offset;
HXDLIN(2315)					this1->set_x(spr->offset->set_y(( (Float)(0) )));
            				}
HXLINE(2316)				changedOffset = true;
            			}
HXLINE(2319)			if (moveKeys3->contains(true)) {
HXLINE(2321)				 ::states::editors::StageEditorAnimationSubstate _hx_tmp2 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN(2321)				_hx_tmp2->holdingArrowsTime = (_hx_tmp2->holdingArrowsTime + elapsed);
HXLINE(2322)				if ((this->holdingArrowsTime > ((Float)0.6))) {
HXLINE(2324)					 ::states::editors::StageEditorAnimationSubstate _hx_tmp3 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN(2324)					_hx_tmp3->holdingArrowsElapsed = (_hx_tmp3->holdingArrowsElapsed + elapsed);
HXLINE(2325)					while((this->holdingArrowsElapsed > ((Float)0.016666666666666666))){
HXLINE(2327)						if (::hx::IsNotNull( spr->animOffsets->get(anim) )) {
HXLINE(2329)							{
HXLINE(2329)								int x2;
HXDLIN(2329)								if (moveKeys3->__get(0)) {
HXLINE(2329)									x2 = 1;
            								}
            								else {
HXLINE(2329)									x2 = 0;
            								}
HXDLIN(2329)								int x3;
HXDLIN(2329)								if (moveKeys3->__get(1)) {
HXLINE(2329)									x3 = 1;
            								}
            								else {
HXLINE(2329)									x3 = 0;
            								}
HXDLIN(2329)								spr->offset->set_x((spr->offset->x + (( (Float)((x2 - x3)) ) * shiftMultBig)));
            							}
HXLINE(2330)							{
HXLINE(2330)								int y2;
HXDLIN(2330)								if (moveKeys3->__get(2)) {
HXLINE(2330)									y2 = 1;
            								}
            								else {
HXLINE(2330)									y2 = 0;
            								}
HXDLIN(2330)								int y3;
HXDLIN(2330)								if (moveKeys3->__get(3)) {
HXLINE(2330)									y3 = 1;
            								}
            								else {
HXLINE(2330)									y3 = 0;
            								}
HXDLIN(2330)								spr->offset->set_y((spr->offset->y + (( (Float)((y2 - y3)) ) * shiftMultBig)));
            							}
            						}
            						else {
HXLINE(2332)							 ::flixel::math::FlxBasePoint this2 = spr->offset;
HXDLIN(2332)							this2->set_x(spr->offset->set_y(( (Float)(0) )));
            						}
HXLINE(2333)						 ::states::editors::StageEditorAnimationSubstate _hx_tmp4 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN(2333)						_hx_tmp4->holdingArrowsElapsed = (_hx_tmp4->holdingArrowsElapsed - ((Float)0.016666666666666666));
HXLINE(2334)						changedOffset = true;
            					}
            				}
            			}
            			else {
HXLINE(2338)				this->holdingArrowsTime = ( (Float)(0) );
            			}
HXLINE(2340)			bool _hx_tmp5;
HXDLIN(2340)			 ::flixel::input::mouse::FlxMouseButton _this13 = ::flixel::FlxG_obj::mouse->_rightButton;
HXDLIN(2340)			bool _hx_tmp6;
HXDLIN(2340)			if ((_this13->current != 1)) {
HXLINE(2340)				_hx_tmp6 = (_this13->current == 2);
            			}
            			else {
HXLINE(2340)				_hx_tmp6 = true;
            			}
HXDLIN(2340)			if (_hx_tmp6) {
HXLINE(2340)				 ::flixel::input::mouse::FlxMouse _this14 = ::flixel::FlxG_obj::mouse;
HXDLIN(2340)				if (((_this14->screenX - _this14->_prevScreenX) == 0)) {
HXLINE(2340)					 ::flixel::input::mouse::FlxMouse _this15 = ::flixel::FlxG_obj::mouse;
HXDLIN(2340)					_hx_tmp5 = ((_this15->screenY - _this15->_prevScreenY) != 0);
            				}
            				else {
HXLINE(2340)					_hx_tmp5 = true;
            				}
            			}
            			else {
HXLINE(2340)				_hx_tmp5 = false;
            			}
HXDLIN(2340)			if (_hx_tmp5) {
HXLINE(2342)				{
HXLINE(2342)					 ::flixel::input::mouse::FlxMouse _this16 = ::flixel::FlxG_obj::mouse;
HXDLIN(2342)					spr->offset->set_x((spr->offset->x - ( (Float)((_this16->screenX - _this16->_prevScreenX)) )));
            				}
HXLINE(2343)				{
HXLINE(2343)					 ::flixel::input::mouse::FlxMouse _this17 = ::flixel::FlxG_obj::mouse;
HXDLIN(2343)					spr->offset->set_y((spr->offset->y - ( (Float)((_this17->screenY - _this17->_prevScreenY)) )));
            				}
HXLINE(2344)				changedOffset = true;
            			}
HXLINE(2347)			bool _hx_tmp7;
HXDLIN(2347)			 ::flixel::input::keyboard::FlxKeyList _this18 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(2347)			if (_this18->keyManager->checkStatusUnsafe(82,_this18->status)) {
HXLINE(2347)				 ::flixel::input::keyboard::FlxKeyList _this19 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2347)				_hx_tmp7 = _this19->keyManager->checkStatusUnsafe(17,_this19->status);
            			}
            			else {
HXLINE(2347)				_hx_tmp7 = false;
            			}
HXDLIN(2347)			if (_hx_tmp7) {
HXLINE(2349)				this->target->animations->__get(this->curAnim)->__SetField(HX_("offsets",80,09,65,d7),null(),::hx::paccDynamic);
HXLINE(2350)				spr->animOffsets->remove(anim);
HXLINE(2351)				spr->updateHitbox();
HXLINE(2352)				Dynamic( this->animsTxtGroup->members->__get(this->curAnim)).StaticCast<  ::flixel::text::FlxText >()->set_text(((HX_("",00,00,00,00) + anim) + HX_(": No offsets",e7,98,3c,0c)));
            			}
HXLINE(2355)			if (changedOffset) {
HXLINE(2357)				int offX = ::Math_obj::round(spr->offset->x);
HXLINE(2358)				int offY = ::Math_obj::round(spr->offset->y);
HXLINE(2360)				spr->addOffset(anim,( (Float)(offX) ),( (Float)(offY) ));
HXLINE(2361)				this->target->animations->__get(this->curAnim)->__SetField(HX_("offsets",80,09,65,d7),::Array_obj< int >::__new(2)->init(0,offX)->init(1,offY),::hx::paccDynamic);
HXLINE(2362)				 ::flixel::text::FlxText _hx_tmp8 = Dynamic( this->animsTxtGroup->members->__get(this->curAnim)).StaticCast<  ::flixel::text::FlxText >();
HXDLIN(2362)				_hx_tmp8->set_text((((HX_("",00,00,00,00) + anim) + HX_(": ",a6,32,00,00)) + ::Std_obj::string(spr->animOffsets->get(anim))));
            			}
            		}
            		else {
HXLINE(2367)			this->holdingArrowsTime = ( (Float)(0) );
HXLINE(2368)			this->holdingArrowsElapsed = ( (Float)(0) );
            		}
HXLINE(2372)		Float camX = ( (Float)(0) );
HXLINE(2373)		Float camY = ( (Float)(0) );
HXLINE(2374)		Float camMove = (((elapsed * ( (Float)(500) )) * shiftMult) * ctrlMult);
HXLINE(2375)		 ::flixel::input::keyboard::FlxKeyList _this20 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2375)		if (_this20->keyManager->checkStatusUnsafe(74,_this20->status)) {
HXLINE(2375)			camX = (camX - camMove);
            		}
HXLINE(2376)		 ::flixel::input::keyboard::FlxKeyList _this21 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2376)		if (_this21->keyManager->checkStatusUnsafe(75,_this21->status)) {
HXLINE(2376)			camY = (camY + camMove);
            		}
HXLINE(2377)		 ::flixel::input::keyboard::FlxKeyList _this22 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2377)		if (_this22->keyManager->checkStatusUnsafe(76,_this22->status)) {
HXLINE(2377)			camX = (camX + camMove);
            		}
HXLINE(2378)		 ::flixel::input::keyboard::FlxKeyList _this23 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2378)		if (_this23->keyManager->checkStatusUnsafe(73,_this23->status)) {
HXLINE(2378)			camY = (camY - camMove);
            		}
HXLINE(2380)		bool _hx_tmp9;
HXDLIN(2380)		if ((camX == 0)) {
HXLINE(2380)			_hx_tmp9 = (camY != 0);
            		}
            		else {
HXLINE(2380)			_hx_tmp9 = true;
            		}
HXDLIN(2380)		if (_hx_tmp9) {
HXLINE(2382)			 ::flixel::FlxCamera fh = ::flixel::FlxG_obj::camera;
HXDLIN(2382)			fh->scroll->set_x((fh->scroll->x + camX));
HXLINE(2383)			 ::flixel::FlxCamera fh1 = ::flixel::FlxG_obj::camera;
HXDLIN(2383)			fh1->scroll->set_y((fh1->scroll->y + camY));
            		}
HXLINE(2386)		Float lastZoom = ::flixel::FlxG_obj::camera->zoom;
HXLINE(2387)		bool _hx_tmp10;
HXDLIN(2387)		 ::flixel::input::keyboard::FlxKeyList _this24 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(2387)		if (_this24->keyManager->checkStatusUnsafe(82,_this24->status)) {
HXLINE(2387)			 ::flixel::input::keyboard::FlxKeyList _this25 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2387)			_hx_tmp10 = !(_this25->keyManager->checkStatusUnsafe(17,_this25->status));
            		}
            		else {
HXLINE(2387)			_hx_tmp10 = false;
            		}
HXDLIN(2387)		if (_hx_tmp10) {
HXLINE(2388)			::flixel::FlxG_obj::camera->set_zoom(((Float)0.5));
            		}
            		else {
HXLINE(2389)			bool _hx_tmp11;
HXDLIN(2389)			 ::flixel::input::keyboard::FlxKeyList _this26 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2389)			if (_this26->keyManager->checkStatusUnsafe(69,_this26->status)) {
HXLINE(2389)				_hx_tmp11 = (::flixel::FlxG_obj::camera->zoom < this->maxZoom);
            			}
            			else {
HXLINE(2389)				_hx_tmp11 = false;
            			}
HXDLIN(2389)			if (_hx_tmp11) {
HXLINE(2390)				::flixel::FlxG_obj::camera->set_zoom(::Math_obj::min(( (Float)(this->maxZoom) ),(::flixel::FlxG_obj::camera->zoom + (((elapsed * ::flixel::FlxG_obj::camera->zoom) * shiftMult) * ctrlMult))));
            			}
            			else {
HXLINE(2391)				bool _hx_tmp12;
HXDLIN(2391)				 ::flixel::input::keyboard::FlxKeyList _this27 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN(2391)				if (_this27->keyManager->checkStatusUnsafe(81,_this27->status)) {
HXLINE(2391)					_hx_tmp12 = (::flixel::FlxG_obj::camera->zoom > this->minZoom);
            				}
            				else {
HXLINE(2391)					_hx_tmp12 = false;
            				}
HXDLIN(2391)				if (_hx_tmp12) {
HXLINE(2392)					::flixel::FlxG_obj::camera->set_zoom(::Math_obj::max(this->minZoom,(::flixel::FlxG_obj::camera->zoom - (((elapsed * ::flixel::FlxG_obj::camera->zoom) * shiftMult) * ctrlMult))));
            				}
            			}
            		}
HXLINE(2394)		 ::flixel::input::keyboard::FlxKeyList _this28 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(2394)		if (_this28->keyManager->checkStatusUnsafe(27,_this28->status)) {
HXLINE(2396)			this->persistentDraw = true;
HXLINE(2397)			this->close();
            		}
            	}



::hx::ObjectPtr< StageEditorAnimationSubstate_obj > StageEditorAnimationSubstate_obj::__new() {
	::hx::ObjectPtr< StageEditorAnimationSubstate_obj > __this = new StageEditorAnimationSubstate_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< StageEditorAnimationSubstate_obj > StageEditorAnimationSubstate_obj::__alloc(::hx::Ctx *_hx_ctx) {
	StageEditorAnimationSubstate_obj *__this = (StageEditorAnimationSubstate_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(StageEditorAnimationSubstate_obj), true, "states.editors.StageEditorAnimationSubstate"));
	*(void **)__this = StageEditorAnimationSubstate_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

StageEditorAnimationSubstate_obj::StageEditorAnimationSubstate_obj()
{
}

void StageEditorAnimationSubstate_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(StageEditorAnimationSubstate);
	HX_MARK_MEMBER_NAME(bg,"bg");
	HX_MARK_MEMBER_NAME(originalZoom,"originalZoom");
	HX_MARK_MEMBER_NAME(originalCamPoint,"originalCamPoint");
	HX_MARK_MEMBER_NAME(originalPosition,"originalPosition");
	HX_MARK_MEMBER_NAME(originalCamTarget,"originalCamTarget");
	HX_MARK_MEMBER_NAME(originalAlpha,"originalAlpha");
	HX_MARK_MEMBER_NAME(target,"target");
	HX_MARK_MEMBER_NAME(curAnim,"curAnim");
	HX_MARK_MEMBER_NAME(animsTxtGroup,"animsTxtGroup");
	HX_MARK_MEMBER_NAME(UI_animationbox,"UI_animationbox");
	HX_MARK_MEMBER_NAME(camHUD,"camHUD");
	HX_MARK_MEMBER_NAME(animationDropDown,"animationDropDown");
	HX_MARK_MEMBER_NAME(animationInputText,"animationInputText");
	HX_MARK_MEMBER_NAME(animationNameInputText,"animationNameInputText");
	HX_MARK_MEMBER_NAME(animationIndicesInputText,"animationIndicesInputText");
	HX_MARK_MEMBER_NAME(animationFramerate,"animationFramerate");
	HX_MARK_MEMBER_NAME(animationLoopCheckBox,"animationLoopCheckBox");
	HX_MARK_MEMBER_NAME(mainAnimTxt,"mainAnimTxt");
	HX_MARK_MEMBER_NAME(minZoom,"minZoom");
	HX_MARK_MEMBER_NAME(maxZoom,"maxZoom");
	HX_MARK_MEMBER_NAME(holdingArrowsTime,"holdingArrowsTime");
	HX_MARK_MEMBER_NAME(holdingArrowsElapsed,"holdingArrowsElapsed");
	HX_MARK_MEMBER_NAME(holdingFrameTime,"holdingFrameTime");
	HX_MARK_MEMBER_NAME(holdingFrameElapsed,"holdingFrameElapsed");
	 ::flixel::FlxSubState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void StageEditorAnimationSubstate_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(bg,"bg");
	HX_VISIT_MEMBER_NAME(originalZoom,"originalZoom");
	HX_VISIT_MEMBER_NAME(originalCamPoint,"originalCamPoint");
	HX_VISIT_MEMBER_NAME(originalPosition,"originalPosition");
	HX_VISIT_MEMBER_NAME(originalCamTarget,"originalCamTarget");
	HX_VISIT_MEMBER_NAME(originalAlpha,"originalAlpha");
	HX_VISIT_MEMBER_NAME(target,"target");
	HX_VISIT_MEMBER_NAME(curAnim,"curAnim");
	HX_VISIT_MEMBER_NAME(animsTxtGroup,"animsTxtGroup");
	HX_VISIT_MEMBER_NAME(UI_animationbox,"UI_animationbox");
	HX_VISIT_MEMBER_NAME(camHUD,"camHUD");
	HX_VISIT_MEMBER_NAME(animationDropDown,"animationDropDown");
	HX_VISIT_MEMBER_NAME(animationInputText,"animationInputText");
	HX_VISIT_MEMBER_NAME(animationNameInputText,"animationNameInputText");
	HX_VISIT_MEMBER_NAME(animationIndicesInputText,"animationIndicesInputText");
	HX_VISIT_MEMBER_NAME(animationFramerate,"animationFramerate");
	HX_VISIT_MEMBER_NAME(animationLoopCheckBox,"animationLoopCheckBox");
	HX_VISIT_MEMBER_NAME(mainAnimTxt,"mainAnimTxt");
	HX_VISIT_MEMBER_NAME(minZoom,"minZoom");
	HX_VISIT_MEMBER_NAME(maxZoom,"maxZoom");
	HX_VISIT_MEMBER_NAME(holdingArrowsTime,"holdingArrowsTime");
	HX_VISIT_MEMBER_NAME(holdingArrowsElapsed,"holdingArrowsElapsed");
	HX_VISIT_MEMBER_NAME(holdingFrameTime,"holdingFrameTime");
	HX_VISIT_MEMBER_NAME(holdingFrameElapsed,"holdingFrameElapsed");
	 ::flixel::FlxSubState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val StageEditorAnimationSubstate_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"bg") ) { return ::hx::Val( bg ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"target") ) { return ::hx::Val( target ); }
		if (HX_FIELD_EQ(inName,"camHUD") ) { return ::hx::Val( camHUD ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"curAnim") ) { return ::hx::Val( curAnim ); }
		if (HX_FIELD_EQ(inName,"minZoom") ) { return ::hx::Val( minZoom ); }
		if (HX_FIELD_EQ(inName,"maxZoom") ) { return ::hx::Val( maxZoom ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"playAnim") ) { return ::hx::Val( playAnim_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"mainAnimTxt") ) { return ::hx::Val( mainAnimTxt ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"originalZoom") ) { return ::hx::Val( originalZoom ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"originalAlpha") ) { return ::hx::Val( originalAlpha ); }
		if (HX_FIELD_EQ(inName,"animsTxtGroup") ) { return ::hx::Val( animsTxtGroup ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"reloadAnimList") ) { return ::hx::Val( reloadAnimList_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"UI_animationbox") ) { return ::hx::Val( UI_animationbox ); }
		if (HX_FIELD_EQ(inName,"addAnimationsUI") ) { return ::hx::Val( addAnimationsUI_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"originalCamPoint") ) { return ::hx::Val( originalCamPoint ); }
		if (HX_FIELD_EQ(inName,"originalPosition") ) { return ::hx::Val( originalPosition ); }
		if (HX_FIELD_EQ(inName,"updateTextColors") ) { return ::hx::Val( updateTextColors_dyn() ); }
		if (HX_FIELD_EQ(inName,"holdingFrameTime") ) { return ::hx::Val( holdingFrameTime ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"originalCamTarget") ) { return ::hx::Val( originalCamTarget ); }
		if (HX_FIELD_EQ(inName,"animationDropDown") ) { return ::hx::Val( animationDropDown ); }
		if (HX_FIELD_EQ(inName,"holdingArrowsTime") ) { return ::hx::Val( holdingArrowsTime ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"animationInputText") ) { return ::hx::Val( animationInputText ); }
		if (HX_FIELD_EQ(inName,"animationFramerate") ) { return ::hx::Val( animationFramerate ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"holdingFrameElapsed") ) { return ::hx::Val( holdingFrameElapsed ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"holdingArrowsElapsed") ) { return ::hx::Val( holdingArrowsElapsed ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"animationLoopCheckBox") ) { return ::hx::Val( animationLoopCheckBox ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"animationNameInputText") ) { return ::hx::Val( animationNameInputText ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"reloadAnimationDropDown") ) { return ::hx::Val( reloadAnimationDropDown_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"animationIndicesInputText") ) { return ::hx::Val( animationIndicesInputText ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val StageEditorAnimationSubstate_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"bg") ) { bg=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"target") ) { target=inValue.Cast<  ::states::editors::StageEditorMetaSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"camHUD") ) { camHUD=inValue.Cast<  ::flixel::FlxCamera >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"curAnim") ) { curAnim=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"minZoom") ) { minZoom=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxZoom") ) { maxZoom=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"mainAnimTxt") ) { mainAnimTxt=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"originalZoom") ) { originalZoom=inValue.Cast< Float >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"originalAlpha") ) { originalAlpha=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"animsTxtGroup") ) { animsTxtGroup=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"UI_animationbox") ) { UI_animationbox=inValue.Cast<  ::backend::ui::PsychUIBox >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"originalCamPoint") ) { originalCamPoint=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"originalPosition") ) { originalPosition=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdingFrameTime") ) { holdingFrameTime=inValue.Cast< Float >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"originalCamTarget") ) { originalCamTarget=inValue.Cast<  ::flixel::FlxObject >(); return inValue; }
		if (HX_FIELD_EQ(inName,"animationDropDown") ) { animationDropDown=inValue.Cast<  ::backend::ui::PsychUIDropDownMenu >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdingArrowsTime") ) { holdingArrowsTime=inValue.Cast< Float >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"animationInputText") ) { animationInputText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"animationFramerate") ) { animationFramerate=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"holdingFrameElapsed") ) { holdingFrameElapsed=inValue.Cast< Float >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"holdingArrowsElapsed") ) { holdingArrowsElapsed=inValue.Cast< Float >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"animationLoopCheckBox") ) { animationLoopCheckBox=inValue.Cast<  ::backend::ui::PsychUICheckBox >(); return inValue; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"animationNameInputText") ) { animationNameInputText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"animationIndicesInputText") ) { animationIndicesInputText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void StageEditorAnimationSubstate_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("bg",c5,55,00,00));
	outFields->push(HX_("originalZoom",04,00,59,2a));
	outFields->push(HX_("originalCamPoint",32,c3,17,79));
	outFields->push(HX_("originalPosition",1a,ca,4a,75));
	outFields->push(HX_("originalCamTarget",2f,ea,71,0b));
	outFields->push(HX_("originalAlpha",4d,9d,87,7c));
	outFields->push(HX_("target",51,f3,ec,86));
	outFields->push(HX_("curAnim",b1,f7,86,ab));
	outFields->push(HX_("animsTxtGroup",11,f6,b6,fc));
	outFields->push(HX_("UI_animationbox",92,6d,a1,87));
	outFields->push(HX_("camHUD",e8,2b,76,b7));
	outFields->push(HX_("animationDropDown",55,ef,bb,0d));
	outFields->push(HX_("animationInputText",33,7a,56,eb));
	outFields->push(HX_("animationNameInputText",68,24,12,3c));
	outFields->push(HX_("animationIndicesInputText",d4,98,c7,74));
	outFields->push(HX_("animationFramerate",e9,d5,7d,25));
	outFields->push(HX_("animationLoopCheckBox",cb,a1,1d,ab));
	outFields->push(HX_("mainAnimTxt",a6,59,30,1b));
	outFields->push(HX_("minZoom",c5,11,02,42));
	outFields->push(HX_("maxZoom",d7,fb,28,d1));
	outFields->push(HX_("holdingArrowsTime",9a,f6,8d,72));
	outFields->push(HX_("holdingArrowsElapsed",cf,c3,f8,c5));
	outFields->push(HX_("holdingFrameTime",57,dd,57,76));
	outFields->push(HX_("holdingFrameElapsed",32,f1,cf,09));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo StageEditorAnimationSubstate_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(StageEditorAnimationSubstate_obj,bg),HX_("bg",c5,55,00,00)},
	{::hx::fsFloat,(int)offsetof(StageEditorAnimationSubstate_obj,originalZoom),HX_("originalZoom",04,00,59,2a)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(StageEditorAnimationSubstate_obj,originalCamPoint),HX_("originalCamPoint",32,c3,17,79)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(StageEditorAnimationSubstate_obj,originalPosition),HX_("originalPosition",1a,ca,4a,75)},
	{::hx::fsObject /*  ::flixel::FlxObject */ ,(int)offsetof(StageEditorAnimationSubstate_obj,originalCamTarget),HX_("originalCamTarget",2f,ea,71,0b)},
	{::hx::fsFloat,(int)offsetof(StageEditorAnimationSubstate_obj,originalAlpha),HX_("originalAlpha",4d,9d,87,7c)},
	{::hx::fsObject /*  ::states::editors::StageEditorMetaSprite */ ,(int)offsetof(StageEditorAnimationSubstate_obj,target),HX_("target",51,f3,ec,86)},
	{::hx::fsInt,(int)offsetof(StageEditorAnimationSubstate_obj,curAnim),HX_("curAnim",b1,f7,86,ab)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(StageEditorAnimationSubstate_obj,animsTxtGroup),HX_("animsTxtGroup",11,f6,b6,fc)},
	{::hx::fsObject /*  ::backend::ui::PsychUIBox */ ,(int)offsetof(StageEditorAnimationSubstate_obj,UI_animationbox),HX_("UI_animationbox",92,6d,a1,87)},
	{::hx::fsObject /*  ::flixel::FlxCamera */ ,(int)offsetof(StageEditorAnimationSubstate_obj,camHUD),HX_("camHUD",e8,2b,76,b7)},
	{::hx::fsObject /*  ::backend::ui::PsychUIDropDownMenu */ ,(int)offsetof(StageEditorAnimationSubstate_obj,animationDropDown),HX_("animationDropDown",55,ef,bb,0d)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(StageEditorAnimationSubstate_obj,animationInputText),HX_("animationInputText",33,7a,56,eb)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(StageEditorAnimationSubstate_obj,animationNameInputText),HX_("animationNameInputText",68,24,12,3c)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(StageEditorAnimationSubstate_obj,animationIndicesInputText),HX_("animationIndicesInputText",d4,98,c7,74)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(StageEditorAnimationSubstate_obj,animationFramerate),HX_("animationFramerate",e9,d5,7d,25)},
	{::hx::fsObject /*  ::backend::ui::PsychUICheckBox */ ,(int)offsetof(StageEditorAnimationSubstate_obj,animationLoopCheckBox),HX_("animationLoopCheckBox",cb,a1,1d,ab)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(StageEditorAnimationSubstate_obj,mainAnimTxt),HX_("mainAnimTxt",a6,59,30,1b)},
	{::hx::fsFloat,(int)offsetof(StageEditorAnimationSubstate_obj,minZoom),HX_("minZoom",c5,11,02,42)},
	{::hx::fsInt,(int)offsetof(StageEditorAnimationSubstate_obj,maxZoom),HX_("maxZoom",d7,fb,28,d1)},
	{::hx::fsFloat,(int)offsetof(StageEditorAnimationSubstate_obj,holdingArrowsTime),HX_("holdingArrowsTime",9a,f6,8d,72)},
	{::hx::fsFloat,(int)offsetof(StageEditorAnimationSubstate_obj,holdingArrowsElapsed),HX_("holdingArrowsElapsed",cf,c3,f8,c5)},
	{::hx::fsFloat,(int)offsetof(StageEditorAnimationSubstate_obj,holdingFrameTime),HX_("holdingFrameTime",57,dd,57,76)},
	{::hx::fsFloat,(int)offsetof(StageEditorAnimationSubstate_obj,holdingFrameElapsed),HX_("holdingFrameElapsed",32,f1,cf,09)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *StageEditorAnimationSubstate_obj_sStaticStorageInfo = 0;
#endif

static ::String StageEditorAnimationSubstate_obj_sMemberFields[] = {
	HX_("bg",c5,55,00,00),
	HX_("originalZoom",04,00,59,2a),
	HX_("originalCamPoint",32,c3,17,79),
	HX_("originalPosition",1a,ca,4a,75),
	HX_("originalCamTarget",2f,ea,71,0b),
	HX_("originalAlpha",4d,9d,87,7c),
	HX_("target",51,f3,ec,86),
	HX_("curAnim",b1,f7,86,ab),
	HX_("animsTxtGroup",11,f6,b6,fc),
	HX_("UI_animationbox",92,6d,a1,87),
	HX_("camHUD",e8,2b,76,b7),
	HX_("animationDropDown",55,ef,bb,0d),
	HX_("animationInputText",33,7a,56,eb),
	HX_("animationNameInputText",68,24,12,3c),
	HX_("animationIndicesInputText",d4,98,c7,74),
	HX_("animationFramerate",e9,d5,7d,25),
	HX_("animationLoopCheckBox",cb,a1,1d,ab),
	HX_("mainAnimTxt",a6,59,30,1b),
	HX_("addAnimationsUI",c4,44,96,30),
	HX_("reloadAnimList",88,3b,92,6a),
	HX_("reloadAnimationDropDown",bc,07,b3,2b),
	HX_("updateTextColors",a6,15,63,47),
	HX_("playAnim",25,ea,84,30),
	HX_("minZoom",c5,11,02,42),
	HX_("maxZoom",d7,fb,28,d1),
	HX_("holdingArrowsTime",9a,f6,8d,72),
	HX_("holdingArrowsElapsed",cf,c3,f8,c5),
	HX_("holdingFrameTime",57,dd,57,76),
	HX_("holdingFrameElapsed",32,f1,cf,09),
	HX_("update",09,86,05,87),
	::String(null()) };

::hx::Class StageEditorAnimationSubstate_obj::__mClass;

void StageEditorAnimationSubstate_obj::__register()
{
	StageEditorAnimationSubstate_obj _hx_dummy;
	StageEditorAnimationSubstate_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("states.editors.StageEditorAnimationSubstate",3e,56,38,7f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(StageEditorAnimationSubstate_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< StageEditorAnimationSubstate_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = StageEditorAnimationSubstate_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = StageEditorAnimationSubstate_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace states
} // end namespace editors
