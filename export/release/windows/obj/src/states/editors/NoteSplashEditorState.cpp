// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_Controls
#include <backend/Controls.h>
#endif
#ifndef INCLUDED_backend_DiscordClient
#include <backend/DiscordClient.h>
#endif
#ifndef INCLUDED_backend_MusicBeatState
#include <backend/MusicBeatState.h>
#endif
#ifndef INCLUDED_backend_MusicBeatSubstate
#include <backend/MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIBox
#include <backend/ui/PsychUIBox.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIButton
#include <backend/ui/PsychUIButton.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUICheckBox
#include <backend/ui/PsychUICheckBox.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIDropDownMenu
#include <backend/ui/PsychUIDropDownMenu.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUIInputText
#include <backend/ui/PsychUIInputText.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUINumericStepper
#include <backend/ui/PsychUINumericStepper.h>
#endif
#ifndef INCLUDED_backend_ui_PsychUITab
#include <backend/ui/PsychUITab.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroupIterator
#include <flixel/group/FlxTypedGroupIterator.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadManager
#include <flixel/input/gamepad/FlxGamepadManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMath
#include <flixel/math/FlxMath.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_LogFrontEnd
#include <flixel/system/frontEnds/LogFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_StackItem
#include <haxe/StackItem.h>
#endif
#ifndef INCLUDED_haxe__CallStack_CallStack_Impl_
#include <haxe/_CallStack/CallStack_Impl_.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_format_JsonParser
#include <haxe/format/JsonParser.h>
#endif
#ifndef INCLUDED_haxe_format_JsonPrinter
#include <haxe/format/JsonPrinter.h>
#endif
#ifndef INCLUDED_objects_Note
#include <objects/Note.h>
#endif
#ifndef INCLUDED_objects_NoteSplash
#include <objects/NoteSplash.h>
#endif
#ifndef INCLUDED_objects_StrumNote
#include <objects/StrumNote.h>
#endif
#ifndef INCLUDED_openfl_events_ErrorEvent
#include <openfl/events/ErrorEvent.h>
#endif
#ifndef INCLUDED_openfl_events_Event
#include <openfl/events/Event.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IOErrorEvent
#include <openfl/events/IOErrorEvent.h>
#endif
#ifndef INCLUDED_openfl_events_TextEvent
#include <openfl/events/TextEvent.h>
#endif
#ifndef INCLUDED_openfl_net_FileFilter
#include <openfl/net/FileFilter.h>
#endif
#ifndef INCLUDED_openfl_net_FileReference
#include <openfl/net/FileReference.h>
#endif
#ifndef INCLUDED_states_editors_MasterEditorMenu
#include <states/editors/MasterEditorMenu.h>
#endif
#ifndef INCLUDED_states_editors_NoteSplashEditorHelpSubState
#include <states/editors/NoteSplashEditorHelpSubState.h>
#endif
#ifndef INCLUDED_states_editors_NoteSplashEditorState
#include <states/editors/NoteSplashEditorState.h>
#endif
#ifndef INCLUDED_sys_io_File
#include <sys/io/File.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_16_new,"states.editors.NoteSplashEditorState","new",0x24368e89,"states.editors.NoteSplashEditorState.new","states/editors/NoteSplashEditorState.hx",16,0x384b3409)
static const Float _hx_array_data_8c409617_1[] = {
	(Float)0,(Float)0,
};
static const int _hx_array_data_8c409617_2[] = {
	(int)0,(int)0,(int)0,
};
static const int _hx_array_data_8c409617_3[] = {
	(int)0,(int)0,(int)0,
};
static const int _hx_array_data_8c409617_4[] = {
	(int)0,(int)0,(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_34_create,"states.editors.NoteSplashEditorState","create",0x23112873,"states.editors.NoteSplashEditorState.create","states/editors/NoteSplashEditorState.hx",34,0x384b3409)
static const ::String _hx_array_data_8c409617_6[] = {
	HX_("Animation",e4,ce,07,ed),
};
static const ::String _hx_array_data_8c409617_7[] = {
	HX_("Properties",13,00,c0,57),
};
static const ::String _hx_array_data_8c409617_8[] = {
	HX_("Shader",45,33,b5,51),
};
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_161_addAnimTab,"states.editors.NoteSplashEditorState","addAnimTab",0x77f2619a,"states.editors.NoteSplashEditorState.addAnimTab","states/editors/NoteSplashEditorState.hx",161,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_182_addAnimTab,"states.editors.NoteSplashEditorState","addAnimTab",0x77f2619a,"states.editors.NoteSplashEditorState.addAnimTab","states/editors/NoteSplashEditorState.hx",182,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_203_addAnimTab,"states.editors.NoteSplashEditorState","addAnimTab",0x77f2619a,"states.editors.NoteSplashEditorState.addAnimTab","states/editors/NoteSplashEditorState.hx",203,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_221_addAnimTab,"states.editors.NoteSplashEditorState","addAnimTab",0x77f2619a,"states.editors.NoteSplashEditorState.addAnimTab","states/editors/NoteSplashEditorState.hx",221,0x384b3409)
static const Float _hx_array_data_8c409617_15[] = {
	(Float)0,(Float)0,
};
static const Float _hx_array_data_8c409617_16[] = {
	(Float)0,(Float)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_256_addAnimTab,"states.editors.NoteSplashEditorState","addAnimTab",0x77f2619a,"states.editors.NoteSplashEditorState.addAnimTab","states/editors/NoteSplashEditorState.hx",256,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_298_addAnimTab,"states.editors.NoteSplashEditorState","addAnimTab",0x77f2619a,"states.editors.NoteSplashEditorState.addAnimTab","states/editors/NoteSplashEditorState.hx",298,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_275_addAnimTab,"states.editors.NoteSplashEditorState","addAnimTab",0x77f2619a,"states.editors.NoteSplashEditorState.addAnimTab","states/editors/NoteSplashEditorState.hx",275,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_130_addAnimTab,"states.editors.NoteSplashEditorState","addAnimTab",0x77f2619a,"states.editors.NoteSplashEditorState.addAnimTab","states/editors/NoteSplashEditorState.hx",130,0x384b3409)
static const ::String _hx_array_data_8c409617_21[] = {
	HX_("",00,00,00,00),
};
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_333_addPropertiesTab,"states.editors.NoteSplashEditorState","addPropertiesTab",0x2cce8978,"states.editors.NoteSplashEditorState.addPropertiesTab","states/editors/NoteSplashEditorState.hx",333,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_357_addPropertiesTab,"states.editors.NoteSplashEditorState","addPropertiesTab",0x2cce8978,"states.editors.NoteSplashEditorState.addPropertiesTab","states/editors/NoteSplashEditorState.hx",357,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_373_addPropertiesTab,"states.editors.NoteSplashEditorState","addPropertiesTab",0x2cce8978,"states.editors.NoteSplashEditorState.addPropertiesTab","states/editors/NoteSplashEditorState.hx",373,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_324_addPropertiesTab,"states.editors.NoteSplashEditorState","addPropertiesTab",0x2cce8978,"states.editors.NoteSplashEditorState.addPropertiesTab","states/editors/NoteSplashEditorState.hx",324,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_405_addShadersTab,"states.editors.NoteSplashEditorState","addShadersTab",0x03e80631,"states.editors.NoteSplashEditorState.addShadersTab","states/editors/NoteSplashEditorState.hx",405,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_417_addShadersTab,"states.editors.NoteSplashEditorState","addShadersTab",0x03e80631,"states.editors.NoteSplashEditorState.addShadersTab","states/editors/NoteSplashEditorState.hx",417,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_429_addShadersTab,"states.editors.NoteSplashEditorState","addShadersTab",0x03e80631,"states.editors.NoteSplashEditorState.addShadersTab","states/editors/NoteSplashEditorState.hx",429,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_441_addShadersTab,"states.editors.NoteSplashEditorState","addShadersTab",0x03e80631,"states.editors.NoteSplashEditorState.addShadersTab","states/editors/NoteSplashEditorState.hx",441,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_460_addShadersTab,"states.editors.NoteSplashEditorState","addShadersTab",0x03e80631,"states.editors.NoteSplashEditorState.addShadersTab","states/editors/NoteSplashEditorState.hx",460,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_482_addShadersTab,"states.editors.NoteSplashEditorState","addShadersTab",0x03e80631,"states.editors.NoteSplashEditorState.addShadersTab","states/editors/NoteSplashEditorState.hx",482,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_396_addShadersTab,"states.editors.NoteSplashEditorState","addShadersTab",0x03e80631,"states.editors.NoteSplashEditorState.addShadersTab","states/editors/NoteSplashEditorState.hx",396,0x384b3409)
static const ::String _hx_array_data_8c409617_39[] = {
	HX_("Red",31,91,3e,00),HX_("Green",a3,7e,1a,2d),HX_("Blue",ba,6e,f2,2b),
};
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_491___default_reloadImage,"states.editors.NoteSplashEditorState","__default_reloadImage",0xe9d43acd,"states.editors.NoteSplashEditorState.__default_reloadImage","states/editors/NoteSplashEditorState.hx",491,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_499_update,"states.editors.NoteSplashEditorState","update",0x2e074780,"states.editors.NoteSplashEditorState.update","states/editors/NoteSplashEditorState.hx",499,0x384b3409)
static const Float _hx_array_data_8c409617_44[] = {
	(Float)0,(Float)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_529_update,"states.editors.NoteSplashEditorState","update",0x2e074780,"states.editors.NoteSplashEditorState.update","states/editors/NoteSplashEditorState.hx",529,0x384b3409)
static const Float _hx_array_data_8c409617_46[] = {
	(Float)0,(Float)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_603_update,"states.editors.NoteSplashEditorState","update",0x2e074780,"states.editors.NoteSplashEditorState.update","states/editors/NoteSplashEditorState.hx",603,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_634_playStrumAnim,"states.editors.NoteSplashEditorState","playStrumAnim",0xcb76a6cf,"states.editors.NoteSplashEditorState.playStrumAnim","states/editors/NoteSplashEditorState.hx",634,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_658_resetRGB,"states.editors.NoteSplashEditorState","resetRGB",0x0beb45b5,"states.editors.NoteSplashEditorState.resetRGB","states/editors/NoteSplashEditorState.hx",658,0x384b3409)
static const int _hx_array_data_8c409617_50[] = {
	(int)0,(int)0,(int)0,
};
static const int _hx_array_data_8c409617_51[] = {
	(int)0,(int)0,(int)0,
};
static const int _hx_array_data_8c409617_52[] = {
	(int)0,(int)0,(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_665_parseRGB,"states.editors.NoteSplashEditorState","parseRGB",0x928715d1,"states.editors.NoteSplashEditorState.parseRGB","states/editors/NoteSplashEditorState.hx",665,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_710_setConfigRGB,"states.editors.NoteSplashEditorState","setConfigRGB",0x4553ba20,"states.editors.NoteSplashEditorState.setConfigRGB","states/editors/NoteSplashEditorState.hx",710,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_740_onSaveComplete,"states.editors.NoteSplashEditorState","onSaveComplete",0xdaa23d4c,"states.editors.NoteSplashEditorState.onSaveComplete","states/editors/NoteSplashEditorState.hx",740,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_752_onSaveCancel,"states.editors.NoteSplashEditorState","onSaveCancel",0x39f3cf4d,"states.editors.NoteSplashEditorState.onSaveCancel","states/editors/NoteSplashEditorState.hx",752,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_763_onSaveError,"states.editors.NoteSplashEditorState","onSaveError",0xee944555,"states.editors.NoteSplashEditorState.onSaveError","states/editors/NoteSplashEditorState.hx",763,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_772_saveSplash,"states.editors.NoteSplashEditorState","saveSplash",0x9e77557b,"states.editors.NoteSplashEditorState.saveSplash","states/editors/NoteSplashEditorState.hx",772,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_786_loadTxt,"states.editors.NoteSplashEditorState","loadTxt",0x836a6e93,"states.editors.NoteSplashEditorState.loadTxt","states/editors/NoteSplashEditorState.hx",786,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_796_onLoadComplete,"states.editors.NoteSplashEditorState","onLoadComplete",0x8182dd35,"states.editors.NoteSplashEditorState.onLoadComplete","states/editors/NoteSplashEditorState.hx",796,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_832_onLoadCancel,"states.editors.NoteSplashEditorState","onLoadCancel",0xa66572f6,"states.editors.NoteSplashEditorState.onLoadCancel","states/editors/NoteSplashEditorState.hx",832,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_844_onLoadError,"states.editors.NoteSplashEditorState","onLoadError",0x7b1e89cc,"states.editors.NoteSplashEditorState.onLoadError","states/editors/NoteSplashEditorState.hx",844,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_853_destroy,"states.editors.NoteSplashEditorState","destroy",0x9f0db3a3,"states.editors.NoteSplashEditorState.destroy","states/editors/NoteSplashEditorState.hx",853,0x384b3409)
static const int _hx_array_data_8c409617_65[] = {
	(int)48,
};
static const int _hx_array_data_8c409617_66[] = {
	(int)109,(int)189,
};
static const int _hx_array_data_8c409617_67[] = {
	(int)107,(int)187,
};
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_864_parseTxt,"states.editors.NoteSplashEditorState","parseTxt",0x9288c534,"states.editors.NoteSplashEditorState.parseTxt","states/editors/NoteSplashEditorState.hx",864,0x384b3409)
HX_LOCAL_STACK_FRAME(_hx_pos_c40e4203cdaacbc6_26_boot,"states.editors.NoteSplashEditorState","boot",0x839f29e9,"states.editors.NoteSplashEditorState.boot","states/editors/NoteSplashEditorState.hx",26,0x384b3409)
namespace states{
namespace editors{

void NoteSplashEditorState_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_16_new)
HXLINE( 497)		this->copiedOffset = ::Array_obj< Float >::fromData( _hx_array_data_8c409617_1,2);
HXLINE( 496)		this->holdingArrowsElapsed = ((Float)0);
HXLINE( 495)		this->holdingArrowsTime = ((Float)0);
HXLINE( 392)		this->blueShader = ::Array_obj< int >::fromData( _hx_array_data_8c409617_2,3);
HXLINE( 391)		this->greenShader = ::Array_obj< int >::fromData( _hx_array_data_8c409617_3,3);
HXLINE( 390)		this->redShader = ::Array_obj< int >::fromData( _hx_array_data_8c409617_4,3);
HXLINE( 389)		this->greenEnabled = true;
HXLINE( 388)		this->blueEnabled = true;
HXLINE( 387)		this->redEnabled = true;
HXLINE( 126)		this->curAnimText = null();
HXLINE(  20)		this->config = ::objects::NoteSplash_obj::createConfig();
HXLINE(  19)		this->splashes =  ::flixel::group::FlxTypedSpriteGroup_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  18)		this->strums =  ::flixel::group::FlxTypedSpriteGroup_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE(  16)		super::__construct();
            	}

Dynamic NoteSplashEditorState_obj::__CreateEmpty() { return new NoteSplashEditorState_obj; }

void *NoteSplashEditorState_obj::_hx_vtable = 0;

Dynamic NoteSplashEditorState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< NoteSplashEditorState_obj > _hx_result = new NoteSplashEditorState_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool NoteSplashEditorState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x53aaab8a) {
			if (inClassId<=(int)0x2b0f5253) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x2b0f5253;
			} else {
				return inClassId==(int)0x53aaab8a;
			}
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void NoteSplashEditorState_obj::create(){
            	HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_34_create)
HXLINE(  35)		if (::hx::IsNull( ::states::editors::NoteSplashEditorState_obj::imageSkin )) {
HXLINE(  36)			::states::editors::NoteSplashEditorState_obj::imageSkin = (::objects::NoteSplash_obj::defaultNoteSplash + ::objects::NoteSplash_obj::getSplashSkinPostfix());
            		}
HXLINE(  38)		::flixel::FlxG_obj::mouse->set_visible(true);
HXLINE(  40)		::flixel::FlxG_obj::sound->volumeUpKeys = ::Array_obj< int >::__new(0);
HXLINE(  41)		::flixel::FlxG_obj::sound->volumeDownKeys = ::Array_obj< int >::__new(0);
HXLINE(  42)		::flixel::FlxG_obj::sound->muteKeys = ::Array_obj< int >::__new(0);
HXLINE(  45)		::backend::DiscordClient_obj::changePresence(HX_("Note Splash Editor",b8,52,34,fe),null(),null(),null(),null(),null());
HXLINE(  48)		 ::flixel::FlxSprite bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXDLIN(  48)		 ::flixel::FlxSprite bg1 = bg->loadGraphic(::backend::Paths_obj::image(HX_("menuDesat",26,91,04,72),null(),null()),null(),null(),null(),null(),null());
HXLINE(  49)		{
HXLINE(  49)			 ::flixel::math::FlxBasePoint this1 = bg1->scrollFactor;
HXDLIN(  49)			this1->set_x(( (Float)(0) ));
HXDLIN(  49)			this1->set_y(( (Float)(0) ));
            		}
HXLINE(  50)		bg1->set_color(-11513776);
HXLINE(  51)		this->add(bg1);
HXLINE(  53)		this->UI =  ::backend::ui::PsychUIBox_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),0,0,::Array_obj< ::String >::fromData( _hx_array_data_8c409617_6,1));
HXLINE(  54)		this->UI->canMove = this->UI->set_canMinimize(false);
HXLINE(  55)		 ::backend::ui::PsychUIBox fh = this->UI;
HXDLIN(  55)		fh->set_y((fh->y + 20));
HXLINE(  56)		this->UI->set_x(( (Float)((::flixel::FlxG_obj::width - 300)) ));
HXLINE(  57)		this->UI->resize(290,240);
HXLINE(  59)		this->properUI =  ::backend::ui::PsychUIBox_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),0,0,::Array_obj< ::String >::fromData( _hx_array_data_8c409617_7,1));
HXLINE(  60)		this->properUI->canMove = this->properUI->set_canMinimize(false);
HXLINE(  61)		this->properUI->resize(280,210);
HXLINE(  62)		 ::backend::ui::PsychUIBox fh1 = this->properUI;
HXDLIN(  62)		fh1->set_y((fh1->y + 20));
HXLINE(  63)		 ::backend::ui::PsychUIBox _hx_tmp = this->properUI;
HXDLIN(  63)		Float _hx_tmp1 = this->UI->x;
HXDLIN(  63)		_hx_tmp->set_x(((_hx_tmp1 - this->properUI->get_width()) - ( (Float)(5) )));
HXLINE(  64)		this->add(this->properUI);
HXLINE(  65)		this->add(this->UI);
HXLINE(  67)		this->shaderUI =  ::backend::ui::PsychUIBox_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),0,0,::Array_obj< ::String >::fromData( _hx_array_data_8c409617_8,1));
HXLINE(  68)		this->shaderUI->canMove = this->shaderUI->set_canMinimize(false);
HXLINE(  69)		this->shaderUI->resize(160,180);
HXLINE(  70)		 ::backend::ui::PsychUIBox _hx_tmp2 = this->shaderUI;
HXDLIN(  70)		int _hx_tmp3 = ::flixel::FlxG_obj::width;
HXDLIN(  70)		_hx_tmp2->set_x(((( (Float)(_hx_tmp3) ) - this->shaderUI->get_width()) - ( (Float)(10) )));
HXLINE(  71)		 ::backend::ui::PsychUIBox _hx_tmp4 = this->shaderUI;
HXDLIN(  71)		Float _hx_tmp5 = this->UI->y;
HXDLIN(  71)		_hx_tmp4->set_y(((_hx_tmp5 + this->UI->get_height()) + 10));
HXLINE(  72)		this->add(this->shaderUI);
HXLINE(  74)		 ::flixel::text::FlxText tipText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE(  75)		tipText->setFormat(null(),24,null(),null(),null(),null(),null());
HXLINE(  76)		tipText->set_text(HX_("Press F1 for Help",b0,ec,b9,d4));
HXLINE(  77)		Float _hx_tmp6 = this->properUI->x;
HXDLIN(  77)		Float _hx_tmp7 = ((_hx_tmp6 - this->properUI->get_width()) + 15);
HXDLIN(  77)		tipText->setPosition(_hx_tmp7,this->UI->y);
HXLINE(  78)		this->add(tipText);
HXLINE(  80)		{
HXLINE(  81)			{
HXLINE(  82)				 ::objects::StrumNote babyArrow =  ::objects::StrumNote_obj::__alloc( HX_CTX ,( (Float)(-273) ),( (Float)(50) ),::hx::Mod(0,4),1);
HXLINE(  83)				babyArrow->playerPosition();
HXLINE(  84)				{
HXLINE(  84)					int axes = 16;
HXDLIN(  84)					bool _hx_tmp8;
HXDLIN(  84)					if ((axes != 1)) {
HXLINE(  84)						_hx_tmp8 = (axes == 17);
            					}
            					else {
HXLINE(  84)						_hx_tmp8 = true;
            					}
HXDLIN(  84)					if (_hx_tmp8) {
HXLINE(  84)						int _hx_tmp9 = ::flixel::FlxG_obj::width;
HXDLIN(  84)						babyArrow->set_x(((( (Float)(_hx_tmp9) ) - babyArrow->get_width()) / ( (Float)(2) )));
            					}
HXDLIN(  84)					bool _hx_tmp10;
HXDLIN(  84)					if ((axes != 16)) {
HXLINE(  84)						_hx_tmp10 = (axes == 17);
            					}
            					else {
HXLINE(  84)						_hx_tmp10 = true;
            					}
HXDLIN(  84)					if (_hx_tmp10) {
HXLINE(  84)						int _hx_tmp11 = ::flixel::FlxG_obj::height;
HXDLIN(  84)						babyArrow->set_y(((( (Float)(_hx_tmp11) ) - babyArrow->get_height()) / ( (Float)(2) )));
            					}
            				}
HXLINE(  85)				babyArrow->ID = 0;
HXLINE(  86)				this->strums->add(babyArrow).StaticCast<  ::objects::StrumNote >();
            			}
HXLINE(  81)			{
HXLINE(  82)				 ::objects::StrumNote babyArrow1 =  ::objects::StrumNote_obj::__alloc( HX_CTX ,( (Float)(-273) ),( (Float)(50) ),::hx::Mod(1,4),1);
HXLINE(  83)				babyArrow1->playerPosition();
HXLINE(  84)				{
HXLINE(  84)					int axes1 = 16;
HXDLIN(  84)					bool _hx_tmp12;
HXDLIN(  84)					if ((axes1 != 1)) {
HXLINE(  84)						_hx_tmp12 = (axes1 == 17);
            					}
            					else {
HXLINE(  84)						_hx_tmp12 = true;
            					}
HXDLIN(  84)					if (_hx_tmp12) {
HXLINE(  84)						int _hx_tmp13 = ::flixel::FlxG_obj::width;
HXDLIN(  84)						babyArrow1->set_x(((( (Float)(_hx_tmp13) ) - babyArrow1->get_width()) / ( (Float)(2) )));
            					}
HXDLIN(  84)					bool _hx_tmp14;
HXDLIN(  84)					if ((axes1 != 16)) {
HXLINE(  84)						_hx_tmp14 = (axes1 == 17);
            					}
            					else {
HXLINE(  84)						_hx_tmp14 = true;
            					}
HXDLIN(  84)					if (_hx_tmp14) {
HXLINE(  84)						int _hx_tmp15 = ::flixel::FlxG_obj::height;
HXDLIN(  84)						babyArrow1->set_y(((( (Float)(_hx_tmp15) ) - babyArrow1->get_height()) / ( (Float)(2) )));
            					}
            				}
HXLINE(  85)				babyArrow1->ID = 1;
HXLINE(  86)				this->strums->add(babyArrow1).StaticCast<  ::objects::StrumNote >();
            			}
HXLINE(  81)			{
HXLINE(  82)				 ::objects::StrumNote babyArrow2 =  ::objects::StrumNote_obj::__alloc( HX_CTX ,( (Float)(-273) ),( (Float)(50) ),::hx::Mod(2,4),1);
HXLINE(  83)				babyArrow2->playerPosition();
HXLINE(  84)				{
HXLINE(  84)					int axes2 = 16;
HXDLIN(  84)					bool _hx_tmp16;
HXDLIN(  84)					if ((axes2 != 1)) {
HXLINE(  84)						_hx_tmp16 = (axes2 == 17);
            					}
            					else {
HXLINE(  84)						_hx_tmp16 = true;
            					}
HXDLIN(  84)					if (_hx_tmp16) {
HXLINE(  84)						int _hx_tmp17 = ::flixel::FlxG_obj::width;
HXDLIN(  84)						babyArrow2->set_x(((( (Float)(_hx_tmp17) ) - babyArrow2->get_width()) / ( (Float)(2) )));
            					}
HXDLIN(  84)					bool _hx_tmp18;
HXDLIN(  84)					if ((axes2 != 16)) {
HXLINE(  84)						_hx_tmp18 = (axes2 == 17);
            					}
            					else {
HXLINE(  84)						_hx_tmp18 = true;
            					}
HXDLIN(  84)					if (_hx_tmp18) {
HXLINE(  84)						int _hx_tmp19 = ::flixel::FlxG_obj::height;
HXDLIN(  84)						babyArrow2->set_y(((( (Float)(_hx_tmp19) ) - babyArrow2->get_height()) / ( (Float)(2) )));
            					}
            				}
HXLINE(  85)				babyArrow2->ID = 2;
HXLINE(  86)				this->strums->add(babyArrow2).StaticCast<  ::objects::StrumNote >();
            			}
HXLINE(  81)			{
HXLINE(  82)				 ::objects::StrumNote babyArrow3 =  ::objects::StrumNote_obj::__alloc( HX_CTX ,( (Float)(-273) ),( (Float)(50) ),::hx::Mod(3,4),1);
HXLINE(  83)				babyArrow3->playerPosition();
HXLINE(  84)				{
HXLINE(  84)					int axes3 = 16;
HXDLIN(  84)					bool _hx_tmp20;
HXDLIN(  84)					if ((axes3 != 1)) {
HXLINE(  84)						_hx_tmp20 = (axes3 == 17);
            					}
            					else {
HXLINE(  84)						_hx_tmp20 = true;
            					}
HXDLIN(  84)					if (_hx_tmp20) {
HXLINE(  84)						int _hx_tmp21 = ::flixel::FlxG_obj::width;
HXDLIN(  84)						babyArrow3->set_x(((( (Float)(_hx_tmp21) ) - babyArrow3->get_width()) / ( (Float)(2) )));
            					}
HXDLIN(  84)					bool _hx_tmp22;
HXDLIN(  84)					if ((axes3 != 16)) {
HXLINE(  84)						_hx_tmp22 = (axes3 == 17);
            					}
            					else {
HXLINE(  84)						_hx_tmp22 = true;
            					}
HXDLIN(  84)					if (_hx_tmp22) {
HXLINE(  84)						int _hx_tmp23 = ::flixel::FlxG_obj::height;
HXDLIN(  84)						babyArrow3->set_y(((( (Float)(_hx_tmp23) ) - babyArrow3->get_height()) / ( (Float)(2) )));
            					}
            				}
HXLINE(  85)				babyArrow3->ID = 3;
HXLINE(  86)				this->strums->add(babyArrow3).StaticCast<  ::objects::StrumNote >();
            			}
            		}
HXLINE(  89)		this->add(this->strums);
HXLINE(  90)		this->add(this->splashes);
HXLINE(  92)		this->splash =  ::objects::NoteSplash_obj::__alloc( HX_CTX ,0,0,::states::editors::NoteSplashEditorState_obj::imageSkin);
HXLINE(  93)		this->splash->inEditor = true;
HXLINE(  94)		this->splash->set_alpha(((Float).0));
HXLINE(  95)		this->splashes->add(this->splash).StaticCast<  ::objects::NoteSplash >();
HXLINE(  97)		if (::hx::IsNotNull( this->splash->config )) {
HXLINE(  98)			this->config = this->splash->config;
            		}
HXLINE( 100)		this->parseRGB();
HXLINE( 102)		this->addPropertiesTab();
HXLINE( 103)		this->addAnimTab();
HXLINE( 104)		this->addShadersTab();
HXLINE( 106)		this->errorText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 107)		this->errorText->setFormat(null(),16,-65536,null(),null(),null(),null());
HXLINE( 108)		this->errorText->set_text(HX_("ERROR!",79,2f,eb,03));
HXLINE( 109)		 ::flixel::text::FlxText _hx_tmp24 = this->errorText;
HXDLIN( 109)		int _hx_tmp25 = ::flixel::FlxG_obj::height;
HXDLIN( 109)		_hx_tmp24->set_y((( (Float)(_hx_tmp25) ) - this->errorText->get_height()));
HXLINE( 110)		this->errorText->set_alpha(((Float).0));
HXLINE( 111)		this->add(this->errorText);
HXLINE( 113)		this->curText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 114)		this->curText->setFormat(null(),24,null(),null(),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 115)		this->curText->set_text(HX_("Copied Offsets: [0, 0]\nCurrent Animation: NONE",d1,24,fd,fe));
HXLINE( 116)		 ::flixel::text::FlxText _hx_tmp26 = this->curText;
HXDLIN( 116)		int _hx_tmp27 = ::flixel::FlxG_obj::height;
HXDLIN( 116)		_hx_tmp26->set_y((( (Float)(_hx_tmp27) ) - this->curText->get_height()));
HXLINE( 117)		 ::flixel::text::FlxText fh2 = this->curText;
HXDLIN( 117)		fh2->set_x((fh2->x + 5));
HXLINE( 118)		this->add(this->curText);
HXLINE( 120)		this->super::create();
            	}


void NoteSplashEditorState_obj::addAnimTab(){
            		HX_BEGIN_LOCAL_FUNC_S6(::hx::LocalFunc,_hx_Closure_0, ::states::editors::NoteSplashEditorState,_gthis, ::backend::ui::PsychUIInputText,name_input, ::backend::ui::PsychUINumericStepper,maxFps, ::backend::ui::PsychUIInputText,indices_input, ::backend::ui::PsychUIInputText,prefix_input, ::backend::ui::PsychUINumericStepper,minFps) HXARGC(2)
            		void _hx_run(int id,::String name){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_161_addAnimTab)
HXLINE( 161)			bool _hx_tmp;
HXDLIN( 161)			if (::hx::IsNotNull( _gthis->config )) {
HXLINE( 161)				_hx_tmp = (name.length > 0);
            			}
            			else {
HXLINE( 161)				_hx_tmp = false;
            			}
HXDLIN( 161)			if (_hx_tmp) {
HXLINE( 163)				 ::Dynamic i = ( ( ::haxe::ds::StringMap)( ::Dynamic(_gthis->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(name);
HXLINE( 164)				if (::hx::IsNotNull( i )) {
HXLINE( 166)					name_input->set_text(name);
HXLINE( 167)					prefix_input->set_text(( (::String)(i->__Field(HX_("prefix",92,d9,b6,ae),::hx::paccDynamic)) ));
HXLINE( 168)					_gthis->numericStepperData->set_min(( (Float)(0) ));
HXLINE( 169)					_gthis->numericStepperData->set_value(( (Float)(i->__Field(HX_("noteData",3c,7b,96,51),::hx::paccDynamic)) ));
HXLINE( 170)					_gthis->curAnim = name;
HXLINE( 171)					minFps->set_value(( (Float)( ::Dynamic(i->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic))->__GetItem(0)) ));
HXLINE( 172)					maxFps->set_value(( (Float)( ::Dynamic(i->__Field(HX_("fps",e9,c7,4d,00),::hx::paccDynamic))->__GetItem(1)) ));
HXLINE( 173)					bool _hx_tmp1;
HXDLIN( 173)					if (::hx::IsNotNull( i->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic) )) {
HXLINE( 173)						_hx_tmp1 = (( (::Array< int >)(i->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) )->length > 0);
            					}
            					else {
HXLINE( 173)						_hx_tmp1 = false;
            					}
HXDLIN( 173)					if (_hx_tmp1) {
HXLINE( 174)						 ::backend::ui::PsychUIInputText indices_input1 = indices_input;
HXDLIN( 174)						::String _hx_tmp2 = ( (::Array< int >)(i->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) )->toString();
HXDLIN( 174)						indices_input1->set_text(_hx_tmp2.substring(1,(( (::Array< int >)(i->__Field(HX_("indices",27,47,54,e3),::hx::paccDynamic)) )->toString().length - 2)));
            					}
HXLINE( 176)					_gthis->playStrumAnim(_gthis->curAnim,( (int)(i->__Field(HX_("noteData",3c,7b,96,51),::hx::paccDynamic)) ));
            				}
            			}
            		}
            		HX_END_LOCAL_FUNC2((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::states::editors::NoteSplashEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_182_addAnimTab)
HXLINE( 183)			::Array< ::String > anims = ::Array_obj< ::String >::__new(0);
HXLINE( 184)			bool setAnimDropDown;
HXDLIN( 184)			if (::hx::IsNotNull( _gthis->config )) {
HXLINE( 184)				setAnimDropDown = ::hx::IsNotNull( _gthis->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic) );
            			}
            			else {
HXLINE( 184)				setAnimDropDown = false;
            			}
HXDLIN( 184)			if (setAnimDropDown) {
HXLINE( 185)				 ::Dynamic i = ( ( ::haxe::ds::StringMap)( ::Dynamic(_gthis->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->keys();
HXDLIN( 185)				while(( (bool)(i->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXLINE( 185)					::String i1 = ( (::String)(i->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 187)					anims->push(i1);
            				}
            			}
HXLINE( 190)			if ((anims->length < 1)) {
HXLINE( 191)				anims->push(HX_("",00,00,00,00));
            			}
HXLINE( 193)			bool setAnimDropDown1;
HXDLIN( 193)			if (::hx::IsNull( _gthis->curAnim )) {
HXLINE( 193)				setAnimDropDown1 = (anims->__get(0).length > 0);
            			}
            			else {
HXLINE( 193)				setAnimDropDown1 = false;
            			}
HXDLIN( 193)			if (setAnimDropDown1) {
HXLINE( 194)				_gthis->curAnim = anims->__get(0);
            			}
HXLINE( 196)			_gthis->animDropDown->set_list(anims);
HXLINE( 197)			_gthis->animDropDown->set_selectedLabel(_gthis->curAnim);
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S7(::hx::LocalFunc,_hx_Closure_2, ::states::editors::NoteSplashEditorState,_gthis, ::Dynamic,setAnimDropDown, ::backend::ui::PsychUIInputText,name_input, ::backend::ui::PsychUINumericStepper,maxFps, ::backend::ui::PsychUIInputText,indices_input, ::backend::ui::PsychUIInputText,prefix_input, ::backend::ui::PsychUINumericStepper,minFps) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_203_addAnimTab)
HXLINE( 204)			::objects::NoteSplash_obj::configs->clear();
HXLINE( 205)			_gthis->config = ::objects::NoteSplash_obj::createConfig();
HXLINE( 207)			_gthis->curAnim = null();
HXLINE( 208)			name_input->set_text(HX_("",00,00,00,00));
HXLINE( 209)			prefix_input->set_text(HX_("",00,00,00,00));
HXLINE( 210)			indices_input->set_text(HX_("",00,00,00,00));
HXLINE( 211)			_gthis->numericStepperData->set_value(( (Float)(0) ));
HXLINE( 212)			minFps->set_value(( (Float)(22) ));
HXLINE( 213)			maxFps->set_value(( (Float)(26) ));
HXLINE( 214)			setAnimDropDown();
HXLINE( 215)			_gthis->parseRGB();
HXLINE( 216)			_gthis->changeShader->set_selectedLabel(HX_("Red",31,91,3e,00));
HXLINE( 217)			_gthis->changeShader->onSelect(0,HX_("Red",31,91,3e,00));
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S7(::hx::LocalFunc,_hx_Closure_3, ::states::editors::NoteSplashEditorState,_gthis, ::Dynamic,setAnimDropDown, ::backend::ui::PsychUIInputText,name_input, ::backend::ui::PsychUINumericStepper,maxFps, ::backend::ui::PsychUIInputText,prefix_input, ::backend::ui::PsychUIInputText,indices_input, ::backend::ui::PsychUINumericStepper,minFps) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_221_addAnimTab)
HXLINE( 222)			::Array< int > indices = ::Array_obj< int >::__new(0);
HXLINE( 223)			if ((indices_input->text.split(HX_(",",2c,00,00,00))->length > 1)) {
HXLINE( 225)				int _g = 0;
HXDLIN( 225)				::Array< ::String > _g1 = indices_input->text.split(HX_(",",2c,00,00,00));
HXDLIN( 225)				while((_g < _g1->length)){
HXLINE( 225)					::String i = _g1->__get(_g);
HXDLIN( 225)					_g = (_g + 1);
HXLINE( 227)					 ::Dynamic index = ::Std_obj::parseInt(i);
HXLINE( 228)					bool _hx_tmp;
HXDLIN( 228)					if (!(::Math_obj::isNaN(( (Float)(index) )))) {
HXLINE( 228)						_hx_tmp = ::hx::IsNotNull( index );
            					}
            					else {
HXLINE( 228)						_hx_tmp = false;
            					}
HXDLIN( 228)					if (_hx_tmp) {
HXLINE( 230)						indices->push(index);
            					}
            				}
            			}
HXLINE( 235)			::Array< Float > offsets = ::Array_obj< Float >::fromData( _hx_array_data_8c409617_15,2);
HXLINE( 236)			 ::Dynamic conf = ( ( ::haxe::ds::StringMap)( ::Dynamic(_gthis->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(name_input->text);
HXLINE( 238)			if (::hx::IsNotNull( conf )) {
HXLINE( 239)				offsets = ( (::Array< Float >)(conf->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) );
            			}
HXLINE( 241)			if (::hx::IsNull( offsets )) {
HXLINE( 242)				offsets = ::Array_obj< Float >::fromData( _hx_array_data_8c409617_16,2);
            			}
            			else {
HXLINE( 244)				offsets = offsets->copy();
            			}
HXLINE( 246)			_gthis->config = ::objects::NoteSplash_obj::addAnimationToConfig(_gthis->config,_gthis->scaleNumericStepper->value,name_input->text,prefix_input->text,::Array_obj< int >::__new(2)->init(0,( (int)(minFps->value) ))->init(1,( (int)(maxFps->value) )),offsets,indices,( (int)(_gthis->numericStepperData->value) ));
HXLINE( 247)			_gthis->curAnim = name_input->text;
HXLINE( 248)			_gthis->playStrumAnim(_gthis->curAnim,( (int)(_gthis->numericStepperData->value) ));
HXLINE( 249)			setAnimDropDown();
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S5(::hx::LocalFunc,_hx_Closure_4, ::states::editors::NoteSplashEditorState,_gthis, ::Dynamic,setAnimDropDown, ::backend::ui::PsychUIInputText,name_input, ::backend::ui::PsychUIInputText,indices_input, ::backend::ui::PsychUIInputText,prefix_input) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_256_addAnimTab)
HXLINE( 256)			if (::hx::IsNotNull( _gthis->config )) {
HXLINE( 258)				if (( ( ::haxe::ds::StringMap)( ::Dynamic(_gthis->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->exists(_gthis->curAnim)) {
HXLINE( 260)					( ( ::haxe::ds::StringMap)( ::Dynamic(_gthis->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->remove(_gthis->curAnim);
HXLINE( 262)					_gthis->curAnim = null();
HXLINE( 263)					name_input->set_text(HX_("",00,00,00,00));
HXLINE( 264)					prefix_input->set_text(HX_("",00,00,00,00));
HXLINE( 265)					indices_input->set_text(HX_("",00,00,00,00));
HXLINE( 266)					_gthis->numericStepperData->set_value(( (Float)(0) ));
HXLINE( 267)					setAnimDropDown();
            				}
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S7(::hx::LocalFunc,_hx_Closure_6, ::states::editors::NoteSplashEditorState,_gthis, ::Dynamic,setAnimDropDown, ::backend::ui::PsychUIInputText,name_input, ::backend::ui::PsychUINumericStepper,maxFps, ::backend::ui::PsychUIInputText,indices_input, ::backend::ui::PsychUIInputText,prefix_input, ::backend::ui::PsychUINumericStepper,minFps) HXARGC(0)
            		void _hx_run(){
            			HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_5, ::states::editors::NoteSplashEditorState,_gthis) HXARGC(1)
            			void _hx_run( ::flixel::tweens::FlxTween twn){
            				HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_298_addAnimTab)
HXLINE( 298)				_gthis->errorText->set_color(-65536);
            			}
            			HX_END_LOCAL_FUNC1((void))

            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_275_addAnimTab)
HXLINE( 276)			::states::editors::NoteSplashEditorState_obj::imageSkin = _gthis->imageInputText->text;
HXLINE( 278)			_gthis->errorText->set_color(-65536);
HXLINE( 279)			::flixel::tweens::FlxTween_obj::cancelTweensOf(_gthis->errorText,null());
HXLINE( 281)			 ::flixel::graphics::FlxGraphic image = ::backend::Paths_obj::image(::states::editors::NoteSplashEditorState_obj::imageSkin,null(),null());
HXLINE( 282)			if (::hx::IsNull( image )) {
HXLINE( 284)				_gthis->errorText->set_text(((HX_("ERROR! Couldn't find ",08,c0,9f,70) + ::states::editors::NoteSplashEditorState_obj::imageSkin) + HX_(".png",3b,2d,bd,1e)));
HXLINE( 285)				_gthis->errorText->set_alpha(( (Float)(1) ));
HXLINE( 286)				return;
            			}
            			else {
HXLINE( 290)				_gthis->errorText->set_color(-16744448);
HXLINE( 291)				_gthis->errorText->set_alpha(( (Float)(1) ));
HXLINE( 292)				_gthis->errorText->set_text(((HX_("Succesfully loaded ",95,e3,bd,29) + ::states::editors::NoteSplashEditorState_obj::imageSkin) + HX_(".png",3b,2d,bd,1e)));
            			}
HXLINE( 295)			::objects::NoteSplash_obj::configs->clear();
HXLINE( 297)			::flixel::tweens::FlxTween_obj::tween(_gthis->errorText, ::Dynamic(::hx::Anon_obj::Create(1)
            				->setFixed(0,HX_("alpha",5e,a7,96,21),0)),1, ::Dynamic(::hx::Anon_obj::Create(2)
            				->setFixed(0,HX_("startDelay",c1,af,3d,f3),1)
            				->setFixed(1,HX_("onComplete",f8,d4,7e,5d), ::Dynamic(new _hx_Closure_5(_gthis)))));
HXLINE( 301)			_gthis->splash->loadSplash(::states::editors::NoteSplashEditorState_obj::imageSkin);
HXLINE( 302)			_gthis->splash->set_alpha(((Float)0.0001));
HXLINE( 304)			if (::hx::IsNotNull( _gthis->splash->config )) {
HXLINE( 304)				_gthis->config = _gthis->splash->config;
            			}
            			else {
HXLINE( 305)				_gthis->config = ::objects::NoteSplash_obj::createConfig();
            			}
HXLINE( 307)			_gthis->curAnim = null();
HXLINE( 308)			name_input->set_text(HX_("",00,00,00,00));
HXLINE( 309)			prefix_input->set_text(HX_("",00,00,00,00));
HXLINE( 310)			indices_input->set_text(HX_("",00,00,00,00));
HXLINE( 311)			_gthis->numericStepperData->set_value(( (Float)(0) ));
HXLINE( 312)			minFps->set_value(( (Float)(22) ));
HXLINE( 313)			maxFps->set_value(( (Float)(26) ));
HXLINE( 314)			setAnimDropDown();
HXLINE( 315)			_gthis->parseRGB();
HXLINE( 316)			_gthis->changeShader->set_selectedLabel(HX_("Red",31,91,3e,00));
HXLINE( 317)			_gthis->changeShader->onSelect(0,HX_("Red",31,91,3e,00));
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_130_addAnimTab)
HXDLIN( 130)		 ::states::editors::NoteSplashEditorState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 131)		 ::flixel::group::FlxTypedSpriteGroup UI = this->UI->getTab(HX_("Animation",e4,ce,07,ed))->menu;
HXLINE( 133)		UI->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,20,20,0,HX_("Animation Name:",33,9d,11,30),8,null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 134)		 ::backend::ui::PsychUIInputText name_input =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,20,((Float)37.5),100,HX_("",00,00,00,00),8);
HXLINE( 135)		name_input->name = HX_("name_input",d6,c7,ef,09);
HXLINE( 136)		this->curAnimText = name_input;
HXLINE( 137)		UI->add(name_input).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 139)		UI->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,name_input->x,(name_input->y + 30),0,HX_("Animation Prefix:",0c,45,6e,12),8,null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 140)		 ::backend::ui::PsychUIInputText prefix_input =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,20,(name_input->y + ((Float)47.5)),100,HX_("",00,00,00,00),8);
HXLINE( 141)		UI->add(prefix_input).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 143)		UI->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,150,20,0,HX_("Note Data:",22,a8,51,93),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 144)		this->numericStepperData =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,150,((Float)37.5),1,((Float).0),((Float).0),999,0,null(),null());
HXLINE( 145)		UI->add(this->numericStepperData).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 147)		UI->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,150,(name_input->y + 30),0,HX_("Indices (OPTIONAL):",20,5f,bd,da),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 148)		 ::backend::ui::PsychUIInputText indices_input =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,150,(name_input->y + ((Float)47.5)),100,HX_("",00,00,00,00),8);
HXLINE( 149)		UI->add(indices_input).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 151)		UI->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,20,110,0,HX_("Minimum FPS:",03,38,d6,52),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 152)		 ::backend::ui::PsychUINumericStepper minFps =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,20,((Float)127.5),1,22,1,120,null(),null(),null());
HXLINE( 153)		UI->add(minFps).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 155)		UI->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,150,110,0,HX_("Maximum FPS:",b1,8c,cb,ce),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 156)		 ::backend::ui::PsychUINumericStepper maxFps =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,150,((Float)127.5),1,26,1,120,null(),null(),null());
HXLINE( 157)		UI->add(maxFps).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 159)		this->animDropDown =  ::backend::ui::PsychUIDropDownMenu_obj::__alloc( HX_CTX ,( (Float)(-155) ),( (Float)(57) ),::Array_obj< ::String >::fromData( _hx_array_data_8c409617_21,1), ::Dynamic(new _hx_Closure_0(_gthis,name_input,maxFps,indices_input,prefix_input,minFps)),null());
HXLINE( 181)		 ::Dynamic setAnimDropDown =  ::Dynamic(new _hx_Closure_1(_gthis));
HXLINE( 200)		setAnimDropDown();
HXLINE( 202)		this->templateButton->onClick =  ::Dynamic(new _hx_Closure_2(_gthis,setAnimDropDown,name_input,maxFps,indices_input,prefix_input,minFps));
HXLINE( 220)		this->addButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,20,185,HX_("Add/Update",b7,cf,f4,ee), ::Dynamic(new _hx_Closure_3(_gthis,setAnimDropDown,name_input,maxFps,prefix_input,indices_input,minFps)),null(),null());
HXLINE( 252)		UI->add(this->addButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 254)		 ::backend::ui::PsychUIButton removeButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,185,185,HX_("Remove",64,10,1d,39), ::Dynamic(new _hx_Closure_4(_gthis,setAnimDropDown,name_input,indices_input,prefix_input)),null(),null());
HXLINE( 271)		UI->add(removeButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 272)		UI->add(this->animDropDown).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 274)		this->reloadImage =  ::Dynamic(new _hx_Closure_6(_gthis,setAnimDropDown,name_input,maxFps,indices_input,prefix_input,minFps));
            	}


HX_DEFINE_DYNAMIC_FUNC0(NoteSplashEditorState_obj,addAnimTab,(void))

void NoteSplashEditorState_obj::addPropertiesTab(){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::states::editors::NoteSplashEditorState,_gthis) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_333_addPropertiesTab)
HXLINE( 333)			_gthis->reloadImage();
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_1, ::states::editors::NoteSplashEditorState,_gthis, ::backend::ui::PsychUICheckBox,allowRGBCheck) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_357_addPropertiesTab)
HXLINE( 357)			if (::hx::IsNotNull( _gthis->config )) {
HXLINE( 358)				_gthis->config->__SetField(HX_("allowRGB",04,8e,17,9e),allowRGBCheck->checked,::hx::paccDynamic);
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_2, ::states::editors::NoteSplashEditorState,_gthis, ::backend::ui::PsychUICheckBox,allowPixelCheck) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_373_addPropertiesTab)
HXLINE( 373)			if (::hx::IsNotNull( _gthis->config )) {
HXLINE( 374)				_gthis->config->__SetField(HX_("allowPixel",3d,81,6f,ed),allowPixelCheck->checked,::hx::paccDynamic);
            			}
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_324_addPropertiesTab)
HXDLIN( 324)		 ::states::editors::NoteSplashEditorState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 325)		 ::flixel::group::FlxTypedSpriteGroup ui = this->properUI->getTab(HX_("Properties",13,00,c0,57))->menu;
HXLINE( 327)		ui->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,20,10,0,HX_("Image:",9f,c4,26,33),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 328)		this->imageInputText =  ::backend::ui::PsychUIInputText_obj::__alloc( HX_CTX ,60,10,120,::states::editors::NoteSplashEditorState_obj::imageSkin,8);
HXLINE( 329)		ui->add(this->imageInputText).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 331)		 ::backend::ui::PsychUIButton reloadButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,185,((Float)6.8),HX_("Reload Image",54,43,aa,83), ::Dynamic(new _hx_Closure_0(_gthis)),null(),null());
HXLINE( 335)		ui->add(reloadButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 337)		ui->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,20,40,null(),HX_("Scale:",90,5e,ba,70),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 338)		this->scaleNumericStepper =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,20,((Float)57.5),((Float)0.1),1,0,4,2,60,null());
HXLINE( 339)		ui->add(this->scaleNumericStepper).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 341)		Float _hx_tmp;
HXDLIN( 341)		if (::hx::IsNotNull( this->config )) {
HXLINE( 341)			_hx_tmp = ( (Float)(this->config->__Field(HX_("scale",8a,ce,ce,78),::hx::paccDynamic)) );
            		}
            		else {
HXLINE( 341)			_hx_tmp = ( (Float)(1) );
            		}
HXDLIN( 341)		this->scaleNumericStepper->set_value(_hx_tmp);
HXLINE( 343)		ui->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,130,40,null(),HX_("Animations:",4b,b4,c4,19),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 345)		 ::backend::ui::PsychUIButton saveButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,20,130,HX_("Save",5d,b7,26,37),this->saveSplash_dyn(),null(),null());
HXLINE( 346)		ui->add(saveButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 348)		this->templateButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,20,155,HX_("Template",5a,a4,f9,85),null(),null(),null());
HXLINE( 349)		ui->add(this->templateButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 351)		 ::backend::ui::PsychUIButton loadButton =  ::backend::ui::PsychUIButton_obj::__alloc( HX_CTX ,180,155,HX_("Convert TXT",83,e9,04,f8),this->loadTxt_dyn(),null(),null());
HXLINE( 352)		ui->add(loadButton).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 354)		 ::backend::ui::PsychUICheckBox allowRGBCheck =  ::backend::ui::PsychUICheckBox_obj::__alloc( HX_CTX ,( (Float)(20) ),( (Float)(105) ),HX_("",00,00,00,00),1,null());
HXLINE( 355)		 ::Dynamic check =  ::Dynamic(new _hx_Closure_1(_gthis,allowRGBCheck));
HXLINE( 360)		allowRGBCheck->onClick = check;
HXLINE( 361)		 ::Dynamic _hx_tmp1;
HXDLIN( 361)		bool _hx_tmp2;
HXDLIN( 361)		if (::hx::IsNotNull( this->config )) {
HXLINE( 361)			_hx_tmp2 = ::hx::IsNotNull( ( (bool)(this->config->__Field(HX_("allowRGB",04,8e,17,9e),::hx::paccDynamic)) ) );
            		}
            		else {
HXLINE( 361)			_hx_tmp2 = false;
            		}
HXDLIN( 361)		if (_hx_tmp2) {
HXLINE( 361)			_hx_tmp1 =  ::Dynamic(this->config->__Field(HX_("allowRGB",04,8e,17,9e),::hx::paccDynamic));
            		}
            		else {
HXLINE( 361)			_hx_tmp1 = false;
            		}
HXDLIN( 361)		allowRGBCheck->set_checked(_hx_tmp1);
HXLINE( 363)		 ::flixel::text::FlxText rgbText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,(allowRGBCheck->x + 20),0,null(),null(),null(),null());
HXLINE( 364)		rgbText->set_text(HX_("Allow RGB?",c9,77,8b,31));
HXLINE( 365)		rgbText->set_y((allowRGBCheck->y + ((Float)2.5)));
HXLINE( 366)		ui->add(rgbText).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 368)		ui->add(allowRGBCheck).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 370)		 ::backend::ui::PsychUICheckBox allowPixelCheck =  ::backend::ui::PsychUICheckBox_obj::__alloc( HX_CTX ,(allowRGBCheck->x + 110),allowRGBCheck->y,HX_("",00,00,00,00),1,null());
HXLINE( 371)		 ::Dynamic check1 =  ::Dynamic(new _hx_Closure_2(_gthis,allowPixelCheck));
HXLINE( 376)		allowPixelCheck->onClick = check1;
HXLINE( 377)		 ::Dynamic _hx_tmp3;
HXDLIN( 377)		bool _hx_tmp4;
HXDLIN( 377)		if (::hx::IsNotNull( this->config )) {
HXLINE( 377)			_hx_tmp4 = ::hx::IsNotNull( ( (bool)(this->config->__Field(HX_("allowPixel",3d,81,6f,ed),::hx::paccDynamic)) ) );
            		}
            		else {
HXLINE( 377)			_hx_tmp4 = false;
            		}
HXDLIN( 377)		if (_hx_tmp4) {
HXLINE( 377)			_hx_tmp3 =  ::Dynamic(this->config->__Field(HX_("allowPixel",3d,81,6f,ed),::hx::paccDynamic));
            		}
            		else {
HXLINE( 377)			_hx_tmp3 = false;
            		}
HXDLIN( 377)		allowPixelCheck->set_checked(_hx_tmp3);
HXLINE( 379)		 ::flixel::text::FlxText pixelText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,(allowPixelCheck->x + 20),0,null(),null(),null(),null());
HXLINE( 380)		pixelText->set_text(HX_("Allow Pixel?",f0,75,e7,2f));
HXLINE( 381)		pixelText->set_y((allowPixelCheck->y + ((Float)2.5)));
HXLINE( 382)		ui->add(pixelText).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 384)		ui->add(allowPixelCheck).StaticCast<  ::flixel::FlxSprite >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(NoteSplashEditorState_obj,addPropertiesTab,(void))

void NoteSplashEditorState_obj::addShadersTab(){
            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_0, ::states::editors::NoteSplashEditorState,_gthis, ::backend::ui::PsychUINumericStepper,red) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_405_addShadersTab)
HXLINE( 406)			int shader;
HXDLIN( 406)			::String _hx_switch_0 = _gthis->changeShader->selectedLabel;
            			if (  (_hx_switch_0==HX_("Green",a3,7e,1a,2d)) ){
HXLINE( 406)				shader = (_gthis->greenShader[0] = ::Std_obj::_hx_int(red->value));
HXDLIN( 406)				goto _hx_goto_26;
            			}
            			if (  (_hx_switch_0==HX_("Red",31,91,3e,00)) ){
HXLINE( 406)				shader = (_gthis->redShader[0] = ::Std_obj::_hx_int(red->value));
HXDLIN( 406)				goto _hx_goto_26;
            			}
            			/* default */{
HXLINE( 406)				shader = (_gthis->blueShader[0] = ::Std_obj::_hx_int(red->value));
            			}
            			_hx_goto_26:;
HXLINE( 412)			_gthis->setConfigRGB();
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_1, ::states::editors::NoteSplashEditorState,_gthis, ::backend::ui::PsychUINumericStepper,green) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_417_addShadersTab)
HXLINE( 418)			int shader;
HXDLIN( 418)			::String _hx_switch_1 = _gthis->changeShader->selectedLabel;
            			if (  (_hx_switch_1==HX_("Green",a3,7e,1a,2d)) ){
HXLINE( 418)				shader = (_gthis->greenShader[1] = ::Std_obj::_hx_int(green->value));
HXDLIN( 418)				goto _hx_goto_27;
            			}
            			if (  (_hx_switch_1==HX_("Red",31,91,3e,00)) ){
HXLINE( 418)				shader = (_gthis->redShader[1] = ::Std_obj::_hx_int(green->value));
HXDLIN( 418)				goto _hx_goto_27;
            			}
            			/* default */{
HXLINE( 418)				shader = (_gthis->blueShader[1] = ::Std_obj::_hx_int(green->value));
            			}
            			_hx_goto_27:;
HXLINE( 424)			_gthis->setConfigRGB();
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_2, ::states::editors::NoteSplashEditorState,_gthis, ::backend::ui::PsychUINumericStepper,blue) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_429_addShadersTab)
HXLINE( 430)			int shader;
HXDLIN( 430)			::String _hx_switch_2 = _gthis->changeShader->selectedLabel;
            			if (  (_hx_switch_2==HX_("Green",a3,7e,1a,2d)) ){
HXLINE( 430)				shader = (_gthis->greenShader[2] = ::Std_obj::_hx_int(blue->value));
HXDLIN( 430)				goto _hx_goto_28;
            			}
            			if (  (_hx_switch_2==HX_("Red",31,91,3e,00)) ){
HXLINE( 430)				shader = (_gthis->redShader[2] = ::Std_obj::_hx_int(blue->value));
HXDLIN( 430)				goto _hx_goto_28;
            			}
            			/* default */{
HXLINE( 430)				shader = (_gthis->blueShader[2] = ::Std_obj::_hx_int(blue->value));
            			}
            			_hx_goto_28:;
HXLINE( 436)			_gthis->setConfigRGB();
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_3, ::states::editors::NoteSplashEditorState,_gthis) HXARGC(1)
            		void _hx_run( ::Dynamic __o_change){
            		bool change = __o_change.Default(true);
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_441_addShadersTab)
HXLINE( 442)			if (!(_gthis->defaultButton->checked)) {
HXLINE( 443)				_gthis->shaderUI->set_alpha(( (Float)(1) ));
            			}
            			else {
HXLINE( 445)				_gthis->shaderUI->set_alpha(((Float)0.6));
            			}
HXLINE( 447)			if (change) {
HXLINE( 448)				::String _hx_switch_3 = _gthis->changeShader->selectedLabel;
            				if (  (_hx_switch_3==HX_("Blue",ba,6e,f2,2b)) ){
HXLINE( 452)					_gthis->blueEnabled = !(_gthis->defaultButton->checked);
HXDLIN( 452)					goto _hx_goto_29;
            				}
            				if (  (_hx_switch_3==HX_("Green",a3,7e,1a,2d)) ){
HXLINE( 451)					_gthis->greenEnabled = !(_gthis->defaultButton->checked);
HXDLIN( 451)					goto _hx_goto_29;
            				}
            				if (  (_hx_switch_3==HX_("Red",31,91,3e,00)) ){
HXLINE( 450)					_gthis->redEnabled = !(_gthis->defaultButton->checked);
HXDLIN( 450)					goto _hx_goto_29;
            				}
            				_hx_goto_29:;
            			}
HXLINE( 455)			_gthis->setConfigRGB();
            		}
            		HX_END_LOCAL_FUNC1((void))

            		HX_BEGIN_LOCAL_FUNC_S5(::hx::LocalFunc,_hx_Closure_4, ::states::editors::NoteSplashEditorState,_gthis, ::backend::ui::PsychUINumericStepper,blue, ::backend::ui::PsychUINumericStepper,green, ::backend::ui::PsychUINumericStepper,red, ::Dynamic,onCheck) HXARGC(2)
            		void _hx_run(int id,::String name){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_460_addShadersTab)
HXLINE( 461)			::Array< int > shader;
HXDLIN( 461)			::String _hx_switch_4 = name;
            			if (  (_hx_switch_4==HX_("Green",a3,7e,1a,2d)) ){
HXLINE( 461)				shader = _gthis->greenShader;
HXDLIN( 461)				goto _hx_goto_30;
            			}
            			if (  (_hx_switch_4==HX_("Red",31,91,3e,00)) ){
HXLINE( 461)				shader = _gthis->redShader;
HXDLIN( 461)				goto _hx_goto_30;
            			}
            			/* default */{
HXLINE( 461)				shader = _gthis->blueShader;
            			}
            			_hx_goto_30:;
HXLINE( 468)			red->set_value(( (Float)(shader->__get(0)) ));
HXLINE( 469)			green->set_value(( (Float)(shader->__get(1)) ));
HXLINE( 470)			blue->set_value(( (Float)(shader->__get(2)) ));
HXLINE( 473)			 ::Dynamic _hx_tmp;
HXDLIN( 473)			::String _hx_switch_5 = name;
            			if (  (_hx_switch_5==HX_("Green",a3,7e,1a,2d)) ){
HXLINE( 473)				_hx_tmp = !(_gthis->greenEnabled);
HXDLIN( 473)				goto _hx_goto_31;
            			}
            			if (  (_hx_switch_5==HX_("Red",31,91,3e,00)) ){
HXLINE( 473)				_hx_tmp = !(_gthis->redEnabled);
HXDLIN( 473)				goto _hx_goto_31;
            			}
            			/* default */{
HXLINE( 473)				_hx_tmp = !(_gthis->blueEnabled);
            			}
            			_hx_goto_31:;
HXDLIN( 473)			_gthis->defaultButton->set_checked(_hx_tmp);
HXLINE( 478)			onCheck(false);
            		}
            		HX_END_LOCAL_FUNC2((void))

            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_5, ::Dynamic,onCheck) HXARGC(0)
            		void _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_482_addShadersTab)
HXLINE( 482)			onCheck(null());
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_396_addShadersTab)
HXDLIN( 396)		 ::states::editors::NoteSplashEditorState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 397)		 ::flixel::group::FlxTypedSpriteGroup tab = this->shaderUI->getTab(HX_("Shader",45,33,b5,51))->menu;
HXLINE( 399)		tab->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,40,10,null(),HX_("Replacing Color:",86,e7,a4,a0),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 400)		tab->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,25,30,null(),HX_("Red:",e9,79,80,36),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 401)		tab->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,25,50,null(),HX_("Green:",37,50,14,4a),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 402)		tab->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,25,70,null(),HX_("Blue:",40,74,2e,48),null(),null())).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 404)		 ::backend::ui::PsychUINumericStepper red =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,60,30,1,this->redShader->__get(0),0,255,0,null(),null());
HXLINE( 405)		red->onValueChange =  ::Dynamic(new _hx_Closure_0(_gthis,red));
HXLINE( 414)		tab->add(red).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 416)		 ::backend::ui::PsychUINumericStepper green =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,60,50,1,this->redShader->__get(1),0,255,0,null(),null());
HXLINE( 417)		green->onValueChange =  ::Dynamic(new _hx_Closure_1(_gthis,green));
HXLINE( 426)		tab->add(green).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 428)		 ::backend::ui::PsychUINumericStepper blue =  ::backend::ui::PsychUINumericStepper_obj::__alloc( HX_CTX ,60,70,1,this->redShader->__get(2),0,255,0,null(),null());
HXLINE( 429)		blue->onValueChange =  ::Dynamic(new _hx_Closure_2(_gthis,blue));
HXLINE( 438)		tab->add(blue).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 440)		 ::Dynamic onCheck =  ::Dynamic(new _hx_Closure_3(_gthis));
HXLINE( 458)		this->add( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,(this->shaderUI->x + 20),(this->shaderUI->y + 135),0,HX_("Color to Replace:",8e,42,ae,43),null(),null()));
HXLINE( 459)		this->changeShader =  ::backend::ui::PsychUIDropDownMenu_obj::__alloc( HX_CTX ,(this->shaderUI->x + 20),(this->shaderUI->y + 150),::Array_obj< ::String >::fromData( _hx_array_data_8c409617_39,3), ::Dynamic(new _hx_Closure_4(_gthis,blue,green,red,onCheck)),null());
HXLINE( 480)		this->add(this->changeShader);
HXLINE( 482)		this->defaultButton =  ::backend::ui::PsychUICheckBox_obj::__alloc( HX_CTX ,(this->shaderUI->x + 30),(this->shaderUI->y + 115),HX_("Do not replace",32,74,24,53),100, ::Dynamic(new _hx_Closure_5(onCheck)));
HXLINE( 483)		 ::flixel::text::FlxText fh = this->defaultButton->text;
HXDLIN( 483)		fh->set_y((fh->y + ((Float)2.5)));
HXLINE( 484)		this->add(this->defaultButton);
HXLINE( 486)		this->changeShader->set_selectedLabel(HX_("Red",31,91,3e,00));
HXLINE( 487)		this->changeShader->onSelect(0,HX_("Red",31,91,3e,00));
            	}


HX_DEFINE_DYNAMIC_FUNC0(NoteSplashEditorState_obj,addShadersTab,(void))

HX_BEGIN_DEFAULT_FUNC(__default_reloadImage,NoteSplashEditorState_obj)
void _hx_run(){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_491___default_reloadImage)
            	}
HX_END_LOCAL_FUNC0((void))
HX_END_DEFAULT_FUNC

void NoteSplashEditorState_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_499_update)
HXDLIN( 499)		 ::states::editors::NoteSplashEditorState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 500)		this->super::update(elapsed);
HXLINE( 502)		 ::flixel::text::FlxText _hx_tmp = this->errorText;
HXDLIN( 502)		int _hx_tmp1 = ::flixel::FlxG_obj::width;
HXDLIN( 502)		_hx_tmp->set_x(((( (Float)(_hx_tmp1) ) - this->errorText->get_width()) - ( (Float)(5) )));
HXLINE( 504)		 ::flixel::text::FlxText _hx_tmp2 = this->curText;
HXDLIN( 504)		_hx_tmp2->set_text(((HX_("Copied Offsets: ",4a,98,e1,b6) + ::StringTools_obj::replace(::Std_obj::string(this->copiedOffset),HX_(",",2c,00,00,00),HX_(", ",74,26,00,00))) + HX_("\n",0a,00,00,00)));
HXLINE( 505)		 ::flixel::text::FlxText fh = this->curText;
HXDLIN( 505)		::String _hx_tmp3;
HXDLIN( 505)		bool _hx_tmp4;
HXDLIN( 505)		if (::hx::IsNotNull( this->curAnim )) {
HXLINE( 505)			_hx_tmp4 = (this->curAnim.length < 1);
            		}
            		else {
HXLINE( 505)			_hx_tmp4 = true;
            		}
HXDLIN( 505)		if (_hx_tmp4) {
HXLINE( 505)			_hx_tmp3 = HX_("NONE",b8,da,ca,33);
            		}
            		else {
HXLINE( 505)			_hx_tmp3 = this->curAnim;
            		}
HXDLIN( 505)		fh->set_text((fh->text + (HX_("Current Animation: ",03,3c,c9,18) + _hx_tmp3)));
HXLINE( 507)		bool _hx_tmp5;
HXDLIN( 507)		if (::hx::IsNotNull( this->config )) {
HXLINE( 507)			_hx_tmp5 = (this->curText->text.indexOf(HX_("NONE",b8,da,ca,33),null()) == -1);
            		}
            		else {
HXLINE( 507)			_hx_tmp5 = false;
            		}
HXDLIN( 507)		if (_hx_tmp5) {
HXLINE( 509)			::Array< Float > offsets;
HXDLIN( 509)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 509)				offsets = ( (::Array< Float >)(( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(this->curAnim)->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) );
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g = _hx_e;
HXLINE( 509)					offsets = ::Array_obj< Float >::fromData( _hx_array_data_8c409617_44,2);
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
HXLINE( 510)			 ::flixel::text::FlxText fh1 = this->curText;
HXDLIN( 510)			::String fh2 = fh1->text;
HXDLIN( 510)			fh1->set_text((fh2 + ::StringTools_obj::replace(((HX_(" (",08,1c,00,00) + ::Std_obj::string(offsets)) + HX_(")",29,00,00,00)),HX_(",",2c,00,00,00),HX_(", ",74,26,00,00))));
            		}
HXLINE( 513)		if (::hx::IsNotNull( this->config )) {
HXLINE( 515)			::String currentAnim = this->curAnimText->text;
HXLINE( 516)			bool _hx_tmp6;
HXDLIN( 516)			if (( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->exists(currentAnim)) {
HXLINE( 516)				_hx_tmp6 = ::hx::IsNotNull( ( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(currentAnim) );
            			}
            			else {
HXLINE( 516)				_hx_tmp6 = false;
            			}
HXDLIN( 516)			if (_hx_tmp6) {
HXLINE( 517)				this->addButton->set_label(HX_("Update",29,fa,99,bb));
            			}
            			else {
HXLINE( 519)				this->addButton->set_label(HX_("Add",01,aa,31,00));
            			}
HXLINE( 521)			this->config->__SetField(HX_("scale",8a,ce,ce,78),this->scaleNumericStepper->value,::hx::paccDynamic);
            		}
HXLINE( 524)		bool blockInput = ::hx::IsNotNull( ::backend::ui::PsychUIInputText_obj::focusOn );
HXLINE( 525)		bool _hx_tmp7;
HXDLIN( 525)		bool _hx_tmp8;
HXDLIN( 525)		bool _hx_tmp9;
HXDLIN( 525)		bool _hx_tmp10;
HXDLIN( 525)		bool _hx_tmp11;
HXDLIN( 525)		if (!(blockInput)) {
HXLINE( 525)			_hx_tmp11 = ::hx::IsNotNull( this->config );
            		}
            		else {
HXLINE( 525)			_hx_tmp11 = false;
            		}
HXDLIN( 525)		if (_hx_tmp11) {
HXLINE( 525)			_hx_tmp10 = ::hx::IsNotNull( this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic) );
            		}
            		else {
HXLINE( 525)			_hx_tmp10 = false;
            		}
HXDLIN( 525)		if (_hx_tmp10) {
HXLINE( 525)			_hx_tmp9 = ( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->exists(this->curAnim);
            		}
            		else {
HXLINE( 525)			_hx_tmp9 = false;
            		}
HXDLIN( 525)		if (_hx_tmp9) {
HXLINE( 525)			_hx_tmp8 = ::hx::IsNotNull( this->curAnim );
            		}
            		else {
HXLINE( 525)			_hx_tmp8 = false;
            		}
HXDLIN( 525)		if (_hx_tmp8) {
HXLINE( 525)			_hx_tmp7 = (this->curAnim.length > 0);
            		}
            		else {
HXLINE( 525)			_hx_tmp7 = false;
            		}
HXDLIN( 525)		if (_hx_tmp7) {
            			HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::states::editors::NoteSplashEditorState,_gthis) HXARGC(0)
            			void _hx_run(){
            				HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_529_update)
HXLINE( 529)				if (::hx::IsNotNull( ( ( ::haxe::ds::StringMap)( ::Dynamic(_gthis->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(_gthis->curAnim) )) {
HXLINE( 531)					 ::states::editors::NoteSplashEditorState _gthis1 = _gthis;
HXDLIN( 531)					::String _gthis2 = _gthis->curAnim;
HXDLIN( 531)					_gthis1->playStrumAnim(_gthis2,( (int)(( ( ::haxe::ds::StringMap)( ::Dynamic(_gthis->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(_gthis->curAnim)->__Field(HX_("noteData",3c,7b,96,51),::hx::paccDynamic)) ));
HXLINE( 532)					::flixel::tweens::FlxTween_obj::cancelTweensOf(_gthis->errorText,null());
HXLINE( 533)					_gthis->errorText->set_alpha(( (Float)(0) ));
            				}
            			}
            			HX_END_LOCAL_FUNC0((void))

HXLINE( 527)			 ::Dynamic splash =  ::Dynamic(new _hx_Closure_0(_gthis));
HXLINE( 537)			bool changedOffset = false;
HXLINE( 538)			bool _hx_tmp12;
HXDLIN( 538)			 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 538)			if (_this->keyManager->checkStatusUnsafe(17,_this->status)) {
HXLINE( 538)				_hx_tmp12 = ::hx::IsNotNull( ( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(this->curAnim) );
            			}
            			else {
HXLINE( 538)				_hx_tmp12 = false;
            			}
HXDLIN( 538)			if (_hx_tmp12) {
HXLINE( 540)				 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 540)				if (_this1->keyManager->checkStatusUnsafe(67,_this1->status)) {
HXLINE( 542)					this->copiedOffset = ( (::Array< Float >)(( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(this->curAnim)->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) )->copy();
            				}
            				else {
HXLINE( 544)					 ::flixel::input::keyboard::FlxKeyList _this2 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 544)					if (_this2->keyManager->checkStatusUnsafe(86,_this2->status)) {
HXLINE( 546)						 ::Dynamic conf = ( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(this->curAnim);
HXLINE( 547)						conf->__SetField(HX_("offsets",80,09,65,d7),this->copiedOffset->copy(),::hx::paccDynamic);
HXLINE( 548)						( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->set(this->curAnim,conf);
HXLINE( 549)						changedOffset = true;
            					}
            					else {
HXLINE( 551)						 ::flixel::input::keyboard::FlxKeyList _this3 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 551)						if (_this3->keyManager->checkStatusUnsafe(82,_this3->status)) {
HXLINE( 553)							 ::Dynamic conf1 = ( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(this->curAnim);
HXLINE( 554)							conf1->__SetField(HX_("offsets",80,09,65,d7),::Array_obj< Float >::fromData( _hx_array_data_8c409617_46,2),::hx::paccDynamic);
HXLINE( 555)							( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->set(this->curAnim,conf1);
HXLINE( 556)							changedOffset = true;
            						}
            					}
            				}
            			}
HXLINE( 560)			int multiplier;
HXDLIN( 560)			bool multiplier1;
HXDLIN( 560)			 ::flixel::input::keyboard::FlxKeyList _this4 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 560)			if (!(_this4->keyManager->checkStatusUnsafe(16,_this4->status))) {
HXLINE( 560)				multiplier1 = ::flixel::FlxG_obj::gamepads->anyHasState(4,1);
            			}
            			else {
HXLINE( 560)				multiplier1 = true;
            			}
HXDLIN( 560)			if (multiplier1) {
HXLINE( 560)				multiplier = 10;
            			}
            			else {
HXLINE( 560)				multiplier = 1;
            			}
HXLINE( 562)			 ::flixel::input::keyboard::FlxKeyList _this5 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 562)			bool moveKeysP = _this5->keyManager->checkStatusUnsafe(37,_this5->status);
HXDLIN( 562)			 ::flixel::input::keyboard::FlxKeyList _this6 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 562)			bool moveKeysP1 = _this6->keyManager->checkStatusUnsafe(39,_this6->status);
HXDLIN( 562)			 ::flixel::input::keyboard::FlxKeyList _this7 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 562)			bool moveKeysP2 = _this7->keyManager->checkStatusUnsafe(38,_this7->status);
HXDLIN( 562)			 ::flixel::input::keyboard::FlxKeyList _this8 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 562)			::Array< bool > moveKeysP3 = ::Array_obj< bool >::__new(4)->init(0,moveKeysP)->init(1,moveKeysP1)->init(2,moveKeysP2)->init(3,_this8->keyManager->checkStatusUnsafe(40,_this8->status));
HXLINE( 563)			if (moveKeysP3->contains(true)) {
HXLINE( 565)				::Array< Float > base = ( (::Array< Float >)(( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(this->curAnim)->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) );
HXDLIN( 565)				int _hx_tmp13 = 0;
HXDLIN( 565)				int _hx_tmp14;
HXDLIN( 565)				if (moveKeysP3->__get(0)) {
HXLINE( 565)					_hx_tmp14 = 1;
            				}
            				else {
HXLINE( 565)					_hx_tmp14 = 0;
            				}
HXDLIN( 565)				int _hx_tmp15;
HXDLIN( 565)				if (moveKeysP3->__get(1)) {
HXLINE( 565)					_hx_tmp15 = 1;
            				}
            				else {
HXLINE( 565)					_hx_tmp15 = 0;
            				}
HXDLIN( 565)				base[_hx_tmp13] = (base->__get(_hx_tmp13) + ((_hx_tmp14 - _hx_tmp15) * multiplier));
HXLINE( 566)				::Array< Float > base1 = ( (::Array< Float >)(( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(this->curAnim)->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) );
HXDLIN( 566)				int _hx_tmp16 = 1;
HXDLIN( 566)				int _hx_tmp17;
HXDLIN( 566)				if (moveKeysP3->__get(2)) {
HXLINE( 566)					_hx_tmp17 = 1;
            				}
            				else {
HXLINE( 566)					_hx_tmp17 = 0;
            				}
HXDLIN( 566)				int _hx_tmp18;
HXDLIN( 566)				if (moveKeysP3->__get(3)) {
HXLINE( 566)					_hx_tmp18 = 1;
            				}
            				else {
HXLINE( 566)					_hx_tmp18 = 0;
            				}
HXDLIN( 566)				base1[_hx_tmp16] = (base1->__get(_hx_tmp16) + ((_hx_tmp17 - _hx_tmp18) * multiplier));
HXLINE( 567)				changedOffset = true;
            			}
HXLINE( 570)			 ::flixel::input::keyboard::FlxKeyList _this9 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 570)			bool moveKeys = _this9->keyManager->checkStatusUnsafe(37,_this9->status);
HXDLIN( 570)			 ::flixel::input::keyboard::FlxKeyList _this10 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 570)			bool moveKeys1 = _this10->keyManager->checkStatusUnsafe(39,_this10->status);
HXDLIN( 570)			 ::flixel::input::keyboard::FlxKeyList _this11 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 570)			bool moveKeys2 = _this11->keyManager->checkStatusUnsafe(38,_this11->status);
HXDLIN( 570)			 ::flixel::input::keyboard::FlxKeyList _this12 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 570)			::Array< bool > moveKeys3 = ::Array_obj< bool >::__new(4)->init(0,moveKeys)->init(1,moveKeys1)->init(2,moveKeys2)->init(3,_this12->keyManager->checkStatusUnsafe(40,_this12->status));
HXLINE( 571)			if (moveKeys3->contains(true)) {
HXLINE( 573)				 ::states::editors::NoteSplashEditorState _hx_tmp19 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 573)				_hx_tmp19->holdingArrowsTime = (_hx_tmp19->holdingArrowsTime + elapsed);
HXLINE( 574)				if ((this->holdingArrowsTime > ((Float)0.6))) {
HXLINE( 576)					 ::states::editors::NoteSplashEditorState _hx_tmp20 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 576)					_hx_tmp20->holdingArrowsElapsed = (_hx_tmp20->holdingArrowsElapsed + elapsed);
HXLINE( 577)					while((this->holdingArrowsElapsed > ((Float)0.016666666666666666))){
HXLINE( 579)						::Array< Float > base2 = ( (::Array< Float >)(( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(this->curAnim)->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) );
HXDLIN( 579)						int _hx_tmp21 = 0;
HXDLIN( 579)						int _hx_tmp22;
HXDLIN( 579)						if (moveKeys3->__get(0)) {
HXLINE( 579)							_hx_tmp22 = 1;
            						}
            						else {
HXLINE( 579)							_hx_tmp22 = 0;
            						}
HXDLIN( 579)						int _hx_tmp23;
HXDLIN( 579)						if (moveKeys3->__get(1)) {
HXLINE( 579)							_hx_tmp23 = 1;
            						}
            						else {
HXLINE( 579)							_hx_tmp23 = 0;
            						}
HXDLIN( 579)						base2[_hx_tmp21] = (base2->__get(_hx_tmp21) + ((_hx_tmp22 - _hx_tmp23) * multiplier));
HXLINE( 580)						::Array< Float > base3 = ( (::Array< Float >)(( ( ::haxe::ds::StringMap)( ::Dynamic(this->config->__Field(HX_("animations",ef,34,1c,83),::hx::paccDynamic))) )->get(this->curAnim)->__Field(HX_("offsets",80,09,65,d7),::hx::paccDynamic)) );
HXDLIN( 580)						int _hx_tmp24 = 1;
HXDLIN( 580)						int _hx_tmp25;
HXDLIN( 580)						if (moveKeys3->__get(2)) {
HXLINE( 580)							_hx_tmp25 = 1;
            						}
            						else {
HXLINE( 580)							_hx_tmp25 = 0;
            						}
HXDLIN( 580)						int _hx_tmp26;
HXDLIN( 580)						if (moveKeys3->__get(3)) {
HXLINE( 580)							_hx_tmp26 = 1;
            						}
            						else {
HXLINE( 580)							_hx_tmp26 = 0;
            						}
HXDLIN( 580)						base3[_hx_tmp24] = (base3->__get(_hx_tmp24) + ((_hx_tmp25 - _hx_tmp26) * multiplier));
HXLINE( 581)						 ::states::editors::NoteSplashEditorState _hx_tmp27 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 581)						_hx_tmp27->holdingArrowsElapsed = (_hx_tmp27->holdingArrowsElapsed - ((Float)0.016666666666666666));
HXLINE( 582)						changedOffset = true;
            					}
            				}
            			}
            			else {
HXLINE( 586)				this->holdingArrowsTime = ( (Float)(0) );
            			}
HXLINE( 588)			bool _hx_tmp28;
HXDLIN( 588)			if (!(changedOffset)) {
HXLINE( 588)				 ::flixel::input::keyboard::FlxKeyList _this13 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 588)				_hx_tmp28 = _this13->keyManager->checkStatusUnsafe(32,_this13->status);
            			}
            			else {
HXLINE( 588)				_hx_tmp28 = true;
            			}
HXDLIN( 588)			if (_hx_tmp28) {
HXLINE( 588)				splash();
            			}
            		}
HXLINE( 591)		if (!(blockInput)) {
HXLINE( 593)			if (this->get_controls()->get_BACK()) {
HXLINE( 594)				::backend::MusicBeatState_obj::switchState( ::states::editors::MasterEditorMenu_obj::__alloc( HX_CTX ));
            			}
HXLINE( 595)			 ::flixel::input::keyboard::FlxKeyList _this14 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 595)			if (_this14->keyManager->checkStatusUnsafe(112,_this14->status)) {
HXLINE( 596)				this->openSubState( ::states::editors::NoteSplashEditorHelpSubState_obj::__alloc( HX_CTX ));
            			}
            		}
HXLINE( 599)		if (::flixel::FlxG_obj::mouse->overlaps(this->strums,null())) {
            			HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::states::editors::NoteSplashEditorState,_gthis) HXARGC(1)
            			void _hx_run( ::objects::StrumNote strum){
            				HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_603_update)
HXLINE( 603)				if (::flixel::FlxG_obj::mouse->overlaps(strum,null())) {
HXLINE( 605)					if ((::flixel::FlxG_obj::mouse->_leftButton->current != 2)) {
HXLINE( 607)						bool _hx_tmp;
HXDLIN( 607)						if ((strum->animation->_curAnim->name != HX_("pressed",a2,d2,e6,39))) {
HXLINE( 607)							_hx_tmp = (strum->animation->_curAnim->name != HX_("confirm",00,9d,39,10));
            						}
            						else {
HXLINE( 607)							_hx_tmp = false;
            						}
HXDLIN( 607)						if (_hx_tmp) {
HXLINE( 608)							strum->playAnim(HX_("pressed",a2,d2,e6,39),null());
            						}
            					}
            					else {
HXLINE( 612)						strum->playAnim(HX_("confirm",00,9d,39,10),true);
HXLINE( 615)						 ::objects::NoteSplash splash =  ::objects::NoteSplash_obj::__alloc( HX_CTX ,0,0,::states::editors::NoteSplashEditorState_obj::imageSkin);
HXLINE( 616)						splash->inEditor = true;
HXLINE( 617)						splash->set_config(_gthis->config);
HXLINE( 618)						splash->babyArrow = strum;
HXLINE( 619)						splash->spawnSplashNote(0,0,::hx::Mod(strum->ID,4),null(),null());
HXLINE( 620)						_gthis->splashes->add(splash).StaticCast<  ::objects::NoteSplash >();
            					}
            				}
            				else {
HXLINE( 623)					strum->playAnim(HX_("static",ae,dc,fb,05),null());
            				}
            			}
            			HX_END_LOCAL_FUNC1((void))

HXLINE( 601)			this->strums->group->forEach( ::Dynamic(new _hx_Closure_1(_gthis)),false);
            		}
            		else {
HXLINE( 628)			 ::Dynamic filter = null();
HXDLIN( 628)			 ::flixel::group::FlxTypedGroupIterator strum =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->strums->group->members,filter);
HXDLIN( 628)			while(strum->hasNext()){
HXLINE( 628)				 ::objects::StrumNote strum1 = strum->next().StaticCast<  ::objects::StrumNote >();
HXLINE( 629)				strum1->playAnim(HX_("static",ae,dc,fb,05),null());
            			}
            		}
            	}


void NoteSplashEditorState_obj::playStrumAnim(::String name,int noteData){
            	HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_634_playStrumAnim)
HXLINE( 635)		 ::objects::NoteSplash splash =  ::objects::NoteSplash_obj::__alloc( HX_CTX ,0,0,::states::editors::NoteSplashEditorState_obj::imageSkin);
HXLINE( 636)		splash->inEditor = true;
HXLINE( 637)		splash->set_config(this->config);
HXLINE( 638)		if ((noteData < 0)) {
HXLINE( 638)			noteData = 0;
            		}
HXLINE( 640)		bool _hx_tmp;
HXDLIN( 640)		if (::hx::IsNotNull( name )) {
HXLINE( 640)			_hx_tmp = splash->animation->exists(name);
            		}
            		else {
HXLINE( 640)			_hx_tmp = false;
            		}
HXDLIN( 640)		if (_hx_tmp) {
HXLINE( 642)			splash->babyArrow = Dynamic( this->strums->group->members->__get(::hx::Mod(noteData,4))).StaticCast<  ::objects::StrumNote >();
HXLINE( 643)			splash->spawnSplashNote(0,0,noteData,null(),false);
HXLINE( 644)			splash->set_alpha(( (Float)(1) ));
HXLINE( 645)			this->splashes->add(splash).StaticCast<  ::objects::NoteSplash >();
            		}
            		else {
HXLINE( 649)			this->errorText->set_alpha(( (Float)(1) ));
HXLINE( 650)			this->errorText->set_text(HX_("ERROR while playing splash",e0,72,87,e4));
HXLINE( 652)			::flixel::tweens::FlxTween_obj::cancelTweensOf(this->errorText,null());
HXLINE( 653)			::flixel::tweens::FlxTween_obj::tween(this->errorText, ::Dynamic(::hx::Anon_obj::Create(1)
            				->setFixed(0,HX_("alpha",5e,a7,96,21),0)),null(), ::Dynamic(::hx::Anon_obj::Create(1)
            				->setFixed(0,HX_("startDelay",c1,af,3d,f3),1)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(NoteSplashEditorState_obj,playStrumAnim,(void))

void NoteSplashEditorState_obj::resetRGB(){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_658_resetRGB)
HXLINE( 659)		this->redShader = ::Array_obj< int >::fromData( _hx_array_data_8c409617_50,3);
HXLINE( 660)		this->greenShader = ::Array_obj< int >::fromData( _hx_array_data_8c409617_51,3);
HXLINE( 661)		this->blueShader = ::Array_obj< int >::fromData( _hx_array_data_8c409617_52,3);
            	}


HX_DEFINE_DYNAMIC_FUNC0(NoteSplashEditorState_obj,resetRGB,(void))

void NoteSplashEditorState_obj::parseRGB(){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_665_parseRGB)
HXLINE( 666)		this->resetRGB();
HXLINE( 667)		if (::hx::IsNotNull( this->config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic) )) {
HXLINE( 668)			int _g = 0;
HXDLIN( 668)			int _g1 = ( (::Array< ::Dynamic>)(this->config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic)) )->length;
HXDLIN( 668)			while((_g < _g1)){
HXLINE( 668)				_g = (_g + 1);
HXDLIN( 668)				int i = (_g - 1);
HXLINE( 670)				if ((i > 2)) {
HXLINE( 670)					goto _hx_goto_53;
            				}
HXLINE( 672)				 ::Dynamic rgb =  ::Dynamic(this->config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic))->__GetItem(i);
HXLINE( 673)				if (::hx::IsNull( rgb )) {
HXLINE( 675)					if ((i == 0)) {
HXLINE( 676)						this->redEnabled = false;
            					}
            					else {
HXLINE( 677)						if ((i == 1)) {
HXLINE( 678)							this->greenEnabled = false;
            						}
            						else {
HXLINE( 679)							if ((i == 2)) {
HXLINE( 680)								this->blueEnabled = false;
            							}
            						}
            					}
HXLINE( 682)					continue;
            				}
            				else {
HXLINE( 686)					if ((i == 0)) {
HXLINE( 687)						this->redEnabled = true;
            					}
            					else {
HXLINE( 688)						if ((i == 1)) {
HXLINE( 689)							this->greenEnabled = true;
            						}
            						else {
HXLINE( 690)							if ((i == 2)) {
HXLINE( 691)								this->blueEnabled = true;
            							}
            						}
            					}
            				}
HXLINE( 694)				::Array< ::Dynamic> colors = ::Array_obj< ::Dynamic>::__new(3)->init(0, ::Dynamic(rgb->__Field(HX_("r",72,00,00,00),::hx::paccDynamic)))->init(1, ::Dynamic(rgb->__Field(HX_("g",67,00,00,00),::hx::paccDynamic)))->init(2, ::Dynamic(rgb->__Field(HX_("b",62,00,00,00),::hx::paccDynamic)));
HXLINE( 695)				if ((i == 0)) {
HXLINE( 696)					this->redShader = colors;
            				}
            				else {
HXLINE( 697)					if ((i == 1)) {
HXLINE( 698)						this->greenShader = colors;
            					}
            					else {
HXLINE( 699)						if ((i == 2)) {
HXLINE( 700)							this->blueShader = colors;
            						}
            					}
            				}
            			}
            			_hx_goto_53:;
            		}
            		else {
HXLINE( 704)			this->resetRGB();
HXLINE( 705)			this->redEnabled = (this->blueEnabled = (this->greenEnabled = false));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(NoteSplashEditorState_obj,parseRGB,(void))

void NoteSplashEditorState_obj::setConfigRGB(){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_710_setConfigRGB)
HXLINE( 711)		if (::hx::IsNull( this->config )) {
HXLINE( 712)			this->config = ::objects::NoteSplash_obj::createConfig();
            		}
HXLINE( 714)		bool _hx_tmp;
HXDLIN( 714)		bool _hx_tmp1;
HXDLIN( 714)		if (!(this->redEnabled)) {
HXLINE( 714)			_hx_tmp1 = !(this->greenEnabled);
            		}
            		else {
HXLINE( 714)			_hx_tmp1 = false;
            		}
HXDLIN( 714)		if (_hx_tmp1) {
HXLINE( 714)			_hx_tmp = !(this->blueEnabled);
            		}
            		else {
HXLINE( 714)			_hx_tmp = false;
            		}
HXDLIN( 714)		if (_hx_tmp) {
HXLINE( 716)			this->config->__SetField(HX_("rgb",0d,db,56,00),null(),::hx::paccDynamic);
HXLINE( 717)			return;
            		}
HXLINE( 720)		this->config->__SetField(HX_("rgb",0d,db,56,00),::Array_obj< ::Dynamic>::__new(0),::hx::paccDynamic);
HXLINE( 722)		if (this->redEnabled) {
HXLINE( 723)			( (::Array< ::Dynamic>)(this->config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic)) )->push( ::Dynamic(::hx::Anon_obj::Create(3)
            				->setFixed(0,HX_("b",62,00,00,00),this->redShader->__get(2))
            				->setFixed(1,HX_("g",67,00,00,00),this->redShader->__get(1))
            				->setFixed(2,HX_("r",72,00,00,00),this->redShader->__get(0))));
            		}
            		else {
HXLINE( 725)			( (::Array< ::Dynamic>)(this->config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic)) )->push(null());
            		}
HXLINE( 727)		if (this->greenEnabled) {
HXLINE( 728)			( (::Array< ::Dynamic>)(this->config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic)) )->push( ::Dynamic(::hx::Anon_obj::Create(3)
            				->setFixed(0,HX_("b",62,00,00,00),this->greenShader->__get(2))
            				->setFixed(1,HX_("g",67,00,00,00),this->greenShader->__get(1))
            				->setFixed(2,HX_("r",72,00,00,00),this->greenShader->__get(0))));
            		}
            		else {
HXLINE( 730)			( (::Array< ::Dynamic>)(this->config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic)) )->push(null());
            		}
HXLINE( 732)		if (this->blueEnabled) {
HXLINE( 733)			( (::Array< ::Dynamic>)(this->config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic)) )->push( ::Dynamic(::hx::Anon_obj::Create(3)
            				->setFixed(0,HX_("b",62,00,00,00),this->blueShader->__get(2))
            				->setFixed(1,HX_("g",67,00,00,00),this->blueShader->__get(1))
            				->setFixed(2,HX_("r",72,00,00,00),this->blueShader->__get(0))));
            		}
            		else {
HXLINE( 735)			( (::Array< ::Dynamic>)(this->config->__Field(HX_("rgb",0d,db,56,00),::hx::paccDynamic)) )->push(null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(NoteSplashEditorState_obj,setConfigRGB,(void))

void NoteSplashEditorState_obj::onSaveComplete( ::openfl::events::Event _){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_740_onSaveComplete)
HXLINE( 741)		this->_file->removeEventListener(HX_("complete",b9,00,c8,7f),this->onSaveComplete_dyn(),null());
HXLINE( 742)		this->_file->removeEventListener(HX_("cancel",7a,ed,33,b8),this->onSaveCancel_dyn(),null());
HXLINE( 743)		this->_file->removeEventListener(HX_("ioError",02,fe,41,76),this->onSaveError_dyn(),null());
HXLINE( 744)		this->_file = null();
HXLINE( 745)		::flixel::FlxG_obj::log->advanced(HX_("Successfully saved file.",c0,0d,09,f4),::flixel::_hx_system::debug::log::LogStyle_obj::NOTICE,null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NoteSplashEditorState_obj,onSaveComplete,(void))

void NoteSplashEditorState_obj::onSaveCancel( ::openfl::events::Event _){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_752_onSaveCancel)
HXLINE( 753)		this->_file->removeEventListener(HX_("complete",b9,00,c8,7f),this->onSaveComplete_dyn(),null());
HXLINE( 754)		this->_file->removeEventListener(HX_("cancel",7a,ed,33,b8),this->onSaveCancel_dyn(),null());
HXLINE( 755)		this->_file->removeEventListener(HX_("ioError",02,fe,41,76),this->onSaveError_dyn(),null());
HXLINE( 756)		this->_file = null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(NoteSplashEditorState_obj,onSaveCancel,(void))

void NoteSplashEditorState_obj::onSaveError( ::openfl::events::IOErrorEvent _){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_763_onSaveError)
HXLINE( 764)		this->_file->removeEventListener(HX_("complete",b9,00,c8,7f),this->onSaveComplete_dyn(),null());
HXLINE( 765)		this->_file->removeEventListener(HX_("cancel",7a,ed,33,b8),this->onSaveCancel_dyn(),null());
HXLINE( 766)		this->_file->removeEventListener(HX_("ioError",02,fe,41,76),this->onSaveError_dyn(),null());
HXLINE( 767)		this->_file = null();
HXLINE( 768)		::flixel::FlxG_obj::log->advanced(HX_("Problem saving file",41,4c,cd,8e),::flixel::_hx_system::debug::log::LogStyle_obj::ERROR,true);
            	}


HX_DEFINE_DYNAMIC_FUNC1(NoteSplashEditorState_obj,onSaveError,(void))

void NoteSplashEditorState_obj::saveSplash(){
            	HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_772_saveSplash)
HXLINE( 773)		::states::editors::NoteSplashEditorState_obj::imageSkin = this->imageInputText->text;
HXLINE( 774)		 ::Dynamic replacer = null();
HXDLIN( 774)		::String data = ::haxe::format::JsonPrinter_obj::print(this->config,replacer,HX_("\t",09,00,00,00));
HXLINE( 775)		if ((data.length > 0)) {
HXLINE( 777)			this->_file =  ::openfl::net::FileReference_obj::__alloc( HX_CTX );
HXLINE( 778)			this->_file->addEventListener(HX_("complete",b9,00,c8,7f),this->onSaveComplete_dyn(),null(),null(),null());
HXLINE( 779)			this->_file->addEventListener(HX_("cancel",7a,ed,33,b8),this->onSaveCancel_dyn(),null(),null(),null());
HXLINE( 780)			this->_file->addEventListener(HX_("ioError",02,fe,41,76),this->onSaveError_dyn(),null(),null(),null());
HXLINE( 781)			this->_file->save(data,(::states::editors::NoteSplashEditorState_obj::imageSkin + HX_(".json",56,f1,d6,c2)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(NoteSplashEditorState_obj,saveSplash,(void))

void NoteSplashEditorState_obj::loadTxt(){
            	HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_786_loadTxt)
HXLINE( 787)		 ::openfl::net::FileFilter jsonFilter =  ::openfl::net::FileFilter_obj::__alloc( HX_CTX ,HX_("Select a note splash TXT",c2,08,17,1e),HX_("*.txt",2c,9c,94,4d),null());
HXLINE( 788)		this->_file =  ::openfl::net::FileReference_obj::__alloc( HX_CTX );
HXLINE( 789)		this->_file->addEventListener(HX_("select",fc,1a,33,6a),this->onLoadComplete_dyn(),null(),null(),null());
HXLINE( 790)		this->_file->addEventListener(HX_("cancel",7a,ed,33,b8),this->onLoadCancel_dyn(),null(),null(),null());
HXLINE( 791)		this->_file->addEventListener(HX_("ioError",02,fe,41,76),this->onLoadError_dyn(),null(),null(),null());
HXLINE( 792)		this->_file->browse(::Array_obj< ::Dynamic>::__new(1)->init(0,jsonFilter));
            	}


HX_DEFINE_DYNAMIC_FUNC0(NoteSplashEditorState_obj,loadTxt,(void))

void NoteSplashEditorState_obj::onLoadComplete( ::openfl::events::Event _){
            	HX_GC_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_796_onLoadComplete)
HXLINE( 797)		this->_file->removeEventListener(HX_("select",fc,1a,33,6a),this->onLoadComplete_dyn(),null());
HXLINE( 798)		this->_file->removeEventListener(HX_("cancel",7a,ed,33,b8),this->onLoadCancel_dyn(),null());
HXLINE( 799)		this->_file->removeEventListener(HX_("ioError",02,fe,41,76),this->onLoadError_dyn(),null());
HXLINE( 801)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 803)			 ::Dynamic replacer = null();
HXDLIN( 803)			::String space = null();
HXDLIN( 803)			 ::Dynamic txtLoaded =  ::haxe::format::JsonParser_obj::__alloc( HX_CTX ,::haxe::format::JsonPrinter_obj::print(this->_file,replacer,space))->doParse();
HXLINE( 804)			::String txt = null();
HXLINE( 805)			::String file = HX_("config.json",54,db,08,a4);
HXLINE( 807)			if (::hx::IsNotNull( txtLoaded->__Field(HX_("__path",c5,48,4a,f9),::hx::paccDynamic) )) {
HXLINE( 809)				try {
            					HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 809)					txt = ::sys::io::File_obj::getContent(( (::String)(txtLoaded->__Field(HX_("__path",c5,48,4a,f9),::hx::paccDynamic)) ));
            				} catch( ::Dynamic _hx_e) {
            					if (_hx_e.IsClass<  ::Dynamic >() ){
            						HX_STACK_BEGIN_CATCH
            						 ::Dynamic _g = _hx_e;
HXLINE( 809)						txt = null();
            					}
            					else {
            						HX_STACK_DO_THROW(_hx_e);
            					}
            				}
HXLINE( 810)				file = ( (::String)(txtLoaded->__Field(HX_("__path",c5,48,4a,f9),::hx::paccDynamic)) );
HXLINE( 811)				file = (file.substring(0,(file.length - 4)) + HX_(".json",56,f1,d6,c2));
            			}
HXLINE( 814)			 ::Dynamic conf = ::states::editors::NoteSplashEditorState_obj::parseTxt(txt);
HXLINE( 815)			this->_file =  ::openfl::net::FileReference_obj::__alloc( HX_CTX );
HXLINE( 816)			this->_file->addEventListener(HX_("complete",b9,00,c8,7f),this->onSaveComplete_dyn(),null(),null(),null());
HXLINE( 817)			this->_file->addEventListener(HX_("cancel",7a,ed,33,b8),this->onSaveCancel_dyn(),null(),null(),null());
HXLINE( 818)			this->_file->addEventListener(HX_("ioError",02,fe,41,76),this->onSaveError_dyn(),null(),null(),null());
HXLINE( 819)			 ::openfl::net::FileReference _hx_tmp = this->_file;
HXDLIN( 819)			 ::Dynamic replacer1 = null();
HXDLIN( 819)			_hx_tmp->save(::haxe::format::JsonPrinter_obj::print(conf,replacer1,HX_("\t",09,00,00,00)),file);
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g1 = _hx_e;
HXLINE( 822)				 ::haxe::Exception e = ::haxe::Exception_obj::caught(_g1);
HXLINE( 824)				{
HXLINE( 824)					 ::Dynamic _hx_tmp1 = ::haxe::Log_obj::trace;
HXDLIN( 824)					::Array< ::Dynamic> tmp = e->get_stack();
HXDLIN( 824)					::String _hx_tmp2;
HXDLIN( 824)					if (::hx::IsNull( tmp )) {
HXLINE( 824)						_hx_tmp2 = HX_("null",87,9e,0e,49);
            					}
            					else {
HXLINE( 824)						_hx_tmp2 = ::haxe::_CallStack::CallStack_Impl__obj::toString(tmp);
            					}
HXDLIN( 824)					_hx_tmp1(_hx_tmp2,::hx::SourceInfo(HX_("source/states/editors/NoteSplashEditorState.hx",95,5b,8e,7d),824,HX_("states.editors.NoteSplashEditorState",17,96,40,8c),HX_("onLoadComplete",be,4c,20,63)));
            				}
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(NoteSplashEditorState_obj,onLoadComplete,(void))

void NoteSplashEditorState_obj::onLoadCancel( ::openfl::events::Event _){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_832_onLoadCancel)
HXLINE( 833)		this->_file->removeEventListener(HX_("select",fc,1a,33,6a),this->onLoadComplete_dyn(),null());
HXLINE( 834)		this->_file->removeEventListener(HX_("cancel",7a,ed,33,b8),this->onLoadCancel_dyn(),null());
HXLINE( 835)		this->_file->removeEventListener(HX_("ioError",02,fe,41,76),this->onLoadError_dyn(),null());
HXLINE( 836)		this->_file = null();
HXLINE( 837)		::haxe::Log_obj::trace(HX_("Cancelled file loading.",67,56,c5,a3),::hx::SourceInfo(HX_("source/states/editors/NoteSplashEditorState.hx",95,5b,8e,7d),837,HX_("states.editors.NoteSplashEditorState",17,96,40,8c),HX_("onLoadCancel",3f,be,a2,45)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(NoteSplashEditorState_obj,onLoadCancel,(void))

void NoteSplashEditorState_obj::onLoadError( ::openfl::events::IOErrorEvent _){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_844_onLoadError)
HXLINE( 845)		this->_file->removeEventListener(HX_("select",fc,1a,33,6a),this->onLoadComplete_dyn(),null());
HXLINE( 846)		this->_file->removeEventListener(HX_("cancel",7a,ed,33,b8),this->onLoadCancel_dyn(),null());
HXLINE( 847)		this->_file->removeEventListener(HX_("ioError",02,fe,41,76),this->onLoadError_dyn(),null());
HXLINE( 848)		this->_file = null();
HXLINE( 849)		::haxe::Log_obj::trace(HX_("Problem loading file",21,8c,56,d8),::hx::SourceInfo(HX_("source/states/editors/NoteSplashEditorState.hx",95,5b,8e,7d),849,HX_("states.editors.NoteSplashEditorState",17,96,40,8c),HX_("onLoadError",a3,fa,a3,b0)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(NoteSplashEditorState_obj,onLoadError,(void))

void NoteSplashEditorState_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_853_destroy)
HXLINE( 854)		::objects::NoteSplash_obj::configs->clear();
HXLINE( 855)		this->super::destroy();
HXLINE( 857)		::flixel::FlxG_obj::sound->music->set_volume(( (Float)(1) ));
HXLINE( 858)		::flixel::FlxG_obj::sound->muteKeys = ::Array_obj< int >::fromData( _hx_array_data_8c409617_65,1);
HXLINE( 859)		::flixel::FlxG_obj::sound->volumeDownKeys = ::Array_obj< int >::fromData( _hx_array_data_8c409617_66,2);
HXLINE( 860)		::flixel::FlxG_obj::sound->volumeUpKeys = ::Array_obj< int >::fromData( _hx_array_data_8c409617_67,2);
            	}


::String NoteSplashEditorState_obj::imageSkin;

 ::Dynamic NoteSplashEditorState_obj::parseTxt(::String content){
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_864_parseTxt)
HXLINE( 865)		 ::Dynamic config = ::objects::NoteSplash_obj::createConfig();
HXLINE( 866)		if (::hx::IsNull( content )) {
HXLINE( 867)			return config;
            		}
HXLINE( 869)		::String trim = ::StringTools_obj::trim(content);
HXLINE( 870)		if ((trim.length < 1)) {
HXLINE( 871)			return config;
            		}
HXLINE( 873)		::Array< ::String > configs = content.split(HX_("\n",0a,00,00,00));
HXLINE( 875)		bool _hx_tmp;
HXDLIN( 875)		if ((configs->length >= 2)) {
HXLINE( 875)			_hx_tmp = (::StringTools_obj::trim(configs->__get(0)) == HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 875)			_hx_tmp = true;
            		}
HXDLIN( 875)		if (_hx_tmp) {
HXLINE( 876)			return config;
            		}
HXLINE( 878)		::String animation = ::StringTools_obj::rtrim(configs->__get(0));
HXLINE( 879)		::Array< ::Dynamic> fps = ::Array_obj< ::Dynamic>::__new(2)->init(0,22)->init(1,26);
HXLINE( 880)		bool _hx_tmp1;
HXDLIN( 880)		if (::hx::IsNotNull( configs->__get(1) )) {
HXLINE( 880)			_hx_tmp1 = (::StringTools_obj::trim(configs->__get(1)) != HX_("",00,00,00,00));
            		}
            		else {
HXLINE( 880)			_hx_tmp1 = false;
            		}
HXDLIN( 880)		if (_hx_tmp1) {
HXLINE( 882)			::Array< ::String > newFps = ::StringTools_obj::trim(configs->__get(1)).split(HX_(" ",20,00,00,00));
HXLINE( 883)			 ::Dynamic fps1 = ::Std_obj::parseInt(newFps->__get(0));
HXDLIN( 883)			fps = ::Array_obj< ::Dynamic>::__new(2)->init(0,fps1)->init(1,::Std_obj::parseInt(newFps->__get(1)));
HXLINE( 884)			if (::hx::IsNull( fps->__get(0) )) {
HXLINE( 884)				fps[0] = 22;
            			}
HXLINE( 885)			if (::hx::IsNull( fps->__get(1) )) {
HXLINE( 885)				fps[1] = 26;
            			}
            		}
HXLINE( 888)		::Array< ::Dynamic> offsets = ::Array_obj< ::Dynamic>::__new(1)->init(0,::Array_obj< ::Dynamic>::__new(2)->init(0,0)->init(1,0));
HXLINE( 889)		if ((configs->length > 2)) {
HXLINE( 891)			offsets = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 892)			{
HXLINE( 892)				int _g = 2;
HXDLIN( 892)				int _g1 = configs->length;
HXDLIN( 892)				while((_g < _g1)){
HXLINE( 892)					_g = (_g + 1);
HXDLIN( 892)					int i = (_g - 1);
HXLINE( 894)					::String offset = ::StringTools_obj::trim(configs->__get(i));
HXLINE( 895)					if ((offset != HX_("",00,00,00,00))) {
HXLINE( 897)						::Array< ::String > offset1 = offset.split(HX_(" ",20,00,00,00));
HXLINE( 898)						Float x = ::Std_obj::parseFloat(offset1->__get(0));
HXLINE( 899)						Float y = ::Std_obj::parseFloat(offset1->__get(1));
HXLINE( 900)						if (::Math_obj::isNaN(x)) {
HXLINE( 900)							x = ( (Float)(0) );
            						}
HXLINE( 901)						if (::Math_obj::isNaN(y)) {
HXLINE( 901)							y = ( (Float)(0) );
            						}
HXLINE( 902)						offsets->push(::Array_obj< ::Dynamic>::__new(2)->init(0,x)->init(1,y));
            					}
            				}
            			}
            		}
HXLINE( 907)		int i1 = 0;
HXLINE( 908)		int k = 1;
HXLINE( 909)		while(true){
HXLINE( 911)			{
HXLINE( 911)				int _g2 = 0;
HXDLIN( 911)				::Array< ::String > _g3 = ::objects::Note_obj::colArray;
HXDLIN( 911)				while((_g2 < _g3->length)){
HXLINE( 911)					::String col = _g3->__get(_g2);
HXDLIN( 911)					_g2 = (_g2 + 1);
HXLINE( 913)					::String anim;
HXDLIN( 913)					if ((k <= 1)) {
HXLINE( 913)						anim = col;
            					}
            					else {
HXLINE( 913)						anim = ((HX_("",00,00,00,00) + col) + k);
            					}
HXLINE( 914)					::Array< ::Dynamic> offset2 = offsets->__get(::flixel::math::FlxMath_obj::wrap(i1,0,::Std_obj::_hx_int(( (Float)((offsets->length - 1)) )))).StaticCast< ::Array< ::Dynamic> >();
HXLINE( 916)					config = ::objects::NoteSplash_obj::addAnimationToConfig(config,( (Float)(1) ),anim,(((((HX_("",00,00,00,00) + animation) + HX_(" ",20,00,00,00)) + col) + HX_(" ",20,00,00,00)) + k),fps,offset2,::Array_obj< int >::__new(0),i1);
HXLINE( 917)					i1 = (i1 + 1);
            				}
            			}
HXLINE( 919)			if (::hx::IsNull( offsets->__get(i1).StaticCast< ::Array< ::Dynamic> >() )) {
HXLINE( 919)				goto _hx_goto_69;
            			}
HXLINE( 920)			k = (k + 1);
            		}
            		_hx_goto_69:;
HXLINE( 923)		return config;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(NoteSplashEditorState_obj,parseTxt,return )


void NoteSplashEditorState_obj::__alloc_dynamic_functions(::hx::Ctx *_hx_ctx,NoteSplashEditorState_obj *_hx_obj) {
	if (!_hx_obj->reloadImage.mPtr) _hx_obj->reloadImage = new __default_reloadImage(_hx_obj);
}
::hx::ObjectPtr< NoteSplashEditorState_obj > NoteSplashEditorState_obj::__new() {
	::hx::ObjectPtr< NoteSplashEditorState_obj > __this = new NoteSplashEditorState_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< NoteSplashEditorState_obj > NoteSplashEditorState_obj::__alloc(::hx::Ctx *_hx_ctx) {
	NoteSplashEditorState_obj *__this = (NoteSplashEditorState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(NoteSplashEditorState_obj), true, "states.editors.NoteSplashEditorState"));
	*(void **)__this = NoteSplashEditorState_obj::_hx_vtable;
	states::editors::NoteSplashEditorState_obj::__alloc_dynamic_functions(_hx_ctx,__this);
	__this->__construct();
	return __this;
}

NoteSplashEditorState_obj::NoteSplashEditorState_obj()
{
	reloadImage = new __default_reloadImage(this);
}

void NoteSplashEditorState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(NoteSplashEditorState);
	HX_MARK_MEMBER_NAME(strums,"strums");
	HX_MARK_MEMBER_NAME(splashes,"splashes");
	HX_MARK_MEMBER_NAME(config,"config");
	HX_MARK_MEMBER_NAME(tipText,"tipText");
	HX_MARK_MEMBER_NAME(errorText,"errorText");
	HX_MARK_MEMBER_NAME(curText,"curText");
	HX_MARK_MEMBER_NAME(splash,"splash");
	HX_MARK_MEMBER_NAME(UI,"UI");
	HX_MARK_MEMBER_NAME(properUI,"properUI");
	HX_MARK_MEMBER_NAME(shaderUI,"shaderUI");
	HX_MARK_MEMBER_NAME(animDropDown,"animDropDown");
	HX_MARK_MEMBER_NAME(curAnim,"curAnim");
	HX_MARK_MEMBER_NAME(addButton,"addButton");
	HX_MARK_MEMBER_NAME(curAnimText,"curAnimText");
	HX_MARK_MEMBER_NAME(numericStepperData,"numericStepperData");
	HX_MARK_MEMBER_NAME(templateButton,"templateButton");
	HX_MARK_MEMBER_NAME(imageInputText,"imageInputText");
	HX_MARK_MEMBER_NAME(scaleNumericStepper,"scaleNumericStepper");
	HX_MARK_MEMBER_NAME(redEnabled,"redEnabled");
	HX_MARK_MEMBER_NAME(blueEnabled,"blueEnabled");
	HX_MARK_MEMBER_NAME(greenEnabled,"greenEnabled");
	HX_MARK_MEMBER_NAME(redShader,"redShader");
	HX_MARK_MEMBER_NAME(greenShader,"greenShader");
	HX_MARK_MEMBER_NAME(blueShader,"blueShader");
	HX_MARK_MEMBER_NAME(changeShader,"changeShader");
	HX_MARK_MEMBER_NAME(defaultButton,"defaultButton");
	HX_MARK_MEMBER_NAME(reloadImage,"reloadImage");
	HX_MARK_MEMBER_NAME(holdingArrowsTime,"holdingArrowsTime");
	HX_MARK_MEMBER_NAME(holdingArrowsElapsed,"holdingArrowsElapsed");
	HX_MARK_MEMBER_NAME(copiedOffset,"copiedOffset");
	HX_MARK_MEMBER_NAME(_file,"_file");
	 ::backend::MusicBeatState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void NoteSplashEditorState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(strums,"strums");
	HX_VISIT_MEMBER_NAME(splashes,"splashes");
	HX_VISIT_MEMBER_NAME(config,"config");
	HX_VISIT_MEMBER_NAME(tipText,"tipText");
	HX_VISIT_MEMBER_NAME(errorText,"errorText");
	HX_VISIT_MEMBER_NAME(curText,"curText");
	HX_VISIT_MEMBER_NAME(splash,"splash");
	HX_VISIT_MEMBER_NAME(UI,"UI");
	HX_VISIT_MEMBER_NAME(properUI,"properUI");
	HX_VISIT_MEMBER_NAME(shaderUI,"shaderUI");
	HX_VISIT_MEMBER_NAME(animDropDown,"animDropDown");
	HX_VISIT_MEMBER_NAME(curAnim,"curAnim");
	HX_VISIT_MEMBER_NAME(addButton,"addButton");
	HX_VISIT_MEMBER_NAME(curAnimText,"curAnimText");
	HX_VISIT_MEMBER_NAME(numericStepperData,"numericStepperData");
	HX_VISIT_MEMBER_NAME(templateButton,"templateButton");
	HX_VISIT_MEMBER_NAME(imageInputText,"imageInputText");
	HX_VISIT_MEMBER_NAME(scaleNumericStepper,"scaleNumericStepper");
	HX_VISIT_MEMBER_NAME(redEnabled,"redEnabled");
	HX_VISIT_MEMBER_NAME(blueEnabled,"blueEnabled");
	HX_VISIT_MEMBER_NAME(greenEnabled,"greenEnabled");
	HX_VISIT_MEMBER_NAME(redShader,"redShader");
	HX_VISIT_MEMBER_NAME(greenShader,"greenShader");
	HX_VISIT_MEMBER_NAME(blueShader,"blueShader");
	HX_VISIT_MEMBER_NAME(changeShader,"changeShader");
	HX_VISIT_MEMBER_NAME(defaultButton,"defaultButton");
	HX_VISIT_MEMBER_NAME(reloadImage,"reloadImage");
	HX_VISIT_MEMBER_NAME(holdingArrowsTime,"holdingArrowsTime");
	HX_VISIT_MEMBER_NAME(holdingArrowsElapsed,"holdingArrowsElapsed");
	HX_VISIT_MEMBER_NAME(copiedOffset,"copiedOffset");
	HX_VISIT_MEMBER_NAME(_file,"_file");
	 ::backend::MusicBeatState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val NoteSplashEditorState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"UI") ) { return ::hx::Val( UI ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"_file") ) { return ::hx::Val( _file ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"strums") ) { return ::hx::Val( strums ); }
		if (HX_FIELD_EQ(inName,"config") ) { return ::hx::Val( config ); }
		if (HX_FIELD_EQ(inName,"splash") ) { return ::hx::Val( splash ); }
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tipText") ) { return ::hx::Val( tipText ); }
		if (HX_FIELD_EQ(inName,"curText") ) { return ::hx::Val( curText ); }
		if (HX_FIELD_EQ(inName,"curAnim") ) { return ::hx::Val( curAnim ); }
		if (HX_FIELD_EQ(inName,"loadTxt") ) { return ::hx::Val( loadTxt_dyn() ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"splashes") ) { return ::hx::Val( splashes ); }
		if (HX_FIELD_EQ(inName,"properUI") ) { return ::hx::Val( properUI ); }
		if (HX_FIELD_EQ(inName,"shaderUI") ) { return ::hx::Val( shaderUI ); }
		if (HX_FIELD_EQ(inName,"resetRGB") ) { return ::hx::Val( resetRGB_dyn() ); }
		if (HX_FIELD_EQ(inName,"parseRGB") ) { return ::hx::Val( parseRGB_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"errorText") ) { return ::hx::Val( errorText ); }
		if (HX_FIELD_EQ(inName,"addButton") ) { return ::hx::Val( addButton ); }
		if (HX_FIELD_EQ(inName,"redShader") ) { return ::hx::Val( redShader ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"addAnimTab") ) { return ::hx::Val( addAnimTab_dyn() ); }
		if (HX_FIELD_EQ(inName,"redEnabled") ) { return ::hx::Val( redEnabled ); }
		if (HX_FIELD_EQ(inName,"blueShader") ) { return ::hx::Val( blueShader ); }
		if (HX_FIELD_EQ(inName,"saveSplash") ) { return ::hx::Val( saveSplash_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"curAnimText") ) { return ::hx::Val( curAnimText ); }
		if (HX_FIELD_EQ(inName,"blueEnabled") ) { return ::hx::Val( blueEnabled ); }
		if (HX_FIELD_EQ(inName,"greenShader") ) { return ::hx::Val( greenShader ); }
		if (HX_FIELD_EQ(inName,"reloadImage") ) { return ::hx::Val( reloadImage ); }
		if (HX_FIELD_EQ(inName,"onSaveError") ) { return ::hx::Val( onSaveError_dyn() ); }
		if (HX_FIELD_EQ(inName,"onLoadError") ) { return ::hx::Val( onLoadError_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"animDropDown") ) { return ::hx::Val( animDropDown ); }
		if (HX_FIELD_EQ(inName,"greenEnabled") ) { return ::hx::Val( greenEnabled ); }
		if (HX_FIELD_EQ(inName,"changeShader") ) { return ::hx::Val( changeShader ); }
		if (HX_FIELD_EQ(inName,"copiedOffset") ) { return ::hx::Val( copiedOffset ); }
		if (HX_FIELD_EQ(inName,"setConfigRGB") ) { return ::hx::Val( setConfigRGB_dyn() ); }
		if (HX_FIELD_EQ(inName,"onSaveCancel") ) { return ::hx::Val( onSaveCancel_dyn() ); }
		if (HX_FIELD_EQ(inName,"onLoadCancel") ) { return ::hx::Val( onLoadCancel_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"defaultButton") ) { return ::hx::Val( defaultButton ); }
		if (HX_FIELD_EQ(inName,"addShadersTab") ) { return ::hx::Val( addShadersTab_dyn() ); }
		if (HX_FIELD_EQ(inName,"playStrumAnim") ) { return ::hx::Val( playStrumAnim_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"templateButton") ) { return ::hx::Val( templateButton ); }
		if (HX_FIELD_EQ(inName,"imageInputText") ) { return ::hx::Val( imageInputText ); }
		if (HX_FIELD_EQ(inName,"onSaveComplete") ) { return ::hx::Val( onSaveComplete_dyn() ); }
		if (HX_FIELD_EQ(inName,"onLoadComplete") ) { return ::hx::Val( onLoadComplete_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"addPropertiesTab") ) { return ::hx::Val( addPropertiesTab_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"holdingArrowsTime") ) { return ::hx::Val( holdingArrowsTime ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"numericStepperData") ) { return ::hx::Val( numericStepperData ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"scaleNumericStepper") ) { return ::hx::Val( scaleNumericStepper ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"holdingArrowsElapsed") ) { return ::hx::Val( holdingArrowsElapsed ); }
	}
	return super::__Field(inName,inCallProp);
}

bool NoteSplashEditorState_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"parseTxt") ) { outValue = parseTxt_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"imageSkin") ) { outValue = ( imageSkin ); return true; }
	}
	return false;
}

::hx::Val NoteSplashEditorState_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"UI") ) { UI=inValue.Cast<  ::backend::ui::PsychUIBox >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"_file") ) { _file=inValue.Cast<  ::openfl::net::FileReference >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"strums") ) { strums=inValue.Cast<  ::flixel::group::FlxTypedSpriteGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"config") ) { config=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"splash") ) { splash=inValue.Cast<  ::objects::NoteSplash >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"tipText") ) { tipText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"curText") ) { curText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"curAnim") ) { curAnim=inValue.Cast< ::String >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"splashes") ) { splashes=inValue.Cast<  ::flixel::group::FlxTypedSpriteGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"properUI") ) { properUI=inValue.Cast<  ::backend::ui::PsychUIBox >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shaderUI") ) { shaderUI=inValue.Cast<  ::backend::ui::PsychUIBox >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"errorText") ) { errorText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"addButton") ) { addButton=inValue.Cast<  ::backend::ui::PsychUIButton >(); return inValue; }
		if (HX_FIELD_EQ(inName,"redShader") ) { redShader=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"redEnabled") ) { redEnabled=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blueShader") ) { blueShader=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"curAnimText") ) { curAnimText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blueEnabled") ) { blueEnabled=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"greenShader") ) { greenShader=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"reloadImage") ) { reloadImage=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"animDropDown") ) { animDropDown=inValue.Cast<  ::backend::ui::PsychUIDropDownMenu >(); return inValue; }
		if (HX_FIELD_EQ(inName,"greenEnabled") ) { greenEnabled=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"changeShader") ) { changeShader=inValue.Cast<  ::backend::ui::PsychUIDropDownMenu >(); return inValue; }
		if (HX_FIELD_EQ(inName,"copiedOffset") ) { copiedOffset=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"defaultButton") ) { defaultButton=inValue.Cast<  ::backend::ui::PsychUICheckBox >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"templateButton") ) { templateButton=inValue.Cast<  ::backend::ui::PsychUIButton >(); return inValue; }
		if (HX_FIELD_EQ(inName,"imageInputText") ) { imageInputText=inValue.Cast<  ::backend::ui::PsychUIInputText >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"holdingArrowsTime") ) { holdingArrowsTime=inValue.Cast< Float >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"numericStepperData") ) { numericStepperData=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"scaleNumericStepper") ) { scaleNumericStepper=inValue.Cast<  ::backend::ui::PsychUINumericStepper >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"holdingArrowsElapsed") ) { holdingArrowsElapsed=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool NoteSplashEditorState_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"imageSkin") ) { imageSkin=ioValue.Cast< ::String >(); return true; }
	}
	return false;
}

void NoteSplashEditorState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("strums",0a,43,39,11));
	outFields->push(HX_("splashes",95,41,c9,37));
	outFields->push(HX_("config",c2,56,d2,c7));
	outFields->push(HX_("tipText",a8,a3,e6,87));
	outFields->push(HX_("errorText",95,48,62,73));
	outFields->push(HX_("curText",4d,3e,0f,b8));
	outFields->push(HX_("splash",67,81,98,bf));
	outFields->push(HX_("UI",54,4a,00,00));
	outFields->push(HX_("properUI",24,2d,38,ac));
	outFields->push(HX_("shaderUI",b9,dc,2a,36));
	outFields->push(HX_("animDropDown",62,db,29,ba));
	outFields->push(HX_("curAnim",b1,f7,86,ab));
	outFields->push(HX_("addButton",f3,96,04,92));
	outFields->push(HX_("curAnimText",fe,1c,8e,01));
	outFields->push(HX_("numericStepperData",0e,a2,d6,9e));
	outFields->push(HX_("templateButton",cc,a5,77,89));
	outFields->push(HX_("imageInputText",fc,06,6b,e2));
	outFields->push(HX_("scaleNumericStepper",ee,ed,ea,6a));
	outFields->push(HX_("redEnabled",30,8f,9e,7d));
	outFields->push(HX_("blueEnabled",07,d1,4d,b9));
	outFields->push(HX_("greenEnabled",fe,cb,df,cc));
	outFields->push(HX_("redShader",56,5f,7f,10));
	outFields->push(HX_("greenShader",48,36,ba,74));
	outFields->push(HX_("blueShader",5f,65,15,78));
	outFields->push(HX_("changeShader",b5,78,4e,04));
	outFields->push(HX_("defaultButton",93,35,59,d4));
	outFields->push(HX_("holdingArrowsTime",9a,f6,8d,72));
	outFields->push(HX_("holdingArrowsElapsed",cf,c3,f8,c5));
	outFields->push(HX_("copiedOffset",f7,dd,2d,57));
	outFields->push(HX_("_file",5b,ea,cc,f6));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo NoteSplashEditorState_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::group::FlxTypedSpriteGroup */ ,(int)offsetof(NoteSplashEditorState_obj,strums),HX_("strums",0a,43,39,11)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedSpriteGroup */ ,(int)offsetof(NoteSplashEditorState_obj,splashes),HX_("splashes",95,41,c9,37)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(NoteSplashEditorState_obj,config),HX_("config",c2,56,d2,c7)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(NoteSplashEditorState_obj,tipText),HX_("tipText",a8,a3,e6,87)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(NoteSplashEditorState_obj,errorText),HX_("errorText",95,48,62,73)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(NoteSplashEditorState_obj,curText),HX_("curText",4d,3e,0f,b8)},
	{::hx::fsObject /*  ::objects::NoteSplash */ ,(int)offsetof(NoteSplashEditorState_obj,splash),HX_("splash",67,81,98,bf)},
	{::hx::fsObject /*  ::backend::ui::PsychUIBox */ ,(int)offsetof(NoteSplashEditorState_obj,UI),HX_("UI",54,4a,00,00)},
	{::hx::fsObject /*  ::backend::ui::PsychUIBox */ ,(int)offsetof(NoteSplashEditorState_obj,properUI),HX_("properUI",24,2d,38,ac)},
	{::hx::fsObject /*  ::backend::ui::PsychUIBox */ ,(int)offsetof(NoteSplashEditorState_obj,shaderUI),HX_("shaderUI",b9,dc,2a,36)},
	{::hx::fsObject /*  ::backend::ui::PsychUIDropDownMenu */ ,(int)offsetof(NoteSplashEditorState_obj,animDropDown),HX_("animDropDown",62,db,29,ba)},
	{::hx::fsString,(int)offsetof(NoteSplashEditorState_obj,curAnim),HX_("curAnim",b1,f7,86,ab)},
	{::hx::fsObject /*  ::backend::ui::PsychUIButton */ ,(int)offsetof(NoteSplashEditorState_obj,addButton),HX_("addButton",f3,96,04,92)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(NoteSplashEditorState_obj,curAnimText),HX_("curAnimText",fe,1c,8e,01)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(NoteSplashEditorState_obj,numericStepperData),HX_("numericStepperData",0e,a2,d6,9e)},
	{::hx::fsObject /*  ::backend::ui::PsychUIButton */ ,(int)offsetof(NoteSplashEditorState_obj,templateButton),HX_("templateButton",cc,a5,77,89)},
	{::hx::fsObject /*  ::backend::ui::PsychUIInputText */ ,(int)offsetof(NoteSplashEditorState_obj,imageInputText),HX_("imageInputText",fc,06,6b,e2)},
	{::hx::fsObject /*  ::backend::ui::PsychUINumericStepper */ ,(int)offsetof(NoteSplashEditorState_obj,scaleNumericStepper),HX_("scaleNumericStepper",ee,ed,ea,6a)},
	{::hx::fsBool,(int)offsetof(NoteSplashEditorState_obj,redEnabled),HX_("redEnabled",30,8f,9e,7d)},
	{::hx::fsBool,(int)offsetof(NoteSplashEditorState_obj,blueEnabled),HX_("blueEnabled",07,d1,4d,b9)},
	{::hx::fsBool,(int)offsetof(NoteSplashEditorState_obj,greenEnabled),HX_("greenEnabled",fe,cb,df,cc)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(NoteSplashEditorState_obj,redShader),HX_("redShader",56,5f,7f,10)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(NoteSplashEditorState_obj,greenShader),HX_("greenShader",48,36,ba,74)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(NoteSplashEditorState_obj,blueShader),HX_("blueShader",5f,65,15,78)},
	{::hx::fsObject /*  ::backend::ui::PsychUIDropDownMenu */ ,(int)offsetof(NoteSplashEditorState_obj,changeShader),HX_("changeShader",b5,78,4e,04)},
	{::hx::fsObject /*  ::backend::ui::PsychUICheckBox */ ,(int)offsetof(NoteSplashEditorState_obj,defaultButton),HX_("defaultButton",93,35,59,d4)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(NoteSplashEditorState_obj,reloadImage),HX_("reloadImage",42,79,0d,19)},
	{::hx::fsFloat,(int)offsetof(NoteSplashEditorState_obj,holdingArrowsTime),HX_("holdingArrowsTime",9a,f6,8d,72)},
	{::hx::fsFloat,(int)offsetof(NoteSplashEditorState_obj,holdingArrowsElapsed),HX_("holdingArrowsElapsed",cf,c3,f8,c5)},
	{::hx::fsObject /* ::Array< Float > */ ,(int)offsetof(NoteSplashEditorState_obj,copiedOffset),HX_("copiedOffset",f7,dd,2d,57)},
	{::hx::fsObject /*  ::openfl::net::FileReference */ ,(int)offsetof(NoteSplashEditorState_obj,_file),HX_("_file",5b,ea,cc,f6)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo NoteSplashEditorState_obj_sStaticStorageInfo[] = {
	{::hx::fsString,(void *) &NoteSplashEditorState_obj::imageSkin,HX_("imageSkin",78,ab,89,2e)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String NoteSplashEditorState_obj_sMemberFields[] = {
	HX_("strums",0a,43,39,11),
	HX_("splashes",95,41,c9,37),
	HX_("config",c2,56,d2,c7),
	HX_("tipText",a8,a3,e6,87),
	HX_("errorText",95,48,62,73),
	HX_("curText",4d,3e,0f,b8),
	HX_("splash",67,81,98,bf),
	HX_("UI",54,4a,00,00),
	HX_("properUI",24,2d,38,ac),
	HX_("shaderUI",b9,dc,2a,36),
	HX_("create",fc,66,0f,7c),
	HX_("animDropDown",62,db,29,ba),
	HX_("curAnim",b1,f7,86,ab),
	HX_("addButton",f3,96,04,92),
	HX_("curAnimText",fe,1c,8e,01),
	HX_("numericStepperData",0e,a2,d6,9e),
	HX_("templateButton",cc,a5,77,89),
	HX_("addAnimTab",a3,18,cd,e1),
	HX_("imageInputText",fc,06,6b,e2),
	HX_("scaleNumericStepper",ee,ed,ea,6a),
	HX_("addPropertiesTab",41,ad,4d,c4),
	HX_("redEnabled",30,8f,9e,7d),
	HX_("blueEnabled",07,d1,4d,b9),
	HX_("greenEnabled",fe,cb,df,cc),
	HX_("redShader",56,5f,7f,10),
	HX_("greenShader",48,36,ba,74),
	HX_("blueShader",5f,65,15,78),
	HX_("changeShader",b5,78,4e,04),
	HX_("defaultButton",93,35,59,d4),
	HX_("addShadersTab",c8,9a,4c,ba),
	HX_("reloadImage",42,79,0d,19),
	HX_("holdingArrowsTime",9a,f6,8d,72),
	HX_("holdingArrowsElapsed",cf,c3,f8,c5),
	HX_("copiedOffset",f7,dd,2d,57),
	HX_("update",09,86,05,87),
	HX_("playStrumAnim",66,3b,db,81),
	HX_("resetRGB",7e,f8,dc,4f),
	HX_("parseRGB",9a,c8,78,d6),
	HX_("setConfigRGB",69,05,91,e4),
	HX_("_file",5b,ea,cc,f6),
	HX_("onSaveComplete",d5,ac,3f,bc),
	HX_("onSaveCancel",96,1a,31,d9),
	HX_("onSaveError",2c,b6,19,24),
	HX_("saveSplash",84,0c,52,08),
	HX_("loadTxt",ea,e7,e2,08),
	HX_("onLoadComplete",be,4c,20,63),
	HX_("onLoadCancel",3f,be,a2,45),
	HX_("onLoadError",a3,fa,a3,b0),
	HX_("destroy",fa,2c,86,24),
	::String(null()) };

static void NoteSplashEditorState_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(NoteSplashEditorState_obj::imageSkin,"imageSkin");
};

#ifdef HXCPP_VISIT_ALLOCS
static void NoteSplashEditorState_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(NoteSplashEditorState_obj::imageSkin,"imageSkin");
};

#endif

::hx::Class NoteSplashEditorState_obj::__mClass;

static ::String NoteSplashEditorState_obj_sStaticFields[] = {
	HX_("imageSkin",78,ab,89,2e),
	HX_("parseTxt",fd,77,7a,d6),
	::String(null())
};

void NoteSplashEditorState_obj::__register()
{
	NoteSplashEditorState_obj _hx_dummy;
	NoteSplashEditorState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("states.editors.NoteSplashEditorState",17,96,40,8c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &NoteSplashEditorState_obj::__GetStatic;
	__mClass->mSetStaticField = &NoteSplashEditorState_obj::__SetStatic;
	__mClass->mMarkFunc = NoteSplashEditorState_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(NoteSplashEditorState_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(NoteSplashEditorState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< NoteSplashEditorState_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = NoteSplashEditorState_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = NoteSplashEditorState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = NoteSplashEditorState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void NoteSplashEditorState_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_c40e4203cdaacbc6_26_boot)
HXDLIN(  26)		imageSkin = null();
            	}
}

} // end namespace states
} // end namespace editors
