// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_ClientPrefs
#include <backend/ClientPrefs.h>
#endif
#ifndef INCLUDED_backend_Controls
#include <backend/Controls.h>
#endif
#ifndef INCLUDED_backend_DiscordClient
#include <backend/DiscordClient.h>
#endif
#ifndef INCLUDED_backend_InputFormatter
#include <backend/InputFormatter.h>
#endif
#ifndef INCLUDED_backend_Language
#include <backend/Language.h>
#endif
#ifndef INCLUDED_backend_MusicBeatSubstate
#include <backend/MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_SaveVariables
#include <backend/SaveVariables.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroupIterator
#include <flixel/group/FlxTypedGroupIterator.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepad
#include <flixel/input/gamepad/FlxGamepad.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadManager
#include <flixel/input/gamepad/FlxGamepadManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadModel
#include <flixel/input/gamepad/FlxGamepadModel.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad__FlxGamepadInputID_FlxGamepadInputID_Impl_
#include <flixel/input/gamepad/_FlxGamepadInputID/FlxGamepadInputID_Impl_.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_FlxGamepadMapping
#include <flixel/input/gamepad/mappings/FlxGamepadMapping.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard__FlxKey_FlxKey_Impl_
#include <flixel/input/keyboard/_FlxKey/FlxKey_Impl_.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMath
#include <flixel/math/FlxMath.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSoundGroup
#include <flixel/sound/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxEase
#include <flixel/tweens/FlxEase.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_objects_Alignment
#include <objects/Alignment.h>
#endif
#ifndef INCLUDED_objects_AlphaCharacter
#include <objects/AlphaCharacter.h>
#endif
#ifndef INCLUDED_objects_Alphabet
#include <objects/Alphabet.h>
#endif
#ifndef INCLUDED_objects_AttachedText
#include <objects/AttachedText.h>
#endif
#ifndef INCLUDED_objects_CheckboxThingie
#include <objects/CheckboxThingie.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_media_Sound
#include <openfl/media/Sound.h>
#endif
#ifndef INCLUDED_options_BaseOptionsMenu
#include <options/BaseOptionsMenu.h>
#endif
#ifndef INCLUDED_options_Option
#include <options/Option.h>
#endif
#ifndef INCLUDED_options_OptionType
#include <options/OptionType.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_11861b212311743c_13_new,"options.BaseOptionsMenu","new",0x99505d4e,"options.BaseOptionsMenu.new","options/BaseOptionsMenu.hx",13,0x82de5a23)
HX_LOCAL_STACK_FRAME(_hx_pos_11861b212311743c_108_addOption,"options.BaseOptionsMenu","addOption",0xc780fbe4,"options.BaseOptionsMenu.addOption","options/BaseOptionsMenu.hx",108,0x82de5a23)
HX_LOCAL_STACK_FRAME(_hx_pos_11861b212311743c_124_update,"options.BaseOptionsMenu","update",0xdab941db,"options.BaseOptionsMenu.update","options/BaseOptionsMenu.hx",124,0x82de5a23)
HX_LOCAL_STACK_FRAME(_hx_pos_11861b212311743c_295_bindingKeyUpdate,"options.BaseOptionsMenu","bindingKeyUpdate",0xf77abf55,"options.BaseOptionsMenu.bindingKeyUpdate","options/BaseOptionsMenu.hx",295,0x82de5a23)
HX_LOCAL_STACK_FRAME(_hx_pos_11861b212311743c_397_updateBind,"options.BaseOptionsMenu","updateBind",0x7b9eed38,"options.BaseOptionsMenu.updateBind","options/BaseOptionsMenu.hx",397,0x82de5a23)
HX_LOCAL_STACK_FRAME(_hx_pos_11861b212311743c_427_playstationCheck,"options.BaseOptionsMenu","playstationCheck",0xac279ffa,"options.BaseOptionsMenu.playstationCheck","options/BaseOptionsMenu.hx",427,0x82de5a23)
HX_LOCAL_STACK_FRAME(_hx_pos_11861b212311743c_448_closeBinding,"options.BaseOptionsMenu","closeBinding",0xb14be7bf,"options.BaseOptionsMenu.closeBinding","options/BaseOptionsMenu.hx",448,0x82de5a23)
HX_LOCAL_STACK_FRAME(_hx_pos_11861b212311743c_461_updateTextFrom,"options.BaseOptionsMenu","updateTextFrom",0x9c56c9b2,"options.BaseOptionsMenu.updateTextFrom","options/BaseOptionsMenu.hx",461,0x82de5a23)
HX_LOCAL_STACK_FRAME(_hx_pos_11861b212311743c_476_changeSelection,"options.BaseOptionsMenu","changeSelection",0x8948d2aa,"options.BaseOptionsMenu.changeSelection","options/BaseOptionsMenu.hx",476,0x82de5a23)
HX_LOCAL_STACK_FRAME(_hx_pos_11861b212311743c_504_reloadCheckboxes,"options.BaseOptionsMenu","reloadCheckboxes",0x856a587c,"options.BaseOptionsMenu.reloadCheckboxes","options/BaseOptionsMenu.hx",504,0x82de5a23)
namespace options{

void BaseOptionsMenu_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_11861b212311743c_13_new)
HXLINE( 395)		this->MAX_KEYBIND_WIDTH = 320;
HXLINE( 119)		this->holdingEsc = ((Float)0);
HXLINE( 118)		this->bindingKey = false;
HXLINE( 116)		this->holdValue = ((Float)0);
HXLINE( 115)		this->holdTime = ((Float)0);
HXLINE( 114)		this->nextAccept = 5;
HXLINE(  16)		this->curSelected = 0;
HXLINE(  15)		this->curOption = null();
HXLINE(  32)		super::__construct();
HXLINE(  34)		if (::hx::IsNull( this->title )) {
HXLINE(  34)			this->title = HX_("Options",3e,5b,4f,ad);
            		}
HXLINE(  35)		if (::hx::IsNull( this->rpcTitle )) {
HXLINE(  35)			this->rpcTitle = HX_("Options Menu",e1,25,4c,98);
            		}
HXLINE(  38)		::backend::DiscordClient_obj::changePresence(this->rpcTitle,null(),null(),null(),null(),null());
HXLINE(  41)		 ::flixel::FlxSprite _hx_tmp =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXDLIN(  41)		this->bg = _hx_tmp->loadGraphic(::backend::Paths_obj::image(HX_("menuDesat",26,91,04,72),null(),null()),null(),null(),null(),null(),null());
HXLINE(  42)		this->bg->set_color(-1412611);
HXLINE(  43)		{
HXLINE(  43)			 ::flixel::FlxSprite _this = this->bg;
HXDLIN(  43)			int axes = 17;
HXDLIN(  43)			bool _hx_tmp1;
HXDLIN(  43)			if ((axes != 1)) {
HXLINE(  43)				_hx_tmp1 = (axes == 17);
            			}
            			else {
HXLINE(  43)				_hx_tmp1 = true;
            			}
HXDLIN(  43)			if (_hx_tmp1) {
HXLINE(  43)				int _hx_tmp2 = ::flixel::FlxG_obj::width;
HXDLIN(  43)				_this->set_x(((( (Float)(_hx_tmp2) ) - _this->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  43)			bool _hx_tmp3;
HXDLIN(  43)			if ((axes != 16)) {
HXLINE(  43)				_hx_tmp3 = (axes == 17);
            			}
            			else {
HXLINE(  43)				_hx_tmp3 = true;
            			}
HXDLIN(  43)			if (_hx_tmp3) {
HXLINE(  43)				int _hx_tmp4 = ::flixel::FlxG_obj::height;
HXDLIN(  43)				_this->set_y(((( (Float)(_hx_tmp4) ) - _this->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  44)		this->bg->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE(  45)		this->add(this->bg);
HXLINE(  48)		this->grpOptions =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  49)		this->add(this->grpOptions);
HXLINE(  51)		this->grpTexts =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  52)		this->add(this->grpTexts);
HXLINE(  54)		this->checkboxGroup =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  55)		this->add(this->checkboxGroup);
HXLINE(  57)		this->descBox =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(1,1,-16777216,null(),null());
HXLINE(  58)		this->descBox->set_alpha(((Float)0.6));
HXLINE(  59)		this->add(this->descBox);
HXLINE(  61)		 ::objects::Alphabet titleText =  ::objects::Alphabet_obj::__alloc( HX_CTX ,( (Float)(75) ),( (Float)(45) ),this->title,true);
HXLINE(  62)		titleText->setScale(((Float)0.6),null());
HXLINE(  63)		titleText->set_alpha(((Float)0.4));
HXLINE(  64)		this->add(titleText);
HXLINE(  66)		this->descText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,50,600,1180,HX_("",00,00,00,00),32,null());
HXLINE(  67)		 ::flixel::text::FlxText _hx_tmp5 = this->descText;
HXDLIN(  67)		::String key = (HX_("fonts/",eb,13,ef,fa) + HX_("vcr.ttf",9d,d2,a7,82));
HXDLIN(  67)		::Dynamic this1 = ::backend::Language_obj::phrases;
HXDLIN(  67)		::String str = ( ( ::haxe::ds::StringMap)(this1) )->get_string(::StringTools_obj::trim(key).toLowerCase());
HXDLIN(  67)		if (::hx::IsNotNull( str )) {
HXLINE(  67)			key = str;
            		}
HXDLIN(  67)		::String folderKey = key;
HXDLIN(  67)		::String file = ::backend::Paths_obj::modFolders(folderKey);
HXDLIN(  67)		::String _hx_tmp6;
HXDLIN(  67)		if (::sys::FileSystem_obj::exists(file)) {
HXLINE(  67)			_hx_tmp6 = file;
            		}
            		else {
HXLINE(  67)			_hx_tmp6 = (HX_("assets/",4c,2a,dc,36) + folderKey);
            		}
HXDLIN(  67)		_hx_tmp5->setFormat(_hx_tmp6,32,-1,HX_("center",d5,25,db,05),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE(  68)		{
HXLINE(  68)			 ::flixel::math::FlxBasePoint this2 = this->descText->scrollFactor;
HXDLIN(  68)			this2->set_x(( (Float)(0) ));
HXDLIN(  68)			this2->set_y(( (Float)(0) ));
            		}
HXLINE(  69)		this->descText->set_borderSize(((Float)2.4));
HXLINE(  70)		this->add(this->descText);
HXLINE(  72)		{
HXLINE(  72)			int _g = 0;
HXDLIN(  72)			int _g1 = this->optionsArray->length;
HXDLIN(  72)			while((_g < _g1)){
HXLINE(  72)				_g = (_g + 1);
HXDLIN(  72)				int i = (_g - 1);
HXLINE(  74)				 ::objects::Alphabet optionText =  ::objects::Alphabet_obj::__alloc( HX_CTX ,( (Float)(220) ),( (Float)(260) ),this->optionsArray->__get(i).StaticCast<  ::options::Option >()->name,false);
HXLINE(  75)				optionText->isMenuItem = true;
HXLINE(  78)				optionText->targetY = i;
HXLINE(  79)				this->grpOptions->add(optionText).StaticCast<  ::objects::Alphabet >();
HXLINE(  81)				if (::hx::IsPointerEq( this->optionsArray->__get(i).StaticCast<  ::options::Option >()->type,::options::OptionType_obj::BOOL_dyn() )) {
HXLINE(  83)					Float checkbox = (optionText->x - ( (Float)(105) ));
HXDLIN(  83)					Float optionText1 = optionText->y;
HXDLIN(  83)					 ::objects::CheckboxThingie checkbox1 =  ::objects::CheckboxThingie_obj::__alloc( HX_CTX ,checkbox,optionText1,(::Std_obj::string(this->optionsArray->__get(i).StaticCast<  ::options::Option >()->getValue()) == HX_("true",4e,a7,03,4d)));
HXLINE(  84)					checkbox1->sprTracker = optionText;
HXLINE(  85)					checkbox1->ID = i;
HXLINE(  86)					this->checkboxGroup->add(checkbox1).StaticCast<  ::objects::CheckboxThingie >();
            				}
            				else {
HXLINE(  90)					optionText->set_x((optionText->x - ( (Float)(80) )));
HXLINE(  91)					optionText->startPosition->set_x((optionText->startPosition->x - ( (Float)(80) )));
HXLINE(  93)					::String valueText = (HX_("",00,00,00,00) + ::Std_obj::string(this->optionsArray->__get(i).StaticCast<  ::options::Option >()->getValue()));
HXDLIN(  93)					 ::objects::AttachedText valueText1 =  ::objects::AttachedText_obj::__alloc( HX_CTX ,valueText,(optionText->get_width() + 60),null(),null(),null());
HXLINE(  94)					valueText1->sprTracker = optionText;
HXLINE(  95)					valueText1->copyAlpha = true;
HXLINE(  96)					valueText1->ID = i;
HXLINE(  97)					this->grpTexts->add(valueText1).StaticCast<  ::objects::AttachedText >();
HXLINE(  98)					this->optionsArray->__get(i).StaticCast<  ::options::Option >()->child = valueText1;
            				}
HXLINE( 101)				this->updateTextFrom(this->optionsArray->__get(i).StaticCast<  ::options::Option >());
            			}
            		}
HXLINE( 104)		this->changeSelection(null());
HXLINE( 105)		this->reloadCheckboxes();
            	}

Dynamic BaseOptionsMenu_obj::__CreateEmpty() { return new BaseOptionsMenu_obj; }

void *BaseOptionsMenu_obj::_hx_vtable = 0;

Dynamic BaseOptionsMenu_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< BaseOptionsMenu_obj > _hx_result = new BaseOptionsMenu_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool BaseOptionsMenu_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x5661ffbf) {
		if (inClassId<=(int)0x3c0818b8) {
			if (inClassId<=(int)0x0cc50116) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0cc50116;
			} else {
				return inClassId==(int)0x3c0818b8;
			}
		} else {
			return inClassId==(int)0x5661ffbf;
		}
	} else {
		if (inClassId<=(int)0x7c795c9f) {
			return inClassId==(int)0x62817b24 || inClassId==(int)0x7c795c9f;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	}
}

 ::options::Option BaseOptionsMenu_obj::addOption( ::options::Option option){
            	HX_STACKFRAME(&_hx_pos_11861b212311743c_108_addOption)
HXLINE( 109)		bool _hx_tmp;
HXDLIN( 109)		if (::hx::IsNotNull( this->optionsArray )) {
HXLINE( 109)			_hx_tmp = (this->optionsArray->length < 1);
            		}
            		else {
HXLINE( 109)			_hx_tmp = true;
            		}
HXDLIN( 109)		if (_hx_tmp) {
HXLINE( 109)			this->optionsArray = ::Array_obj< ::Dynamic>::__new(0);
            		}
HXLINE( 110)		this->optionsArray->push(option);
HXLINE( 111)		return option;
            	}


HX_DEFINE_DYNAMIC_FUNC1(BaseOptionsMenu_obj,addOption,return )

void BaseOptionsMenu_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_11861b212311743c_124_update)
HXLINE( 125)		this->super::update(elapsed);
HXLINE( 127)		if (this->bindingKey) {
HXLINE( 129)			this->bindingKeyUpdate(elapsed);
HXLINE( 130)			return;
            		}
HXLINE( 133)		if (::backend::Controls_obj::instance->get_UI_UP_P()) {
HXLINE( 135)			this->changeSelection(-1);
            		}
HXLINE( 137)		if (::backend::Controls_obj::instance->get_UI_DOWN_P()) {
HXLINE( 139)			this->changeSelection(1);
            		}
HXLINE( 142)		if (::backend::Controls_obj::instance->get_BACK()) {
HXLINE( 143)			this->close();
HXLINE( 144)			 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 144)			_hx_tmp->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("cancelMenu",39,a4,43,b7)),null(),true,null()),null(),null(),null(),null(),null());
            		}
HXLINE( 147)		if ((this->nextAccept <= 0)) {
HXLINE( 149)			switch((int)(this->curOption->type->_hx_getIndex())){
            				case (int)0: {
HXLINE( 152)					if (::backend::Controls_obj::instance->get_ACCEPT()) {
HXLINE( 154)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 154)						_hx_tmp1->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),null(),null(),null(),null(),null());
HXLINE( 155)						 ::Dynamic _hx_tmp2 = this->curOption->setValue;
HXDLIN( 155)						 ::Dynamic _hx_tmp3;
HXDLIN( 155)						if (::hx::IsEq( this->curOption->getValue(),true )) {
HXLINE( 155)							_hx_tmp3 = false;
            						}
            						else {
HXLINE( 155)							_hx_tmp3 = true;
            						}
HXDLIN( 155)						_hx_tmp2(_hx_tmp3);
HXLINE( 156)						this->curOption->change();
HXLINE( 157)						this->reloadCheckboxes();
            					}
            				}
            				break;
            				case (int)5: {
HXLINE( 161)					if (::backend::Controls_obj::instance->get_ACCEPT()) {
HXLINE( 163)						this->bindingBlack =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(1,1,-1,null(),null());
HXLINE( 164)						{
HXLINE( 164)							 ::flixel::math::FlxBasePoint this1 = this->bindingBlack->scale;
HXDLIN( 164)							Float y = ( (Float)(::flixel::FlxG_obj::height) );
HXDLIN( 164)							this1->set_x(( (Float)(::flixel::FlxG_obj::width) ));
HXDLIN( 164)							this1->set_y(y);
            						}
HXLINE( 165)						this->bindingBlack->updateHitbox();
HXLINE( 166)						this->bindingBlack->set_alpha(( (Float)(0) ));
HXLINE( 167)						::flixel::tweens::FlxTween_obj::tween(this->bindingBlack, ::Dynamic(::hx::Anon_obj::Create(1)
            							->setFixed(0,HX_("alpha",5e,a7,96,21),((Float)0.6))),((Float)0.35), ::Dynamic(::hx::Anon_obj::Create(1)
            							->setFixed(0,HX_("ease",ee,8b,0c,43),::flixel::tweens::FlxEase_obj::linear_dyn())));
HXLINE( 168)						this->add(this->bindingBlack);
HXLINE( 170)						Float _hx_tmp4 = (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ));
HXDLIN( 170)						::cpp::VirtualArray values = ::cpp::VirtualArray_obj::__new(1)->init(0,this->curOption->name);
HXDLIN( 170)						::Dynamic this2 = ::backend::Language_obj::phrases;
HXDLIN( 170)						 ::EReg hideChars =  ::EReg_obj::__alloc( HX_CTX ,HX_("[~&\\\\/;:<>#.,'\"%?!]",85,3f,6d,6d),HX_("g",67,00,00,00));
HXDLIN( 170)						::String str = ( ( ::haxe::ds::StringMap)(this2) )->get_string(::StringTools_obj::trim(hideChars->replace(::StringTools_obj::replace(HX_("controls_rebinding",a9,45,9d,e8),HX_(" ",20,00,00,00),HX_("_",5f,00,00,00)),HX_("",00,00,00,00)).toLowerCase()));
HXDLIN( 170)						if (::hx::IsNull( str )) {
HXLINE(  62)							str = HX_("Rebinding {1}",19,d9,a7,e4);
            						}
HXLINE( 170)						if (::hx::IsNull( str )) {
HXLINE(  68)							str = HX_("controls_rebinding",a9,45,9d,e8);
            						}
HXLINE( 170)						if (::hx::IsNotNull( values )) {
HXLINE( 170)							int _g_current = 0;
HXDLIN( 170)							::cpp::VirtualArray _g_array = values;
HXDLIN( 170)							while((_g_current < _g_array->get_length())){
HXLINE( 170)								 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 170)								_g_current = (_g_current + 1);
HXDLIN( 170)								int _g_key = (_g_current - 1);
HXDLIN( 170)								int num = _g_key;
HXDLIN( 170)								 ::Dynamic value = _g_value;
HXLINE(  72)								str = ::StringTools_obj::replace(str,((HX_("{",7b,00,00,00) + (num + 1)) + HX_("}",7d,00,00,00)),( (::String)(value) ));
            							}
            						}
HXLINE( 170)						this->bindingText =  ::objects::Alphabet_obj::__alloc( HX_CTX ,_hx_tmp4,( (Float)(160) ),str,false);
HXLINE( 171)						this->bindingText->set_alignment(::objects::Alignment_obj::CENTERED_dyn());
HXLINE( 172)						this->add(this->bindingText);
HXLINE( 174)						Float _hx_tmp5 = (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ));
HXDLIN( 174)						::cpp::VirtualArray values1 = null();
HXDLIN( 174)						::Dynamic this3 = ::backend::Language_obj::phrases;
HXDLIN( 174)						 ::EReg hideChars1 =  ::EReg_obj::__alloc( HX_CTX ,HX_("[~&\\\\/;:<>#.,'\"%?!]",85,3f,6d,6d),HX_("g",67,00,00,00));
HXDLIN( 174)						::String str1 = ( ( ::haxe::ds::StringMap)(this3) )->get_string(::StringTools_obj::trim(hideChars1->replace(::StringTools_obj::replace(HX_("controls_rebinding2",69,ae,ff,a0),HX_(" ",20,00,00,00),HX_("_",5f,00,00,00)),HX_("",00,00,00,00)).toLowerCase()));
HXDLIN( 174)						if (::hx::IsNull( str1 )) {
HXLINE(  62)							str1 = HX_("Hold ESC to Cancel\nHold Backspace to Delete",25,23,57,ab);
            						}
HXLINE( 174)						if (::hx::IsNull( str1 )) {
HXLINE(  68)							str1 = HX_("controls_rebinding2",69,ae,ff,a0);
            						}
HXLINE( 174)						if (::hx::IsNotNull( values1 )) {
HXLINE( 174)							int _g_current1 = 0;
HXDLIN( 174)							::cpp::VirtualArray _g_array1 = values1;
HXDLIN( 174)							while((_g_current1 < _g_array1->get_length())){
HXLINE( 174)								 ::Dynamic _g_value1 = _g_array1->__get(_g_current1);
HXDLIN( 174)								_g_current1 = (_g_current1 + 1);
HXDLIN( 174)								int _g_key1 = (_g_current1 - 1);
HXDLIN( 174)								int num1 = _g_key1;
HXDLIN( 174)								 ::Dynamic value1 = _g_value1;
HXLINE(  72)								str1 = ::StringTools_obj::replace(str1,((HX_("{",7b,00,00,00) + (num1 + 1)) + HX_("}",7d,00,00,00)),( (::String)(value1) ));
            							}
            						}
HXLINE( 174)						this->bindingText2 =  ::objects::Alphabet_obj::__alloc( HX_CTX ,_hx_tmp5,( (Float)(340) ),str1,true);
HXLINE( 175)						this->bindingText2->set_alignment(::objects::Alignment_obj::CENTERED_dyn());
HXLINE( 176)						this->add(this->bindingText2);
HXLINE( 178)						this->bindingKey = true;
HXLINE( 179)						this->holdingEsc = ( (Float)(0) );
HXLINE( 180)						::backend::ClientPrefs_obj::toggleVolumeKeys(false);
HXLINE( 181)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp6 = ::flixel::FlxG_obj::sound;
HXDLIN( 181)						_hx_tmp6->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),null(),null(),null(),null(),null());
            					}
            				}
            				break;
            				default:{
HXLINE( 185)					bool _hx_tmp7;
HXDLIN( 185)					if (!(::backend::Controls_obj::instance->get_UI_LEFT())) {
HXLINE( 185)						_hx_tmp7 = ::backend::Controls_obj::instance->get_UI_RIGHT();
            					}
            					else {
HXLINE( 185)						_hx_tmp7 = true;
            					}
HXDLIN( 185)					if (_hx_tmp7) {
HXLINE( 187)						bool pressed;
HXDLIN( 187)						if (!(::backend::Controls_obj::instance->get_UI_LEFT_P())) {
HXLINE( 187)							pressed = ::backend::Controls_obj::instance->get_UI_RIGHT_P();
            						}
            						else {
HXLINE( 187)							pressed = true;
            						}
HXLINE( 188)						bool _hx_tmp8;
HXDLIN( 188)						if (!((this->holdTime > ((Float)0.5)))) {
HXLINE( 188)							_hx_tmp8 = pressed;
            						}
            						else {
HXLINE( 188)							_hx_tmp8 = true;
            						}
HXDLIN( 188)						if (_hx_tmp8) {
HXLINE( 190)							if (pressed) {
HXLINE( 192)								 ::Dynamic add = null();
HXLINE( 193)								if (::hx::IsPointerNotEq( this->curOption->type,::options::OptionType_obj::STRING_dyn() )) {
HXLINE( 194)									if (::backend::Controls_obj::instance->get_UI_LEFT()) {
HXLINE( 194)										add = -(this->curOption->changeValue);
            									}
            									else {
HXLINE( 194)										add = this->curOption->changeValue;
            									}
            								}
HXLINE( 196)								switch((int)(this->curOption->type->_hx_getIndex())){
            									case (int)1: case (int)2: case (int)3: {
HXLINE( 199)										this->holdValue = ( (Float)((this->curOption->getValue() + add)) );
HXLINE( 200)										if (::hx::IsLess( this->holdValue,this->curOption->minValue )) {
HXLINE( 200)											this->holdValue = ( (Float)(this->curOption->minValue) );
            										}
            										else {
HXLINE( 201)											if (::hx::IsGreater( this->holdValue,this->curOption->maxValue )) {
HXLINE( 201)												this->holdValue = ( (Float)(this->curOption->maxValue) );
            											}
            										}
HXLINE( 203)										if (::hx::IsPointerEq( this->curOption->type,::options::OptionType_obj::INT_dyn() )) {
HXLINE( 205)											this->holdValue = ( (Float)(::Math_obj::round(this->holdValue)) );
HXLINE( 206)											this->curOption->setValue(this->holdValue);
            										}
            										else {
HXLINE( 210)											this->holdValue = ::flixel::math::FlxMath_obj::roundDecimal(this->holdValue,this->curOption->decimals);
HXLINE( 211)											this->curOption->setValue(this->holdValue);
            										}
            									}
            									break;
            									case (int)4: {
HXLINE( 215)										int num2 = this->curOption->curOption;
HXLINE( 216)										if (::backend::Controls_obj::instance->get_UI_LEFT_P()) {
HXLINE( 216)											num2 = (num2 - 1);
            										}
            										else {
HXLINE( 217)											num2 = (num2 + 1);
            										}
HXLINE( 219)										if ((num2 < 0)) {
HXLINE( 220)											num2 = (this->curOption->options->length - 1);
            										}
            										else {
HXLINE( 221)											if ((num2 >= this->curOption->options->length)) {
HXLINE( 222)												num2 = 0;
            											}
            										}
HXLINE( 224)										this->curOption->curOption = num2;
HXLINE( 225)										this->curOption->setValue(this->curOption->options->__get(num2));
            									}
            									break;
            									default:{
            									}
            								}
HXLINE( 230)								this->updateTextFrom(this->curOption);
HXLINE( 231)								this->curOption->change();
HXLINE( 232)								 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp9 = ::flixel::FlxG_obj::sound;
HXDLIN( 232)								_hx_tmp9->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),null(),null(),null(),null(),null());
            							}
            							else {
HXLINE( 234)								if (::hx::IsPointerNotEq( this->curOption->type,::options::OptionType_obj::STRING_dyn() )) {
HXLINE( 236)									 ::options::BaseOptionsMenu _hx_tmp10 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 236)									Float _hx_tmp11 = _hx_tmp10->holdValue;
HXDLIN( 236)									Float _hx_tmp12 = (this->curOption->scrollSpeed * elapsed);
HXDLIN( 236)									int _hx_tmp13;
HXDLIN( 236)									if (::backend::Controls_obj::instance->get_UI_LEFT()) {
HXLINE( 236)										_hx_tmp13 = -1;
            									}
            									else {
HXLINE( 236)										_hx_tmp13 = 1;
            									}
HXDLIN( 236)									_hx_tmp10->holdValue = (_hx_tmp11 + (_hx_tmp12 * ( (Float)(_hx_tmp13) )));
HXLINE( 237)									if (::hx::IsLess( this->holdValue,this->curOption->minValue )) {
HXLINE( 237)										this->holdValue = ( (Float)(this->curOption->minValue) );
            									}
            									else {
HXLINE( 238)										if (::hx::IsGreater( this->holdValue,this->curOption->maxValue )) {
HXLINE( 238)											this->holdValue = ( (Float)(this->curOption->maxValue) );
            										}
            									}
HXLINE( 240)									switch((int)(this->curOption->type->_hx_getIndex())){
            										case (int)1: {
HXLINE( 243)											this->curOption->setValue(::Math_obj::round(this->holdValue));
            										}
            										break;
            										case (int)3: {
HXLINE( 246)											 ::Dynamic _hx_tmp14 = this->curOption->setValue;
HXDLIN( 246)											_hx_tmp14(::flixel::math::FlxMath_obj::roundDecimal(this->holdValue,this->curOption->decimals));
            										}
            										break;
            										default:{
            										}
            									}
HXLINE( 250)									this->updateTextFrom(this->curOption);
HXLINE( 251)									this->curOption->change();
            								}
            							}
            						}
HXLINE( 255)						if (::hx::IsPointerNotEq( this->curOption->type,::options::OptionType_obj::STRING_dyn() )) {
HXLINE( 256)							 ::options::BaseOptionsMenu _hx_tmp15 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 256)							_hx_tmp15->holdTime = (_hx_tmp15->holdTime + elapsed);
            						}
            					}
            					else {
HXLINE( 258)						bool _hx_tmp16;
HXDLIN( 258)						if (!(::backend::Controls_obj::instance->get_UI_LEFT_R())) {
HXLINE( 258)							_hx_tmp16 = ::backend::Controls_obj::instance->get_UI_RIGHT_R();
            						}
            						else {
HXLINE( 258)							_hx_tmp16 = true;
            						}
HXDLIN( 258)						if (_hx_tmp16) {
HXLINE( 260)							if ((this->holdTime > ((Float)0.5))) {
HXLINE( 260)								 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp17 = ::flixel::FlxG_obj::sound;
HXDLIN( 260)								_hx_tmp17->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),null(),null(),null(),null(),null());
            							}
HXLINE( 261)							this->holdTime = ( (Float)(0) );
            						}
            					}
            				}
            			}
HXLINE( 265)			if (::backend::Controls_obj::instance->get_RESET()) {
HXLINE( 267)				 ::options::Option leOption = this->optionsArray->__get(this->curSelected).StaticCast<  ::options::Option >();
HXLINE( 268)				if (::hx::IsPointerNotEq( leOption->type,::options::OptionType_obj::KEYBIND_dyn() )) {
HXLINE( 270)					leOption->setValue(leOption->defaultValue);
HXLINE( 271)					if (::hx::IsPointerNotEq( leOption->type,::options::OptionType_obj::BOOL_dyn() )) {
HXLINE( 273)						if (::hx::IsPointerEq( leOption->type,::options::OptionType_obj::STRING_dyn() )) {
HXLINE( 273)							::Array< ::String > leOption1 = leOption->options;
HXDLIN( 273)							leOption->curOption = leOption1->indexOf(leOption->getValue(),null());
            						}
HXLINE( 274)						this->updateTextFrom(leOption);
            					}
            				}
            				else {
HXLINE( 279)					 ::Dynamic _hx_tmp18;
HXDLIN( 279)					if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 279)						_hx_tmp18 =  ::Dynamic(leOption->defaultKeys->__Field(HX_("keyboard",a7,bc,29,68),::hx::paccDynamic));
            					}
            					else {
HXLINE( 279)						_hx_tmp18 =  ::Dynamic(leOption->defaultKeys->__Field(HX_("gamepad",a1,e0,85,89),::hx::paccDynamic));
            					}
HXDLIN( 279)					leOption->setValue(_hx_tmp18);
HXLINE( 280)					this->updateBind(null(),leOption);
            				}
HXLINE( 282)				leOption->change();
HXLINE( 283)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp19 = ::flixel::FlxG_obj::sound;
HXDLIN( 283)				_hx_tmp19->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("cancelMenu",39,a4,43,b7)),null(),true,null()),null(),null(),null(),null(),null());
HXLINE( 284)				this->reloadCheckboxes();
            			}
            		}
HXLINE( 288)		if ((this->nextAccept > 0)) {
HXLINE( 289)			 ::options::BaseOptionsMenu _hx_tmp20 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 289)			_hx_tmp20->nextAccept = (_hx_tmp20->nextAccept - 1);
            		}
            	}


void BaseOptionsMenu_obj::bindingKeyUpdate(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_11861b212311743c_295_bindingKeyUpdate)
HXDLIN( 295)		bool _hx_tmp;
HXDLIN( 295)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 295)		if (!(_this->keyManager->checkStatusUnsafe(27,_this->status))) {
HXDLIN( 295)			_hx_tmp = ::flixel::FlxG_obj::gamepads->anyHasState(1,1);
            		}
            		else {
HXDLIN( 295)			_hx_tmp = true;
            		}
HXDLIN( 295)		if (_hx_tmp) {
HXLINE( 297)			 ::options::BaseOptionsMenu _hx_tmp1 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 297)			_hx_tmp1->holdingEsc = (_hx_tmp1->holdingEsc + elapsed);
HXLINE( 298)			if ((this->holdingEsc > ((Float)0.5))) {
HXLINE( 300)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp2 = ::flixel::FlxG_obj::sound;
HXDLIN( 300)				_hx_tmp2->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("cancelMenu",39,a4,43,b7)),null(),true,null()),null(),null(),null(),null(),null());
HXLINE( 301)				this->closeBinding();
            			}
            		}
            		else {
HXLINE( 304)			bool _hx_tmp3;
HXDLIN( 304)			 ::flixel::input::keyboard::FlxKeyList _this1 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 304)			if (!(_this1->keyManager->checkStatusUnsafe(8,_this1->status))) {
HXLINE( 304)				_hx_tmp3 = ::flixel::FlxG_obj::gamepads->anyHasState(6,1);
            			}
            			else {
HXLINE( 304)				_hx_tmp3 = true;
            			}
HXDLIN( 304)			if (_hx_tmp3) {
HXLINE( 306)				 ::options::BaseOptionsMenu _hx_tmp4 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 306)				_hx_tmp4->holdingEsc = (_hx_tmp4->holdingEsc + elapsed);
HXLINE( 307)				if ((this->holdingEsc > ((Float)0.5))) {
HXLINE( 309)					if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 309)						::String _hx_tmp5 = ::flixel::input::gamepad::_FlxGamepadInputID::FlxGamepadInputID_Impl__obj::toStringMap->get_string(-1);
HXDLIN( 309)						this->curOption->keys->__SetField(HX_("keyboard",a7,bc,29,68),_hx_tmp5,::hx::paccDynamic);
            					}
            					else {
HXLINE( 310)						::String _hx_tmp6 = ::flixel::input::gamepad::_FlxGamepadInputID::FlxGamepadInputID_Impl__obj::toStringMap->get_string(-1);
HXDLIN( 310)						this->curOption->keys->__SetField(HX_("gamepad",a1,e0,85,89),_hx_tmp6,::hx::paccDynamic);
            					}
HXLINE( 311)					::String _hx_tmp7;
HXDLIN( 311)					if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 311)						_hx_tmp7 = ::backend::InputFormatter_obj::getKeyName(-1);
            					}
            					else {
HXLINE( 311)						_hx_tmp7 = ::backend::InputFormatter_obj::getGamepadName(-1);
            					}
HXDLIN( 311)					this->updateBind(_hx_tmp7,null());
HXLINE( 312)					 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp8 = ::flixel::FlxG_obj::sound;
HXDLIN( 312)					_hx_tmp8->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("cancelMenu",39,a4,43,b7)),null(),true,null()),null(),null(),null(),null(),null());
HXLINE( 313)					this->closeBinding();
            				}
            			}
            			else {
HXLINE( 318)				this->holdingEsc = ( (Float)(0) );
HXLINE( 319)				bool changed = false;
HXLINE( 320)				if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 322)					bool _hx_tmp9;
HXDLIN( 322)					if (!(( ( ::flixel::input::FlxBaseKeyList)(::flixel::FlxG_obj::keys->justPressed) )->get_ANY())) {
HXLINE( 322)						_hx_tmp9 = ( ( ::flixel::input::FlxBaseKeyList)(::flixel::FlxG_obj::keys->justReleased) )->get_ANY();
            					}
            					else {
HXLINE( 322)						_hx_tmp9 = true;
            					}
HXDLIN( 322)					if (_hx_tmp9) {
HXLINE( 324)						int keyPressed = ::flixel::FlxG_obj::keys->firstJustPressed();
HXLINE( 325)						int keyReleased = ::flixel::FlxG_obj::keys->firstJustReleased();
HXLINE( 327)						bool _hx_tmp10;
HXDLIN( 327)						bool _hx_tmp11;
HXDLIN( 327)						if ((keyPressed != -1)) {
HXLINE( 327)							_hx_tmp11 = (keyPressed != 27);
            						}
            						else {
HXLINE( 327)							_hx_tmp11 = false;
            						}
HXDLIN( 327)						if (_hx_tmp11) {
HXLINE( 327)							_hx_tmp10 = (keyPressed != 8);
            						}
            						else {
HXLINE( 327)							_hx_tmp10 = false;
            						}
HXDLIN( 327)						if (_hx_tmp10) {
HXLINE( 329)							changed = true;
HXLINE( 330)							::String _hx_tmp12 = ::flixel::input::keyboard::_FlxKey::FlxKey_Impl__obj::toStringMap->get_string(keyPressed);
HXDLIN( 330)							this->curOption->keys->__SetField(HX_("keyboard",a7,bc,29,68),_hx_tmp12,::hx::paccDynamic);
            						}
            						else {
HXLINE( 332)							bool _hx_tmp13;
HXDLIN( 332)							if ((keyReleased != -1)) {
HXLINE( 332)								if ((keyReleased != 27)) {
HXLINE( 332)									_hx_tmp13 = (keyReleased == 8);
            								}
            								else {
HXLINE( 332)									_hx_tmp13 = true;
            								}
            							}
            							else {
HXLINE( 332)								_hx_tmp13 = false;
            							}
HXDLIN( 332)							if (_hx_tmp13) {
HXLINE( 334)								changed = true;
HXLINE( 335)								::String _hx_tmp14 = ::flixel::input::keyboard::_FlxKey::FlxKey_Impl__obj::toStringMap->get_string(keyReleased);
HXDLIN( 335)								this->curOption->keys->__SetField(HX_("keyboard",a7,bc,29,68),_hx_tmp14,::hx::paccDynamic);
            							}
            						}
            					}
            				}
            				else {
HXLINE( 339)					bool _hx_tmp15;
HXDLIN( 339)					bool _hx_tmp16;
HXDLIN( 339)					bool _hx_tmp17;
HXDLIN( 339)					if (!(::flixel::FlxG_obj::gamepads->anyHasState(-2,2))) {
HXLINE( 339)						_hx_tmp17 = ::flixel::FlxG_obj::gamepads->anyHasState(17,2);
            					}
            					else {
HXLINE( 339)						_hx_tmp17 = true;
            					}
HXDLIN( 339)					if (!(_hx_tmp17)) {
HXLINE( 339)						_hx_tmp16 = ::flixel::FlxG_obj::gamepads->anyHasState(18,2);
            					}
            					else {
HXLINE( 339)						_hx_tmp16 = true;
            					}
HXDLIN( 339)					if (!(_hx_tmp16)) {
HXLINE( 339)						_hx_tmp15 = ::flixel::FlxG_obj::gamepads->anyHasState(-2,-1);
            					}
            					else {
HXLINE( 339)						_hx_tmp15 = true;
            					}
HXDLIN( 339)					if (_hx_tmp15) {
HXLINE( 341)						int keyPressed1 = -1;
HXLINE( 342)						int keyReleased1 = -1;
HXLINE( 343)						if (::flixel::FlxG_obj::gamepads->anyHasState(17,2)) {
HXLINE( 344)							keyPressed1 = 17;
            						}
            						else {
HXLINE( 345)							if (::flixel::FlxG_obj::gamepads->anyHasState(18,2)) {
HXLINE( 346)								keyPressed1 = 18;
            							}
            							else {
HXLINE( 349)								int _g = 0;
HXDLIN( 349)								int _g1 = ::flixel::FlxG_obj::gamepads->get_numActiveGamepads();
HXDLIN( 349)								while((_g < _g1)){
HXLINE( 349)									_g = (_g + 1);
HXDLIN( 349)									int i = (_g - 1);
HXLINE( 351)									 ::flixel::input::gamepad::FlxGamepad gamepad = ::flixel::FlxG_obj::gamepads->_activeGamepads->__get(i).StaticCast<  ::flixel::input::gamepad::FlxGamepad >();
HXLINE( 352)									if (::hx::IsNotNull( gamepad )) {
HXLINE( 354)										int id = gamepad->firstJustPressedRawID();
HXDLIN( 354)										int keyPressed2;
HXDLIN( 354)										if ((id < 0)) {
HXLINE( 354)											keyPressed2 = id;
            										}
            										else {
HXLINE( 354)											keyPressed2 = gamepad->mapping->getID(id);
            										}
HXDLIN( 354)										keyPressed1 = keyPressed2;
HXLINE( 355)										int id1 = gamepad->firstJustReleasedRawID();
HXDLIN( 355)										int keyReleased2;
HXDLIN( 355)										if ((id1 < 0)) {
HXLINE( 355)											keyReleased2 = id1;
            										}
            										else {
HXLINE( 355)											keyReleased2 = gamepad->mapping->getID(id1);
            										}
HXDLIN( 355)										keyReleased1 = keyReleased2;
HXLINE( 356)										bool _hx_tmp18;
HXDLIN( 356)										if ((keyPressed1 == -1)) {
HXLINE( 356)											_hx_tmp18 = (keyReleased1 != -1);
            										}
            										else {
HXLINE( 356)											_hx_tmp18 = true;
            										}
HXDLIN( 356)										if (_hx_tmp18) {
HXLINE( 356)											goto _hx_goto_6;
            										}
            									}
            								}
            								_hx_goto_6:;
            							}
            						}
HXLINE( 361)						bool _hx_tmp19;
HXDLIN( 361)						bool _hx_tmp20;
HXDLIN( 361)						if ((keyPressed1 != -1)) {
HXLINE( 361)							_hx_tmp20 = (keyPressed1 != 6);
            						}
            						else {
HXLINE( 361)							_hx_tmp20 = false;
            						}
HXDLIN( 361)						if (_hx_tmp20) {
HXLINE( 361)							_hx_tmp19 = (keyPressed1 != 1);
            						}
            						else {
HXLINE( 361)							_hx_tmp19 = false;
            						}
HXDLIN( 361)						if (_hx_tmp19) {
HXLINE( 363)							changed = true;
HXLINE( 364)							::String _hx_tmp21 = ::flixel::input::gamepad::_FlxGamepadInputID::FlxGamepadInputID_Impl__obj::toStringMap->get_string(keyPressed1);
HXDLIN( 364)							this->curOption->keys->__SetField(HX_("gamepad",a1,e0,85,89),_hx_tmp21,::hx::paccDynamic);
            						}
            						else {
HXLINE( 366)							bool _hx_tmp22;
HXDLIN( 366)							if ((keyReleased1 != -1)) {
HXLINE( 366)								if ((keyReleased1 != 6)) {
HXLINE( 366)									_hx_tmp22 = (keyReleased1 == 1);
            								}
            								else {
HXLINE( 366)									_hx_tmp22 = true;
            								}
            							}
            							else {
HXLINE( 366)								_hx_tmp22 = false;
            							}
HXDLIN( 366)							if (_hx_tmp22) {
HXLINE( 368)								changed = true;
HXLINE( 369)								::String _hx_tmp23 = ::flixel::input::gamepad::_FlxGamepadInputID::FlxGamepadInputID_Impl__obj::toStringMap->get_string(keyReleased1);
HXDLIN( 369)								this->curOption->keys->__SetField(HX_("gamepad",a1,e0,85,89),_hx_tmp23,::hx::paccDynamic);
            							}
            						}
            					}
            				}
HXLINE( 373)				if (changed) {
HXLINE( 375)					::String key = null();
HXLINE( 376)					if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 378)						if (::hx::IsNull( this->curOption->keys->__Field(HX_("keyboard",a7,bc,29,68),::hx::paccDynamic) )) {
HXLINE( 378)							this->curOption->keys->__SetField(HX_("keyboard",a7,bc,29,68),HX_("NONE",b8,da,ca,33),::hx::paccDynamic);
            						}
HXLINE( 379)						this->curOption->setValue( ::Dynamic(this->curOption->keys->__Field(HX_("keyboard",a7,bc,29,68),::hx::paccDynamic)));
HXLINE( 380)						::String s = ( (::String)(this->curOption->keys->__Field(HX_("keyboard",a7,bc,29,68),::hx::paccDynamic)) );
HXDLIN( 380)						s = s.toUpperCase();
HXDLIN( 380)						int key1;
HXDLIN( 380)						if (::flixel::input::keyboard::_FlxKey::FlxKey_Impl__obj::fromStringMap->exists(s)) {
HXLINE( 380)							key1 = ::flixel::input::keyboard::_FlxKey::FlxKey_Impl__obj::fromStringMap->get_int(s);
            						}
            						else {
HXLINE( 380)							key1 = -1;
            						}
HXDLIN( 380)						key = ::backend::InputFormatter_obj::getKeyName(key1);
            					}
            					else {
HXLINE( 384)						if (::hx::IsNull( this->curOption->keys->__Field(HX_("gamepad",a1,e0,85,89),::hx::paccDynamic) )) {
HXLINE( 384)							this->curOption->keys->__SetField(HX_("gamepad",a1,e0,85,89),HX_("NONE",b8,da,ca,33),::hx::paccDynamic);
            						}
HXLINE( 385)						this->curOption->setValue( ::Dynamic(this->curOption->keys->__Field(HX_("gamepad",a1,e0,85,89),::hx::paccDynamic)));
HXLINE( 386)						::String s1 = ( (::String)(this->curOption->keys->__Field(HX_("gamepad",a1,e0,85,89),::hx::paccDynamic)) );
HXDLIN( 386)						s1 = s1.toUpperCase();
HXDLIN( 386)						int key2;
HXDLIN( 386)						if (::flixel::input::gamepad::_FlxGamepadInputID::FlxGamepadInputID_Impl__obj::fromStringMap->exists(s1)) {
HXLINE( 386)							key2 = ::flixel::input::gamepad::_FlxGamepadInputID::FlxGamepadInputID_Impl__obj::fromStringMap->get_int(s1);
            						}
            						else {
HXLINE( 386)							key2 = -1;
            						}
HXDLIN( 386)						key = ::backend::InputFormatter_obj::getGamepadName(key2);
            					}
HXLINE( 388)					this->updateBind(key,null());
HXLINE( 389)					 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp24 = ::flixel::FlxG_obj::sound;
HXDLIN( 389)					_hx_tmp24->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("confirmMenu",bf,8e,fe,3c)),null(),true,null()),null(),null(),null(),null(),null());
HXLINE( 390)					this->closeBinding();
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(BaseOptionsMenu_obj,bindingKeyUpdate,(void))

void BaseOptionsMenu_obj::updateBind(::String text, ::options::Option option){
            	HX_GC_STACKFRAME(&_hx_pos_11861b212311743c_397_updateBind)
HXLINE( 398)		if (::hx::IsNull( option )) {
HXLINE( 398)			option = this->curOption;
            		}
HXLINE( 399)		if (::hx::IsNull( text )) {
HXLINE( 401)			text = ( (::String)(option->getValue()) );
HXLINE( 402)			if (::hx::IsNull( text )) {
HXLINE( 402)				text = HX_("NONE",b8,da,ca,33);
            			}
HXLINE( 404)			if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 405)				::String s = text;
HXDLIN( 405)				s = s.toUpperCase();
HXDLIN( 405)				int text1;
HXDLIN( 405)				if (::flixel::input::keyboard::_FlxKey::FlxKey_Impl__obj::fromStringMap->exists(s)) {
HXLINE( 405)					text1 = ::flixel::input::keyboard::_FlxKey::FlxKey_Impl__obj::fromStringMap->get_int(s);
            				}
            				else {
HXLINE( 405)					text1 = -1;
            				}
HXDLIN( 405)				text = ::backend::InputFormatter_obj::getKeyName(text1);
            			}
            			else {
HXLINE( 407)				::String s1 = text;
HXDLIN( 407)				s1 = s1.toUpperCase();
HXDLIN( 407)				int text2;
HXDLIN( 407)				if (::flixel::input::gamepad::_FlxGamepadInputID::FlxGamepadInputID_Impl__obj::fromStringMap->exists(s1)) {
HXLINE( 407)					text2 = ::flixel::input::gamepad::_FlxGamepadInputID::FlxGamepadInputID_Impl__obj::fromStringMap->get_int(s1);
            				}
            				else {
HXLINE( 407)					text2 = -1;
            				}
HXDLIN( 407)				text = ::backend::InputFormatter_obj::getGamepadName(text2);
            			}
            		}
HXLINE( 410)		 ::objects::AttachedText bind = ( ( ::objects::AttachedText)(option->child) );
HXLINE( 411)		 ::objects::AttachedText attach =  ::objects::AttachedText_obj::__alloc( HX_CTX ,text,bind->offsetX,null(),null(),null());
HXLINE( 412)		attach->sprTracker = bind->sprTracker;
HXLINE( 413)		attach->copyAlpha = true;
HXLINE( 414)		attach->ID = bind->ID;
HXLINE( 415)		this->playstationCheck(attach);
HXLINE( 416)		int _hx_tmp = this->MAX_KEYBIND_WIDTH;
HXDLIN( 416)		attach->set_scaleX(::Math_obj::min(( (Float)(1) ),(( (Float)(_hx_tmp) ) / attach->get_width())));
HXLINE( 417)		attach->set_x(bind->x);
HXLINE( 418)		attach->set_y(bind->y);
HXLINE( 420)		option->child = attach;
HXLINE( 421)		 ::flixel::group::FlxTypedGroup _hx_tmp1 = this->grpTexts;
HXDLIN( 421)		_hx_tmp1->insert(this->grpTexts->members->indexOf(bind,null()),attach).StaticCast<  ::objects::AttachedText >();
HXLINE( 422)		this->grpTexts->remove(bind,null()).StaticCast<  ::objects::AttachedText >();
HXLINE( 423)		bind->destroy();
            	}


HX_DEFINE_DYNAMIC_FUNC2(BaseOptionsMenu_obj,updateBind,(void))

void BaseOptionsMenu_obj::playstationCheck( ::objects::Alphabet alpha){
            	HX_STACKFRAME(&_hx_pos_11861b212311743c_427_playstationCheck)
HXLINE( 428)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 428)			return;
            		}
HXLINE( 430)		 ::flixel::input::gamepad::FlxGamepad gamepad = ::flixel::FlxG_obj::gamepads->firstActive;
HXLINE( 431)		 ::flixel::input::gamepad::FlxGamepadModel model;
HXDLIN( 431)		if (::hx::IsNotNull( gamepad )) {
HXLINE( 431)			model = gamepad->detectedModel;
            		}
            		else {
HXLINE( 431)			model = ::flixel::input::gamepad::FlxGamepadModel_obj::UNKNOWN_dyn();
            		}
HXLINE( 432)		 ::objects::AlphaCharacter letter = alpha->letters->__get(0).StaticCast<  ::objects::AlphaCharacter >();
HXLINE( 433)		if (::hx::IsPointerEq( model,::flixel::input::gamepad::FlxGamepadModel_obj::PS4_dyn() )) {
HXLINE( 435)			::String _hx_switch_0 = alpha->text;
            			if (  (_hx_switch_0==HX_("[",5b,00,00,00)) ||  (_hx_switch_0==HX_("]",5d,00,00,00)) ){
HXLINE( 438)				letter->set_image(HX_("alphabet_playstation",34,6a,13,2b));
HXLINE( 439)				letter->updateHitbox();
HXLINE( 441)				letter->offset->set_x((letter->offset->x + 4));
HXLINE( 442)				letter->offset->set_y((letter->offset->y - ( (Float)(5) )));
HXLINE( 437)				goto _hx_goto_9;
            			}
            			_hx_goto_9:;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(BaseOptionsMenu_obj,playstationCheck,(void))

void BaseOptionsMenu_obj::closeBinding(){
            	HX_STACKFRAME(&_hx_pos_11861b212311743c_448_closeBinding)
HXLINE( 449)		this->bindingKey = false;
HXLINE( 450)		this->bindingBlack->destroy();
HXLINE( 451)		this->remove(this->bindingBlack,null());
HXLINE( 453)		this->bindingText->destroy();
HXLINE( 454)		this->remove(this->bindingText,null());
HXLINE( 456)		this->bindingText2->destroy();
HXLINE( 457)		this->remove(this->bindingText2,null());
HXLINE( 458)		::backend::ClientPrefs_obj::toggleVolumeKeys(true);
            	}


HX_DEFINE_DYNAMIC_FUNC0(BaseOptionsMenu_obj,closeBinding,(void))

void BaseOptionsMenu_obj::updateTextFrom( ::options::Option option){
            	HX_STACKFRAME(&_hx_pos_11861b212311743c_461_updateTextFrom)
HXLINE( 462)		if (::hx::IsPointerEq( option->type,::options::OptionType_obj::KEYBIND_dyn() )) {
HXLINE( 464)			this->updateBind(null(),option);
HXLINE( 465)			return;
            		}
HXLINE( 468)		::String text = option->displayFormat;
HXLINE( 469)		 ::Dynamic val = option->getValue();
HXLINE( 470)		if (::hx::IsPointerEq( option->type,::options::OptionType_obj::PERCENT_dyn() )) {
HXLINE( 470)			val = (val * 100);
            		}
HXLINE( 471)		 ::Dynamic def = option->defaultValue;
HXLINE( 472)		option->set_text(::StringTools_obj::replace(::StringTools_obj::replace(text,HX_("%v",b1,20,00,00),( (::String)(val) )),HX_("%d",9f,20,00,00),( (::String)(def) )));
            	}


HX_DEFINE_DYNAMIC_FUNC1(BaseOptionsMenu_obj,updateTextFrom,(void))

void BaseOptionsMenu_obj::changeSelection(::hx::Null< int >  __o_change){
            		int change = __o_change.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_11861b212311743c_476_changeSelection)
HXLINE( 477)		this->curSelected = ::flixel::math::FlxMath_obj::wrap((this->curSelected + change),0,(this->optionsArray->length - 1));
HXLINE( 479)		this->descText->set_text(this->optionsArray->__get(this->curSelected).StaticCast<  ::options::Option >()->description);
HXLINE( 480)		{
HXLINE( 480)			 ::flixel::text::FlxText _this = this->descText;
HXDLIN( 480)			int axes = 16;
HXDLIN( 480)			bool _hx_tmp;
HXDLIN( 480)			if ((axes != 1)) {
HXLINE( 480)				_hx_tmp = (axes == 17);
            			}
            			else {
HXLINE( 480)				_hx_tmp = true;
            			}
HXDLIN( 480)			if (_hx_tmp) {
HXLINE( 480)				int _hx_tmp1 = ::flixel::FlxG_obj::width;
HXDLIN( 480)				_this->set_x(((( (Float)(_hx_tmp1) ) - _this->get_width()) / ( (Float)(2) )));
            			}
HXDLIN( 480)			bool _hx_tmp2;
HXDLIN( 480)			if ((axes != 16)) {
HXLINE( 480)				_hx_tmp2 = (axes == 17);
            			}
            			else {
HXLINE( 480)				_hx_tmp2 = true;
            			}
HXDLIN( 480)			if (_hx_tmp2) {
HXLINE( 480)				int _hx_tmp3 = ::flixel::FlxG_obj::height;
HXDLIN( 480)				_this->set_y(((( (Float)(_hx_tmp3) ) - _this->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE( 481)		 ::flixel::text::FlxText fh = this->descText;
HXDLIN( 481)		fh->set_y((fh->y + 270));
HXLINE( 483)		{
HXLINE( 483)			int _g_current = 0;
HXDLIN( 483)			::Array< ::Dynamic> _g_array = this->grpOptions->members;
HXDLIN( 483)			while((_g_current < _g_array->length)){
HXLINE( 483)				 ::objects::Alphabet _g_value = _g_array->__get(_g_current).StaticCast<  ::objects::Alphabet >();
HXDLIN( 483)				_g_current = (_g_current + 1);
HXDLIN( 483)				int _g_key = (_g_current - 1);
HXDLIN( 483)				int num = _g_key;
HXDLIN( 483)				 ::objects::Alphabet item = _g_value;
HXLINE( 484)				{
HXLINE( 485)					item->targetY = (num - this->curSelected);
HXLINE( 486)					item->set_alpha(((Float)0.6));
HXLINE( 487)					if ((item->targetY == 0)) {
HXLINE( 487)						item->set_alpha(( (Float)(1) ));
            					}
            				}
            			}
            		}
HXLINE( 489)		{
HXLINE( 489)			 ::Dynamic filter = null();
HXDLIN( 489)			 ::flixel::group::FlxTypedGroupIterator text =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->grpTexts->members,filter);
HXDLIN( 489)			while(text->hasNext()){
HXLINE( 489)				 ::objects::AttachedText text1 = text->next().StaticCast<  ::objects::AttachedText >();
HXLINE( 491)				text1->set_alpha(((Float)0.6));
HXLINE( 492)				if ((text1->ID == this->curSelected)) {
HXLINE( 492)					text1->set_alpha(( (Float)(1) ));
            				}
            			}
            		}
HXLINE( 495)		this->descBox->setPosition((this->descText->x - ( (Float)(10) )),(this->descText->y - ( (Float)(10) )));
HXLINE( 496)		 ::flixel::FlxSprite _hx_tmp4 = this->descBox;
HXDLIN( 496)		int _hx_tmp5 = ::Std_obj::_hx_int((this->descText->get_width() + 20));
HXDLIN( 496)		_hx_tmp4->setGraphicSize(_hx_tmp5,::Std_obj::_hx_int((this->descText->get_height() + 25)));
HXLINE( 497)		this->descBox->updateHitbox();
HXLINE( 499)		this->curOption = this->optionsArray->__get(this->curSelected).StaticCast<  ::options::Option >();
HXLINE( 500)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp6 = ::flixel::FlxG_obj::sound;
HXDLIN( 500)		_hx_tmp6->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),null(),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(BaseOptionsMenu_obj,changeSelection,(void))

void BaseOptionsMenu_obj::reloadCheckboxes(){
            	HX_GC_STACKFRAME(&_hx_pos_11861b212311743c_504_reloadCheckboxes)
HXDLIN( 504)		 ::Dynamic filter = null();
HXDLIN( 504)		 ::flixel::group::FlxTypedGroupIterator checkbox =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->checkboxGroup->members,filter);
HXDLIN( 504)		while(checkbox->hasNext()){
HXDLIN( 504)			 ::objects::CheckboxThingie checkbox1 = checkbox->next().StaticCast<  ::objects::CheckboxThingie >();
HXLINE( 505)			checkbox1->set_daValue((::Std_obj::string(this->optionsArray->__get(checkbox1->ID).StaticCast<  ::options::Option >()->getValue()) == HX_("true",4e,a7,03,4d)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(BaseOptionsMenu_obj,reloadCheckboxes,(void))


::hx::ObjectPtr< BaseOptionsMenu_obj > BaseOptionsMenu_obj::__new() {
	::hx::ObjectPtr< BaseOptionsMenu_obj > __this = new BaseOptionsMenu_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< BaseOptionsMenu_obj > BaseOptionsMenu_obj::__alloc(::hx::Ctx *_hx_ctx) {
	BaseOptionsMenu_obj *__this = (BaseOptionsMenu_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(BaseOptionsMenu_obj), true, "options.BaseOptionsMenu"));
	*(void **)__this = BaseOptionsMenu_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

BaseOptionsMenu_obj::BaseOptionsMenu_obj()
{
}

void BaseOptionsMenu_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(BaseOptionsMenu);
	HX_MARK_MEMBER_NAME(curOption,"curOption");
	HX_MARK_MEMBER_NAME(curSelected,"curSelected");
	HX_MARK_MEMBER_NAME(optionsArray,"optionsArray");
	HX_MARK_MEMBER_NAME(grpOptions,"grpOptions");
	HX_MARK_MEMBER_NAME(checkboxGroup,"checkboxGroup");
	HX_MARK_MEMBER_NAME(grpTexts,"grpTexts");
	HX_MARK_MEMBER_NAME(descBox,"descBox");
	HX_MARK_MEMBER_NAME(descText,"descText");
	HX_MARK_MEMBER_NAME(title,"title");
	HX_MARK_MEMBER_NAME(rpcTitle,"rpcTitle");
	HX_MARK_MEMBER_NAME(bg,"bg");
	HX_MARK_MEMBER_NAME(nextAccept,"nextAccept");
	HX_MARK_MEMBER_NAME(holdTime,"holdTime");
	HX_MARK_MEMBER_NAME(holdValue,"holdValue");
	HX_MARK_MEMBER_NAME(bindingKey,"bindingKey");
	HX_MARK_MEMBER_NAME(holdingEsc,"holdingEsc");
	HX_MARK_MEMBER_NAME(bindingBlack,"bindingBlack");
	HX_MARK_MEMBER_NAME(bindingText,"bindingText");
	HX_MARK_MEMBER_NAME(bindingText2,"bindingText2");
	HX_MARK_MEMBER_NAME(MAX_KEYBIND_WIDTH,"MAX_KEYBIND_WIDTH");
	 ::flixel::FlxSubState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void BaseOptionsMenu_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(curOption,"curOption");
	HX_VISIT_MEMBER_NAME(curSelected,"curSelected");
	HX_VISIT_MEMBER_NAME(optionsArray,"optionsArray");
	HX_VISIT_MEMBER_NAME(grpOptions,"grpOptions");
	HX_VISIT_MEMBER_NAME(checkboxGroup,"checkboxGroup");
	HX_VISIT_MEMBER_NAME(grpTexts,"grpTexts");
	HX_VISIT_MEMBER_NAME(descBox,"descBox");
	HX_VISIT_MEMBER_NAME(descText,"descText");
	HX_VISIT_MEMBER_NAME(title,"title");
	HX_VISIT_MEMBER_NAME(rpcTitle,"rpcTitle");
	HX_VISIT_MEMBER_NAME(bg,"bg");
	HX_VISIT_MEMBER_NAME(nextAccept,"nextAccept");
	HX_VISIT_MEMBER_NAME(holdTime,"holdTime");
	HX_VISIT_MEMBER_NAME(holdValue,"holdValue");
	HX_VISIT_MEMBER_NAME(bindingKey,"bindingKey");
	HX_VISIT_MEMBER_NAME(holdingEsc,"holdingEsc");
	HX_VISIT_MEMBER_NAME(bindingBlack,"bindingBlack");
	HX_VISIT_MEMBER_NAME(bindingText,"bindingText");
	HX_VISIT_MEMBER_NAME(bindingText2,"bindingText2");
	HX_VISIT_MEMBER_NAME(MAX_KEYBIND_WIDTH,"MAX_KEYBIND_WIDTH");
	 ::flixel::FlxSubState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val BaseOptionsMenu_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"bg") ) { return ::hx::Val( bg ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"title") ) { return ::hx::Val( title ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"descBox") ) { return ::hx::Val( descBox ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"grpTexts") ) { return ::hx::Val( grpTexts ); }
		if (HX_FIELD_EQ(inName,"descText") ) { return ::hx::Val( descText ); }
		if (HX_FIELD_EQ(inName,"rpcTitle") ) { return ::hx::Val( rpcTitle ); }
		if (HX_FIELD_EQ(inName,"holdTime") ) { return ::hx::Val( holdTime ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"curOption") ) { return ::hx::Val( curOption ); }
		if (HX_FIELD_EQ(inName,"addOption") ) { return ::hx::Val( addOption_dyn() ); }
		if (HX_FIELD_EQ(inName,"holdValue") ) { return ::hx::Val( holdValue ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"grpOptions") ) { return ::hx::Val( grpOptions ); }
		if (HX_FIELD_EQ(inName,"nextAccept") ) { return ::hx::Val( nextAccept ); }
		if (HX_FIELD_EQ(inName,"bindingKey") ) { return ::hx::Val( bindingKey ); }
		if (HX_FIELD_EQ(inName,"holdingEsc") ) { return ::hx::Val( holdingEsc ); }
		if (HX_FIELD_EQ(inName,"updateBind") ) { return ::hx::Val( updateBind_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"curSelected") ) { return ::hx::Val( curSelected ); }
		if (HX_FIELD_EQ(inName,"bindingText") ) { return ::hx::Val( bindingText ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"optionsArray") ) { return ::hx::Val( optionsArray ); }
		if (HX_FIELD_EQ(inName,"bindingBlack") ) { return ::hx::Val( bindingBlack ); }
		if (HX_FIELD_EQ(inName,"bindingText2") ) { return ::hx::Val( bindingText2 ); }
		if (HX_FIELD_EQ(inName,"closeBinding") ) { return ::hx::Val( closeBinding_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"checkboxGroup") ) { return ::hx::Val( checkboxGroup ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"updateTextFrom") ) { return ::hx::Val( updateTextFrom_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"changeSelection") ) { return ::hx::Val( changeSelection_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"bindingKeyUpdate") ) { return ::hx::Val( bindingKeyUpdate_dyn() ); }
		if (HX_FIELD_EQ(inName,"playstationCheck") ) { return ::hx::Val( playstationCheck_dyn() ); }
		if (HX_FIELD_EQ(inName,"reloadCheckboxes") ) { return ::hx::Val( reloadCheckboxes_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"MAX_KEYBIND_WIDTH") ) { return ::hx::Val( MAX_KEYBIND_WIDTH ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val BaseOptionsMenu_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"bg") ) { bg=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"title") ) { title=inValue.Cast< ::String >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"descBox") ) { descBox=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"grpTexts") ) { grpTexts=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"descText") ) { descText=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		if (HX_FIELD_EQ(inName,"rpcTitle") ) { rpcTitle=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdTime") ) { holdTime=inValue.Cast< Float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"curOption") ) { curOption=inValue.Cast<  ::options::Option >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdValue") ) { holdValue=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"grpOptions") ) { grpOptions=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"nextAccept") ) { nextAccept=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bindingKey") ) { bindingKey=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdingEsc") ) { holdingEsc=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"curSelected") ) { curSelected=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bindingText") ) { bindingText=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"optionsArray") ) { optionsArray=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bindingBlack") ) { bindingBlack=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bindingText2") ) { bindingText2=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"checkboxGroup") ) { checkboxGroup=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"MAX_KEYBIND_WIDTH") ) { MAX_KEYBIND_WIDTH=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void BaseOptionsMenu_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("curOption",15,ed,07,9c));
	outFields->push(HX_("curSelected",fb,eb,ab,32));
	outFields->push(HX_("optionsArray",5b,b5,f1,e8));
	outFields->push(HX_("grpOptions",f9,45,d8,00));
	outFields->push(HX_("checkboxGroup",fc,3d,bc,23));
	outFields->push(HX_("grpTexts",01,f1,99,f0));
	outFields->push(HX_("descBox",3a,20,25,19));
	outFields->push(HX_("descText",9e,53,35,f3));
	outFields->push(HX_("title",98,15,3b,10));
	outFields->push(HX_("rpcTitle",73,04,98,e2));
	outFields->push(HX_("bg",c5,55,00,00));
	outFields->push(HX_("nextAccept",5b,44,38,c0));
	outFields->push(HX_("holdTime",ec,cc,bf,3e));
	outFields->push(HX_("holdValue",b2,41,96,ca));
	outFields->push(HX_("bindingKey",5a,4f,70,89));
	outFields->push(HX_("holdingEsc",f2,2e,6e,8a));
	outFields->push(HX_("bindingBlack",3a,c0,99,d7));
	outFields->push(HX_("bindingText",92,0a,c8,be));
	outFields->push(HX_("bindingText2",60,35,41,30));
	outFields->push(HX_("MAX_KEYBIND_WIDTH",a8,6e,06,d8));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo BaseOptionsMenu_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::options::Option */ ,(int)offsetof(BaseOptionsMenu_obj,curOption),HX_("curOption",15,ed,07,9c)},
	{::hx::fsInt,(int)offsetof(BaseOptionsMenu_obj,curSelected),HX_("curSelected",fb,eb,ab,32)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(BaseOptionsMenu_obj,optionsArray),HX_("optionsArray",5b,b5,f1,e8)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(BaseOptionsMenu_obj,grpOptions),HX_("grpOptions",f9,45,d8,00)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(BaseOptionsMenu_obj,checkboxGroup),HX_("checkboxGroup",fc,3d,bc,23)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(BaseOptionsMenu_obj,grpTexts),HX_("grpTexts",01,f1,99,f0)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(BaseOptionsMenu_obj,descBox),HX_("descBox",3a,20,25,19)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(BaseOptionsMenu_obj,descText),HX_("descText",9e,53,35,f3)},
	{::hx::fsString,(int)offsetof(BaseOptionsMenu_obj,title),HX_("title",98,15,3b,10)},
	{::hx::fsString,(int)offsetof(BaseOptionsMenu_obj,rpcTitle),HX_("rpcTitle",73,04,98,e2)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(BaseOptionsMenu_obj,bg),HX_("bg",c5,55,00,00)},
	{::hx::fsInt,(int)offsetof(BaseOptionsMenu_obj,nextAccept),HX_("nextAccept",5b,44,38,c0)},
	{::hx::fsFloat,(int)offsetof(BaseOptionsMenu_obj,holdTime),HX_("holdTime",ec,cc,bf,3e)},
	{::hx::fsFloat,(int)offsetof(BaseOptionsMenu_obj,holdValue),HX_("holdValue",b2,41,96,ca)},
	{::hx::fsBool,(int)offsetof(BaseOptionsMenu_obj,bindingKey),HX_("bindingKey",5a,4f,70,89)},
	{::hx::fsFloat,(int)offsetof(BaseOptionsMenu_obj,holdingEsc),HX_("holdingEsc",f2,2e,6e,8a)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(BaseOptionsMenu_obj,bindingBlack),HX_("bindingBlack",3a,c0,99,d7)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(BaseOptionsMenu_obj,bindingText),HX_("bindingText",92,0a,c8,be)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(BaseOptionsMenu_obj,bindingText2),HX_("bindingText2",60,35,41,30)},
	{::hx::fsInt,(int)offsetof(BaseOptionsMenu_obj,MAX_KEYBIND_WIDTH),HX_("MAX_KEYBIND_WIDTH",a8,6e,06,d8)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *BaseOptionsMenu_obj_sStaticStorageInfo = 0;
#endif

static ::String BaseOptionsMenu_obj_sMemberFields[] = {
	HX_("curOption",15,ed,07,9c),
	HX_("curSelected",fb,eb,ab,32),
	HX_("optionsArray",5b,b5,f1,e8),
	HX_("grpOptions",f9,45,d8,00),
	HX_("checkboxGroup",fc,3d,bc,23),
	HX_("grpTexts",01,f1,99,f0),
	HX_("descBox",3a,20,25,19),
	HX_("descText",9e,53,35,f3),
	HX_("title",98,15,3b,10),
	HX_("rpcTitle",73,04,98,e2),
	HX_("bg",c5,55,00,00),
	HX_("addOption",76,08,9f,e3),
	HX_("nextAccept",5b,44,38,c0),
	HX_("holdTime",ec,cc,bf,3e),
	HX_("holdValue",b2,41,96,ca),
	HX_("bindingKey",5a,4f,70,89),
	HX_("holdingEsc",f2,2e,6e,8a),
	HX_("bindingBlack",3a,c0,99,d7),
	HX_("bindingText",92,0a,c8,be),
	HX_("bindingText2",60,35,41,30),
	HX_("update",09,86,05,87),
	HX_("bindingKeyUpdate",03,49,3b,b7),
	HX_("MAX_KEYBIND_WIDTH",a8,6e,06,d8),
	HX_("updateBind",66,e0,cb,f9),
	HX_("playstationCheck",a8,29,e8,6b),
	HX_("closeBinding",6d,82,fe,ca),
	HX_("updateTextFrom",e0,eb,e7,7b),
	HX_("changeSelection",bc,98,b5,48),
	HX_("reloadCheckboxes",2a,e2,2a,45),
	::String(null()) };

::hx::Class BaseOptionsMenu_obj::__mClass;

void BaseOptionsMenu_obj::__register()
{
	BaseOptionsMenu_obj _hx_dummy;
	BaseOptionsMenu_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("options.BaseOptionsMenu",5c,5e,30,7f);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(BaseOptionsMenu_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< BaseOptionsMenu_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = BaseOptionsMenu_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = BaseOptionsMenu_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace options
