// Generated by Haxe 4.3.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_backend_ClientPrefs
#include <backend/ClientPrefs.h>
#endif
#ifndef INCLUDED_backend_Controls
#include <backend/Controls.h>
#endif
#ifndef INCLUDED_backend_DiscordClient
#include <backend/DiscordClient.h>
#endif
#ifndef INCLUDED_backend_Language
#include <backend/Language.h>
#endif
#ifndef INCLUDED_backend_MusicBeatState
#include <backend/MusicBeatState.h>
#endif
#ifndef INCLUDED_backend_MusicBeatSubstate
#include <backend/MusicBeatSubstate.h>
#endif
#ifndef INCLUDED_backend_Paths
#include <backend/Paths.h>
#endif
#ifndef INCLUDED_backend_SaveVariables
#include <backend/SaveVariables.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_FlxSubState
#include <flixel/FlxSubState.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxBackdrop
#include <flixel/addons/display/FlxBackdrop.h>
#endif
#ifndef INCLUDED_flixel_addons_display_FlxGridOverlay
#include <flixel/addons/display/FlxGridOverlay.h>
#endif
#ifndef INCLUDED_flixel_addons_display_shapes_FlxShape
#include <flixel/addons/display/shapes/FlxShape.h>
#endif
#ifndef INCLUDED_flixel_addons_display_shapes_FlxShapeCircle
#include <flixel/addons/display/shapes/FlxShapeCircle.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroupIterator
#include <flixel/group/FlxTypedGroupIterator.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedSpriteGroup
#include <flixel/group/FlxTypedSpriteGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxInput
#include <flixel/input/FlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepad
#include <flixel/input/gamepad/FlxGamepad.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadAnalogStick
#include <flixel/input/gamepad/FlxGamepadAnalogStick.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_FlxGamepadManager
#include <flixel/input/gamepad/FlxGamepadManager.h>
#endif
#ifndef INCLUDED_flixel_input_gamepad_mappings_FlxGamepadMapping
#include <flixel/input/gamepad/mappings/FlxGamepadMapping.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouseButton
#include <flixel/input/mouse/FlxMouseButton.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMath
#include <flixel/math/FlxMath.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSound
#include <flixel/sound/FlxSound.h>
#endif
#ifndef INCLUDED_flixel_sound_FlxSoundGroup
#include <flixel/sound/FlxSoundGroup.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SoundFrontEnd
#include <flixel/system/frontEnds/SoundFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxEase
#include <flixel/tweens/FlxEase.h>
#endif
#ifndef INCLUDED_flixel_tweens_FlxTween
#include <flixel/tweens/FlxTween.h>
#endif
#ifndef INCLUDED_flixel_tweens_misc_VarTween
#include <flixel/tweens/misc/VarTween.h>
#endif
#ifndef INCLUDED_flixel_util_FlxGradient
#include <flixel/util/FlxGradient.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_lime_system_Clipboard
#include <lime/system/Clipboard.h>
#endif
#ifndef INCLUDED_objects_Alignment
#include <objects/Alignment.h>
#endif
#ifndef INCLUDED_objects_AlphaCharacter
#include <objects/AlphaCharacter.h>
#endif
#ifndef INCLUDED_objects_Alphabet
#include <objects/Alphabet.h>
#endif
#ifndef INCLUDED_objects_Note
#include <objects/Note.h>
#endif
#ifndef INCLUDED_objects_StrumNote
#include <objects/StrumNote.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_media_Sound
#include <openfl/media/Sound.h>
#endif
#ifndef INCLUDED_options_NotesColorSubState
#include <options/NotesColorSubState.h>
#endif
#ifndef INCLUDED_shaders_RGBPalette
#include <shaders/RGBPalette.h>
#endif
#ifndef INCLUDED_shaders_RGBPaletteShader
#include <shaders/RGBPaletteShader.h>
#endif
#ifndef INCLUDED_shaders_RGBShaderReference
#include <shaders/RGBShaderReference.h>
#endif
#ifndef INCLUDED_states_PlayState
#include <states/PlayState.h>
#endif
#ifndef INCLUDED_sys_FileSystem
#include <sys/FileSystem.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_1dccb24f48fccdae_16_new,"options.NotesColorSubState","new",0x4a050995,"options.NotesColorSubState.new","options/NotesColorSubState.hx",16,0xf56d49da)
static const int _hx_array_data_87d99b23_2[] = {
	(int)-1,(int)-16777216,
};
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_173_updateTip,"options.NotesColorSubState","updateTip",0x8ab8cdc7,"options.NotesColorSubState.updateTip","options/NotesColorSubState.hx",173,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_186_update,"options.NotesColorSubState","update",0x72263bf4,"options.NotesColorSubState.update","options/NotesColorSubState.hx",186,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_373_update,"options.NotesColorSubState","update",0x72263bf4,"options.NotesColorSubState.update","options/NotesColorSubState.hx",373,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_386_update,"options.NotesColorSubState","update",0x72263bf4,"options.NotesColorSubState.update","options/NotesColorSubState.hx",386,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_498_pointerOverlaps,"options.NotesColorSubState","pointerOverlaps",0x9ff5899e,"options.NotesColorSubState.pointerOverlaps","options/NotesColorSubState.hx",498,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_504_pointerX,"options.NotesColorSubState","pointerX",0x29912ba6,"options.NotesColorSubState.pointerX","options/NotesColorSubState.hx",504,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_509_pointerY,"options.NotesColorSubState","pointerY",0x29912ba7,"options.NotesColorSubState.pointerY","options/NotesColorSubState.hx",509,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_514_pointerFlxPoint,"options.NotesColorSubState","pointerFlxPoint",0x0482b910,"options.NotesColorSubState.pointerFlxPoint","options/NotesColorSubState.hx",514,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_520_centerHexTypeLine,"options.NotesColorSubState","centerHexTypeLine",0x2886c1e9,"options.NotesColorSubState.centerHexTypeLine","options/NotesColorSubState.hx",520,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_536_changeSelectionMode,"options.NotesColorSubState","changeSelectionMode",0x83de5974,"options.NotesColorSubState.changeSelectionMode","options/NotesColorSubState.hx",536,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_548_changeSelectionNote,"options.NotesColorSubState","changeSelectionNote",0x84879e03,"options.NotesColorSubState.changeSelectionNote","options/NotesColorSubState.hx",548,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_565_makeColorAlphabet,"options.NotesColorSubState","makeColorAlphabet",0x16a44a5d,"options.NotesColorSubState.makeColorAlphabet","options/NotesColorSubState.hx",565,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_584_spawnNotes,"options.NotesColorSubState","spawnNotes",0xab2cbf71,"options.NotesColorSubState.spawnNotes","options/NotesColorSubState.hx",584,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_588_spawnNotes,"options.NotesColorSubState","spawnNotes",0xab2cbf71,"options.NotesColorSubState.spawnNotes","options/NotesColorSubState.hx",588,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_579_spawnNotes,"options.NotesColorSubState","spawnNotes",0xab2cbf71,"options.NotesColorSubState.spawnNotes","options/NotesColorSubState.hx",579,0xf56d49da)
static const int _hx_array_data_87d99b23_25[] = {
	(int)0,
};
static const int _hx_array_data_87d99b23_26[] = {
	(int)0,
};
static const int _hx_array_data_87d99b23_27[] = {
	(int)1,
};
static const int _hx_array_data_87d99b23_28[] = {
	(int)2,
};
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_660_updateNotes,"options.NotesColorSubState","updateNotes",0xd4703bad,"options.NotesColorSubState.updateNotes","options/NotesColorSubState.hx",660,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_676_updateColors,"options.NotesColorSubState","updateColors",0xa294e4c4,"options.NotesColorSubState.updateColors","options/NotesColorSubState.hx",676,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_707_setShaderColor,"options.NotesColorSubState","setShaderColor",0x27407067,"options.NotesColorSubState.setShaderColor","options/NotesColorSubState.hx",707,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_708_getShaderColor,"options.NotesColorSubState","getShaderColor",0x072087f3,"options.NotesColorSubState.getShaderColor","options/NotesColorSubState.hx",708,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_709_getShader,"options.NotesColorSubState","getShader",0xa14ad750,"options.NotesColorSubState.getShader","options/NotesColorSubState.hx",709,0xf56d49da)
HX_LOCAL_STACK_FRAME(_hx_pos_1dccb24f48fccdae_712_destroy,"options.NotesColorSubState","destroy",0xf604a4af,"options.NotesColorSubState.destroy","options/NotesColorSubState.hx",712,0xf56d49da)
namespace options{

void NotesColorSubState_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_1dccb24f48fccdae_16_new)
HXLINE( 181)		 ::haxe::ds::IntMap _g =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN( 181)		_g->set(48,HX_("0",30,00,00,00));
HXDLIN( 181)		_g->set(49,HX_("1",31,00,00,00));
HXDLIN( 181)		_g->set(50,HX_("2",32,00,00,00));
HXDLIN( 181)		_g->set(51,HX_("3",33,00,00,00));
HXDLIN( 181)		_g->set(52,HX_("4",34,00,00,00));
HXDLIN( 181)		_g->set(53,HX_("5",35,00,00,00));
HXDLIN( 181)		_g->set(54,HX_("6",36,00,00,00));
HXDLIN( 181)		_g->set(55,HX_("7",37,00,00,00));
HXDLIN( 181)		_g->set(56,HX_("8",38,00,00,00));
HXDLIN( 181)		_g->set(57,HX_("9",39,00,00,00));
HXDLIN( 181)		_g->set(96,HX_("0",30,00,00,00));
HXDLIN( 181)		_g->set(97,HX_("1",31,00,00,00));
HXDLIN( 181)		_g->set(98,HX_("2",32,00,00,00));
HXDLIN( 181)		_g->set(99,HX_("3",33,00,00,00));
HXDLIN( 181)		_g->set(100,HX_("4",34,00,00,00));
HXDLIN( 181)		_g->set(101,HX_("5",35,00,00,00));
HXDLIN( 181)		_g->set(102,HX_("6",36,00,00,00));
HXDLIN( 181)		_g->set(103,HX_("7",37,00,00,00));
HXDLIN( 181)		_g->set(104,HX_("8",38,00,00,00));
HXDLIN( 181)		_g->set(105,HX_("9",39,00,00,00));
HXDLIN( 181)		_g->set(65,HX_("A",41,00,00,00));
HXDLIN( 181)		_g->set(66,HX_("B",42,00,00,00));
HXDLIN( 181)		_g->set(67,HX_("C",43,00,00,00));
HXDLIN( 181)		_g->set(68,HX_("D",44,00,00,00));
HXDLIN( 181)		_g->set(69,HX_("E",45,00,00,00));
HXDLIN( 181)		_g->set(70,HX_("F",46,00,00,00));
HXDLIN( 181)		this->allowedTypeKeys = _g;
HXLINE( 179)		this->changingNote = false;
HXLINE(  47)		this->_lastControllerMode = false;
HXLINE(  26)		this->hexTypeVisibleTimer = ((Float)0);
HXLINE(  25)		this->hexTypeNum = -1;
HXLINE(  21)		this->onPixel = false;
HXLINE(  20)		this->curSelectedNote = 0;
HXLINE(  19)		this->curSelectedMode = 0;
HXLINE(  18)		this->onModeColumn = true;
HXLINE(  51)		super::__construct();
HXLINE(  54)		::backend::DiscordClient_obj::changePresence(HX_("Note Colors Menu",01,01,06,42),null(),null(),null(),null(),null());
HXLINE(  57)		this->onPixel = ::states::PlayState_obj::get_isPixelStage();
HXLINE(  58)		 ::flixel::FlxSprite bg =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXDLIN(  58)		 ::flixel::FlxSprite bg1 = bg->loadGraphic(::backend::Paths_obj::image(HX_("menuDesat",26,91,04,72),null(),null()),null(),null(),null(),null(),null());
HXLINE(  59)		bg1->set_color(-1412611);
HXLINE(  60)		{
HXLINE(  60)			int axes = 17;
HXDLIN(  60)			bool _hx_tmp;
HXDLIN(  60)			if ((axes != 1)) {
HXLINE(  60)				_hx_tmp = (axes == 17);
            			}
            			else {
HXLINE(  60)				_hx_tmp = true;
            			}
HXDLIN(  60)			if (_hx_tmp) {
HXLINE(  60)				int _hx_tmp1 = ::flixel::FlxG_obj::width;
HXDLIN(  60)				bg1->set_x(((( (Float)(_hx_tmp1) ) - bg1->get_width()) / ( (Float)(2) )));
            			}
HXDLIN(  60)			bool _hx_tmp2;
HXDLIN(  60)			if ((axes != 16)) {
HXLINE(  60)				_hx_tmp2 = (axes == 17);
            			}
            			else {
HXLINE(  60)				_hx_tmp2 = true;
            			}
HXDLIN(  60)			if (_hx_tmp2) {
HXLINE(  60)				int _hx_tmp3 = ::flixel::FlxG_obj::height;
HXDLIN(  60)				bg1->set_y(((( (Float)(_hx_tmp3) ) - bg1->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE(  61)		bg1->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE(  62)		this->add(bg1);
HXLINE(  64)		 ::flixel::addons::display::FlxBackdrop grid =  ::flixel::addons::display::FlxBackdrop_obj::__alloc( HX_CTX ,::flixel::addons::display::FlxGridOverlay_obj::createGrid(80,80,160,160,true,872415231,0),null(),null(),null());
HXLINE(  65)		{
HXLINE(  65)			 ::flixel::math::FlxBasePoint this1 = grid->velocity;
HXDLIN(  65)			this1->set_x(( (Float)(40) ));
HXDLIN(  65)			this1->set_y(( (Float)(40) ));
            		}
HXLINE(  66)		grid->set_alpha(( (Float)(0) ));
HXLINE(  67)		::flixel::tweens::FlxTween_obj::tween(grid, ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("alpha",5e,a7,96,21),1)),((Float)0.5), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("ease",ee,8b,0c,43),::flixel::tweens::FlxEase_obj::quadOut_dyn())));
HXLINE(  68)		this->add(grid);
HXLINE(  70)		this->modeBG =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,215,85,null())->makeGraphic(315,115,-16777216,null(),null());
HXLINE(  71)		this->modeBG->set_visible(false);
HXLINE(  72)		this->modeBG->set_alpha(((Float)0.4));
HXLINE(  73)		this->add(this->modeBG);
HXLINE(  75)		this->notesBG =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,140,190,null())->makeGraphic(480,125,-16777216,null(),null());
HXLINE(  76)		this->notesBG->set_visible(false);
HXLINE(  77)		this->notesBG->set_alpha(((Float)0.4));
HXLINE(  78)		this->add(this->notesBG);
HXLINE(  80)		this->modeNotes =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  81)		this->add(this->modeNotes);
HXLINE(  83)		this->myNotes =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  84)		this->add(this->myNotes);
HXLINE(  86)		 ::flixel::FlxSprite bg2 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,720,null(),null());
HXDLIN(  86)		 ::flixel::FlxSprite bg3 = bg2->makeGraphic((::flixel::FlxG_obj::width - 720),::flixel::FlxG_obj::height,-16777216,null(),null());
HXLINE(  87)		bg3->set_alpha(((Float)0.25));
HXLINE(  88)		this->add(bg3);
HXLINE(  89)		 ::flixel::FlxSprite bg4 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,750,160,null());
HXDLIN(  89)		 ::flixel::FlxSprite bg5 = bg4->makeGraphic((::flixel::FlxG_obj::width - 780),540,-16777216,null(),null());
HXLINE(  90)		bg5->set_alpha(((Float)0.25));
HXLINE(  91)		this->add(bg5);
HXLINE(  93)		 ::objects::Alphabet text =  ::objects::Alphabet_obj::__alloc( HX_CTX ,( (Float)(50) ),( (Float)(86) ),HX_("CTRL",ab,50,89,2c),false);
HXLINE(  94)		text->set_alignment(::objects::Alignment_obj::CENTERED_dyn());
HXLINE(  95)		text->setScale(((Float)0.4),null());
HXLINE(  96)		this->add(text);
HXLINE(  98)		 ::flixel::FlxSprite _hx_tmp4 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,760,50,null());
HXDLIN(  98)		this->copyButton = _hx_tmp4->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/copy",14,93,08,23),null(),null()),null(),null(),null(),null(),null());
HXLINE(  99)		this->copyButton->set_alpha(((Float)0.6));
HXLINE( 100)		this->add(this->copyButton);
HXLINE( 102)		 ::flixel::FlxSprite _hx_tmp5 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,1180,50,null());
HXDLIN( 102)		this->pasteButton = _hx_tmp5->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/paste",14,ef,6e,f7),null(),null()),null(),null(),null(),null(),null());
HXLINE( 103)		this->pasteButton->set_alpha(((Float)0.6));
HXLINE( 104)		this->add(this->pasteButton);
HXLINE( 106)		this->colorGradient = ::flixel::util::FlxGradient_obj::createGradientFlxSprite(60,360,::Array_obj< int >::fromData( _hx_array_data_87d99b23_2,2),null(),null(),null());
HXLINE( 107)		this->colorGradient->setPosition(780,200);
HXLINE( 108)		this->add(this->colorGradient);
HXLINE( 110)		this->colorGradientSelector =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,770,200,null())->makeGraphic(80,10,-1,null(),null());
HXLINE( 111)		this->colorGradientSelector->offset->set_y(( (Float)(5) ));
HXLINE( 112)		this->add(this->colorGradientSelector);
HXLINE( 114)		 ::flixel::FlxSprite _hx_tmp6 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,820,580,null());
HXDLIN( 114)		this->colorPalette = _hx_tmp6->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/palette",7c,60,ab,d2),null(),false),null(),null(),null(),null(),null());
HXLINE( 115)		{
HXLINE( 115)			 ::flixel::math::FlxBasePoint this2 = this->colorPalette->scale;
HXDLIN( 115)			this2->set_x(( (Float)(20) ));
HXDLIN( 115)			this2->set_y(( (Float)(20) ));
            		}
HXLINE( 116)		this->colorPalette->updateHitbox();
HXLINE( 117)		this->colorPalette->set_antialiasing(false);
HXLINE( 118)		this->add(this->colorPalette);
HXLINE( 120)		 ::flixel::FlxSprite _hx_tmp7 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,860,200,null());
HXDLIN( 120)		this->colorWheel = _hx_tmp7->loadGraphic(::backend::Paths_obj::image(HX_("noteColorMenu/colorWheel",d7,74,dc,98),null(),null()),null(),null(),null(),null(),null());
HXLINE( 121)		this->colorWheel->setGraphicSize(360,360);
HXLINE( 122)		this->colorWheel->updateHitbox();
HXLINE( 123)		this->add(this->colorWheel);
HXLINE( 125)		this->colorWheelSelector =  ::flixel::addons::display::shapes::FlxShapeCircle_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),( (Float)(8) ), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("thickness",74,f1,66,5a),0)),-1);
HXLINE( 126)		{
HXLINE( 126)			 ::flixel::math::FlxBasePoint this3 = this->colorWheelSelector->offset;
HXDLIN( 126)			this3->set_x(( (Float)(8) ));
HXDLIN( 126)			this3->set_y(( (Float)(8) ));
            		}
HXLINE( 127)		this->colorWheelSelector->set_alpha(((Float)0.6));
HXLINE( 128)		this->add(this->colorWheelSelector);
HXLINE( 130)		int txtX = 980;
HXLINE( 131)		int txtY = 90;
HXLINE( 132)		this->alphabetR = this->makeColorAlphabet((txtX - 100),txtY);
HXLINE( 133)		this->add(this->alphabetR);
HXLINE( 134)		this->alphabetG = this->makeColorAlphabet(txtX,txtY);
HXLINE( 135)		this->add(this->alphabetG);
HXLINE( 136)		this->alphabetB = this->makeColorAlphabet((txtX + 100),txtY);
HXLINE( 137)		this->add(this->alphabetB);
HXLINE( 138)		this->alphabetHex = this->makeColorAlphabet(txtX,(txtY - 55));
HXLINE( 139)		this->add(this->alphabetHex);
HXLINE( 140)		this->hexTypeLine =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,0,20,null())->makeGraphic(5,62,-1,null(),null());
HXLINE( 141)		this->hexTypeLine->set_visible(false);
HXLINE( 142)		this->add(this->hexTypeLine);
HXLINE( 144)		this->spawnNotes();
HXLINE( 145)		this->updateNotes(true);
HXLINE( 146)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp8 = ::flixel::FlxG_obj::sound;
HXDLIN( 146)		_hx_tmp8->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 148)		int tipX = 20;
HXLINE( 149)		int tipY = 660;
HXLINE( 150)		::cpp::VirtualArray values = null();
HXDLIN( 150)		::Dynamic this4 = ::backend::Language_obj::phrases;
HXDLIN( 150)		 ::EReg hideChars =  ::EReg_obj::__alloc( HX_CTX ,HX_("[~&\\\\/;:<>#.,'\"%?!]",85,3f,6d,6d),HX_("g",67,00,00,00));
HXDLIN( 150)		::String str = ( ( ::haxe::ds::StringMap)(this4) )->get_string(::StringTools_obj::trim(hideChars->replace(::StringTools_obj::replace(HX_("note_colors_tip",79,ba,05,d3),HX_(" ",20,00,00,00),HX_("_",5f,00,00,00)),HX_("",00,00,00,00)).toLowerCase()));
HXDLIN( 150)		if (::hx::IsNull( str )) {
HXLINE(  62)			str = HX_("Press RESET to Reset the selected Note Part.",7b,64,f4,7a);
            		}
HXLINE( 150)		if (::hx::IsNull( str )) {
HXLINE(  68)			str = HX_("note_colors_tip",79,ba,05,d3);
            		}
HXLINE( 150)		if (::hx::IsNotNull( values )) {
HXLINE( 150)			int _g_current = 0;
HXDLIN( 150)			::cpp::VirtualArray _g_array = values;
HXDLIN( 150)			while((_g_current < _g_array->get_length())){
HXLINE( 150)				 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 150)				_g_current = (_g_current + 1);
HXDLIN( 150)				int _g_key = (_g_current - 1);
HXDLIN( 150)				int num = _g_key;
HXDLIN( 150)				 ::Dynamic value = _g_value;
HXLINE(  72)				str = ::StringTools_obj::replace(str,((HX_("{",7b,00,00,00) + (num + 1)) + HX_("}",7d,00,00,00)),( (::String)(value) ));
            			}
            		}
HXLINE( 150)		 ::flixel::text::FlxText tip =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,tipX,tipY,0,str,16,null());
HXLINE( 151)		::String key = (HX_("fonts/",eb,13,ef,fa) + HX_("vcr.ttf",9d,d2,a7,82));
HXDLIN( 151)		::Dynamic this5 = ::backend::Language_obj::phrases;
HXDLIN( 151)		::String str1 = ( ( ::haxe::ds::StringMap)(this5) )->get_string(::StringTools_obj::trim(key).toLowerCase());
HXDLIN( 151)		if (::hx::IsNotNull( str1 )) {
HXLINE(  82)			key = str1;
            		}
HXLINE( 151)		::String folderKey = key;
HXDLIN( 151)		::String file = ::backend::Paths_obj::modFolders(folderKey);
HXDLIN( 151)		::String _hx_tmp9;
HXDLIN( 151)		if (::sys::FileSystem_obj::exists(file)) {
HXLINE( 151)			_hx_tmp9 = file;
            		}
            		else {
HXLINE( 151)			_hx_tmp9 = (HX_("assets/",4c,2a,dc,36) + folderKey);
            		}
HXDLIN( 151)		tip->setFormat(_hx_tmp9,16,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 152)		tip->set_borderSize(( (Float)(2) ));
HXLINE( 153)		this->add(tip);
HXLINE( 155)		this->tipTxt =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,tipX,(tipY + 24),0,HX_("",00,00,00,00),16,null());
HXLINE( 156)		 ::flixel::text::FlxText _hx_tmp10 = this->tipTxt;
HXDLIN( 156)		::String key1 = (HX_("fonts/",eb,13,ef,fa) + HX_("vcr.ttf",9d,d2,a7,82));
HXDLIN( 156)		::Dynamic this6 = ::backend::Language_obj::phrases;
HXDLIN( 156)		::String str2 = ( ( ::haxe::ds::StringMap)(this6) )->get_string(::StringTools_obj::trim(key1).toLowerCase());
HXDLIN( 156)		if (::hx::IsNotNull( str2 )) {
HXLINE(  82)			key1 = str2;
            		}
HXLINE( 156)		::String folderKey1 = key1;
HXDLIN( 156)		::String file1 = ::backend::Paths_obj::modFolders(folderKey1);
HXDLIN( 156)		::String _hx_tmp11;
HXDLIN( 156)		if (::sys::FileSystem_obj::exists(file1)) {
HXLINE( 156)			_hx_tmp11 = file1;
            		}
            		else {
HXLINE( 156)			_hx_tmp11 = (HX_("assets/",4c,2a,dc,36) + folderKey1);
            		}
HXDLIN( 156)		_hx_tmp10->setFormat(_hx_tmp11,16,-1,HX_("left",07,08,b0,47),::flixel::text::FlxTextBorderStyle_obj::OUTLINE_dyn(),-16777216,null());
HXLINE( 157)		this->tipTxt->set_borderSize(( (Float)(2) ));
HXLINE( 158)		this->add(this->tipTxt);
HXLINE( 159)		this->updateTip();
HXLINE( 161)		this->controllerPointer =  ::flixel::addons::display::shapes::FlxShapeCircle_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ),( (Float)(20) ), ::Dynamic(::hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("thickness",74,f1,66,5a),0)),-1);
HXLINE( 162)		{
HXLINE( 162)			 ::flixel::math::FlxBasePoint this7 = this->controllerPointer->offset;
HXDLIN( 162)			this7->set_x(( (Float)(20) ));
HXDLIN( 162)			this7->set_y(( (Float)(20) ));
            		}
HXLINE( 163)		{
HXLINE( 163)			 ::flixel::FlxSprite _this = this->controllerPointer;
HXDLIN( 163)			int axes1 = 17;
HXDLIN( 163)			bool _hx_tmp12;
HXDLIN( 163)			if ((axes1 != 1)) {
HXLINE( 163)				_hx_tmp12 = (axes1 == 17);
            			}
            			else {
HXLINE( 163)				_hx_tmp12 = true;
            			}
HXDLIN( 163)			if (_hx_tmp12) {
HXLINE( 163)				int _hx_tmp13 = ::flixel::FlxG_obj::width;
HXDLIN( 163)				_this->set_x(((( (Float)(_hx_tmp13) ) - _this->get_width()) / ( (Float)(2) )));
            			}
HXDLIN( 163)			bool _hx_tmp14;
HXDLIN( 163)			if ((axes1 != 16)) {
HXLINE( 163)				_hx_tmp14 = (axes1 == 17);
            			}
            			else {
HXLINE( 163)				_hx_tmp14 = true;
            			}
HXDLIN( 163)			if (_hx_tmp14) {
HXLINE( 163)				int _hx_tmp15 = ::flixel::FlxG_obj::height;
HXDLIN( 163)				_this->set_y(((( (Float)(_hx_tmp15) ) - _this->get_height()) / ( (Float)(2) )));
            			}
            		}
HXLINE( 164)		this->controllerPointer->set_alpha(((Float)0.6));
HXLINE( 165)		this->add(this->controllerPointer);
HXLINE( 167)		::flixel::FlxG_obj::mouse->set_visible(!(::backend::Controls_obj::instance->controllerMode));
HXLINE( 168)		this->controllerPointer->set_visible(::backend::Controls_obj::instance->controllerMode);
HXLINE( 169)		this->_lastControllerMode = ::backend::Controls_obj::instance->controllerMode;
            	}

Dynamic NotesColorSubState_obj::__CreateEmpty() { return new NotesColorSubState_obj; }

void *NotesColorSubState_obj::_hx_vtable = 0;

Dynamic NotesColorSubState_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< NotesColorSubState_obj > _hx_result = new NotesColorSubState_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool NotesColorSubState_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x5661ffbf) {
		if (inClassId<=(int)0x3c0818b8) {
			if (inClassId<=(int)0x1df65f8d) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x1df65f8d;
			} else {
				return inClassId==(int)0x3c0818b8;
			}
		} else {
			return inClassId==(int)0x5661ffbf;
		}
	} else {
		if (inClassId<=(int)0x7c795c9f) {
			return inClassId==(int)0x62817b24 || inClassId==(int)0x7c795c9f;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	}
}

void NotesColorSubState_obj::updateTip(){
            	HX_GC_STACKFRAME(&_hx_pos_1dccb24f48fccdae_173_updateTip)
HXLINE( 174)		::String key;
HXDLIN( 174)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 174)			::cpp::VirtualArray values = null();
HXDLIN( 174)			::Dynamic this1 = ::backend::Language_obj::phrases;
HXDLIN( 174)			 ::EReg hideChars =  ::EReg_obj::__alloc( HX_CTX ,HX_("[~&\\\\/;:<>#.,'\"%?!]",85,3f,6d,6d),HX_("g",67,00,00,00));
HXDLIN( 174)			::String str = ( ( ::haxe::ds::StringMap)(this1) )->get_string(::StringTools_obj::trim(hideChars->replace(::StringTools_obj::replace(HX_("note_colors_shift",20,49,af,57),HX_(" ",20,00,00,00),HX_("_",5f,00,00,00)),HX_("",00,00,00,00)).toLowerCase()));
HXDLIN( 174)			if (::hx::IsNull( str )) {
HXLINE(  62)				str = HX_("Shift",62,5c,50,0f);
            			}
HXLINE( 174)			if (::hx::IsNull( str )) {
HXLINE(  68)				str = HX_("note_colors_shift",20,49,af,57);
            			}
HXLINE( 174)			if (::hx::IsNotNull( values )) {
HXLINE( 174)				int _g_current = 0;
HXDLIN( 174)				::cpp::VirtualArray _g_array = values;
HXDLIN( 174)				while((_g_current < _g_array->get_length())){
HXLINE( 174)					 ::Dynamic _g_value = _g_array->__get(_g_current);
HXDLIN( 174)					_g_current = (_g_current + 1);
HXDLIN( 174)					int _g_key = (_g_current - 1);
HXDLIN( 174)					int num = _g_key;
HXDLIN( 174)					 ::Dynamic value = _g_value;
HXLINE(  72)					str = ::StringTools_obj::replace(str,((HX_("{",7b,00,00,00) + (num + 1)) + HX_("}",7d,00,00,00)),( (::String)(value) ));
            				}
            			}
HXLINE( 174)			key = str;
            		}
            		else {
HXLINE( 174)			::cpp::VirtualArray values1 = null();
HXDLIN( 174)			::Dynamic this2 = ::backend::Language_obj::phrases;
HXDLIN( 174)			 ::EReg hideChars1 =  ::EReg_obj::__alloc( HX_CTX ,HX_("[~&\\\\/;:<>#.,'\"%?!]",85,3f,6d,6d),HX_("g",67,00,00,00));
HXDLIN( 174)			::String str1 = ( ( ::haxe::ds::StringMap)(this2) )->get_string(::StringTools_obj::trim(hideChars1->replace(::StringTools_obj::replace(HX_("note_colors_lb",18,13,f1,1f),HX_(" ",20,00,00,00),HX_("_",5f,00,00,00)),HX_("",00,00,00,00)).toLowerCase()));
HXDLIN( 174)			if (::hx::IsNull( str1 )) {
HXLINE(  62)				str1 = HX_("Left Shoulder Button",b9,84,12,11);
            			}
HXLINE( 174)			if (::hx::IsNull( str1 )) {
HXLINE(  68)				str1 = HX_("note_colors_lb",18,13,f1,1f);
            			}
HXLINE( 174)			if (::hx::IsNotNull( values1 )) {
HXLINE( 174)				int _g_current1 = 0;
HXDLIN( 174)				::cpp::VirtualArray _g_array1 = values1;
HXDLIN( 174)				while((_g_current1 < _g_array1->get_length())){
HXLINE( 174)					 ::Dynamic _g_value1 = _g_array1->__get(_g_current1);
HXDLIN( 174)					_g_current1 = (_g_current1 + 1);
HXDLIN( 174)					int _g_key1 = (_g_current1 - 1);
HXDLIN( 174)					int num1 = _g_key1;
HXDLIN( 174)					 ::Dynamic value1 = _g_value1;
HXLINE(  72)					str1 = ::StringTools_obj::replace(str1,((HX_("{",7b,00,00,00) + (num1 + 1)) + HX_("}",7d,00,00,00)),( (::String)(value1) ));
            				}
            			}
HXLINE( 174)			key = str1;
            		}
HXLINE( 175)		 ::flixel::text::FlxText _hx_tmp = this->tipTxt;
HXDLIN( 175)		::cpp::VirtualArray values2 = ::cpp::VirtualArray_obj::__new(1)->init(0,key);
HXDLIN( 175)		::Dynamic this3 = ::backend::Language_obj::phrases;
HXDLIN( 175)		 ::EReg hideChars2 =  ::EReg_obj::__alloc( HX_CTX ,HX_("[~&\\\\/;:<>#.,'\"%?!]",85,3f,6d,6d),HX_("g",67,00,00,00));
HXDLIN( 175)		::String str2 = ( ( ::haxe::ds::StringMap)(this3) )->get_string(::StringTools_obj::trim(hideChars2->replace(::StringTools_obj::replace(HX_("note_colors_hold_tip",3d,55,12,62),HX_(" ",20,00,00,00),HX_("_",5f,00,00,00)),HX_("",00,00,00,00)).toLowerCase()));
HXDLIN( 175)		if (::hx::IsNull( str2 )) {
HXLINE(  62)			str2 = HX_("Hold {1} + Press RESET key to fully reset the selected Note.",54,29,ac,5a);
            		}
HXLINE( 175)		if (::hx::IsNull( str2 )) {
HXLINE(  68)			str2 = HX_("note_colors_hold_tip",3d,55,12,62);
            		}
HXLINE( 175)		if (::hx::IsNotNull( values2 )) {
HXLINE( 175)			int _g_current2 = 0;
HXDLIN( 175)			::cpp::VirtualArray _g_array2 = values2;
HXDLIN( 175)			while((_g_current2 < _g_array2->get_length())){
HXLINE( 175)				 ::Dynamic _g_value2 = _g_array2->__get(_g_current2);
HXDLIN( 175)				_g_current2 = (_g_current2 + 1);
HXDLIN( 175)				int _g_key2 = (_g_current2 - 1);
HXDLIN( 175)				int num2 = _g_key2;
HXDLIN( 175)				 ::Dynamic value2 = _g_value2;
HXLINE(  72)				str2 = ::StringTools_obj::replace(str2,((HX_("{",7b,00,00,00) + (num2 + 1)) + HX_("}",7d,00,00,00)),( (::String)(value2) ));
            			}
            		}
HXLINE( 175)		_hx_tmp->set_text(str2);
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesColorSubState_obj,updateTip,(void))

void NotesColorSubState_obj::update(Float elapsed){
            	HX_GC_STACKFRAME(&_hx_pos_1dccb24f48fccdae_186_update)
HXDLIN( 186)		 ::options::NotesColorSubState _gthis = ::hx::ObjectPtr<OBJ_>(this);
HXLINE( 187)		if (::backend::Controls_obj::instance->get_BACK()) {
HXLINE( 188)			::flixel::FlxG_obj::mouse->set_visible(false);
HXLINE( 189)			 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp = ::flixel::FlxG_obj::sound;
HXDLIN( 189)			_hx_tmp->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("cancelMenu",39,a4,43,b7)),null(),true,null()),null(),null(),null(),null(),null());
HXLINE( 190)			this->close();
HXLINE( 191)			return;
            		}
HXLINE( 194)		this->super::update(elapsed);
HXLINE( 197)		if (::flixel::FlxG_obj::gamepads->anyHasState(-2,2)) {
HXLINE( 197)			::backend::Controls_obj::instance->controllerMode = true;
            		}
            		else {
HXLINE( 198)			bool _hx_tmp1;
HXDLIN( 198)			bool _hx_tmp2;
HXDLIN( 198)			if ((::flixel::FlxG_obj::mouse->_leftButton->current != 2)) {
HXLINE( 198)				 ::flixel::input::mouse::FlxMouse _this = ::flixel::FlxG_obj::mouse;
HXDLIN( 198)				_hx_tmp2 = ((_this->screenX - _this->_prevScreenX) != 0);
            			}
            			else {
HXLINE( 198)				_hx_tmp2 = true;
            			}
HXDLIN( 198)			if (!(_hx_tmp2)) {
HXLINE( 198)				 ::flixel::input::mouse::FlxMouse _this1 = ::flixel::FlxG_obj::mouse;
HXDLIN( 198)				_hx_tmp1 = ((_this1->screenY - _this1->_prevScreenY) != 0);
            			}
            			else {
HXLINE( 198)				_hx_tmp1 = true;
            			}
HXDLIN( 198)			if (_hx_tmp1) {
HXLINE( 198)				::backend::Controls_obj::instance->controllerMode = false;
            			}
            		}
HXLINE( 201)		bool changedToController = false;
HXLINE( 202)		if ((::backend::Controls_obj::instance->controllerMode != this->_lastControllerMode)) {
HXLINE( 205)			::flixel::FlxG_obj::mouse->set_visible(!(::backend::Controls_obj::instance->controllerMode));
HXLINE( 206)			this->controllerPointer->set_visible(::backend::Controls_obj::instance->controllerMode);
HXLINE( 209)			if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 211)				this->controllerPointer->set_x(( (Float)(::flixel::FlxG_obj::mouse->x) ));
HXLINE( 212)				this->controllerPointer->set_y(( (Float)(::flixel::FlxG_obj::mouse->y) ));
HXLINE( 213)				changedToController = true;
            			}
HXLINE( 223)			this->_lastControllerMode = ::backend::Controls_obj::instance->controllerMode;
HXLINE( 224)			this->updateTip();
            		}
HXLINE( 228)		Float analogX = ( (Float)(0) );
HXLINE( 229)		Float analogY = ( (Float)(0) );
HXLINE( 230)		bool analogMoved = false;
HXLINE( 231)		bool _hx_tmp3;
HXDLIN( 231)		if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 231)			if (!(changedToController)) {
HXLINE( 231)				_hx_tmp3 = ::flixel::FlxG_obj::gamepads->anyInput();
            			}
            			else {
HXLINE( 231)				_hx_tmp3 = true;
            			}
            		}
            		else {
HXLINE( 231)			_hx_tmp3 = false;
            		}
HXDLIN( 231)		if (_hx_tmp3) {
HXLINE( 233)			{
HXLINE( 233)				int _g = 0;
HXDLIN( 233)				::Array< ::Dynamic> _g1 = ::flixel::FlxG_obj::gamepads->getActiveGamepads(null());
HXDLIN( 233)				while((_g < _g1->length)){
HXLINE( 233)					 ::flixel::input::gamepad::FlxGamepad gamepad = _g1->__get(_g).StaticCast<  ::flixel::input::gamepad::FlxGamepad >();
HXDLIN( 233)					_g = (_g + 1);
HXLINE( 235)					analogX = gamepad->getAnalogXAxisValue(gamepad->mapping->getAnalogStick(19));
HXLINE( 236)					analogY = gamepad->getYAxisRaw(gamepad->mapping->getAnalogStick(19));
HXLINE( 237)					if ((analogX == 0)) {
HXLINE( 237)						analogMoved = (analogY != 0);
            					}
            					else {
HXLINE( 237)						analogMoved = true;
            					}
HXLINE( 238)					if (analogMoved) {
HXLINE( 238)						goto _hx_goto_7;
            					}
            				}
            				_hx_goto_7:;
            			}
HXLINE( 240)			this->controllerPointer->set_x(::Math_obj::max(( (Float)(0) ),::Math_obj::min(( (Float)(::flixel::FlxG_obj::width) ),(this->controllerPointer->x + ((analogX * ( (Float)(1000) )) * elapsed)))));
HXLINE( 241)			this->controllerPointer->set_y(::Math_obj::max(( (Float)(0) ),::Math_obj::min(( (Float)(::flixel::FlxG_obj::height) ),(this->controllerPointer->y + ((analogY * ( (Float)(1000) )) * elapsed)))));
            		}
HXLINE( 243)		bool controllerPressed;
HXDLIN( 243)		if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 243)			controllerPressed = ::backend::Controls_obj::instance->get_ACCEPT();
            		}
            		else {
HXLINE( 243)			controllerPressed = false;
            		}
HXLINE( 246)		 ::flixel::input::keyboard::FlxKeyList _this2 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 246)		if (_this2->keyManager->checkStatusUnsafe(17,_this2->status)) {
HXLINE( 248)			this->onPixel = !(this->onPixel);
HXLINE( 249)			this->spawnNotes();
HXLINE( 250)			this->updateNotes(true);
HXLINE( 251)			 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp4 = ::flixel::FlxG_obj::sound;
HXDLIN( 251)			_hx_tmp4->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
            		}
HXLINE( 254)		if ((this->hexTypeNum > -1)) {
HXLINE( 256)			int keyPressed = ::flixel::FlxG_obj::keys->firstJustPressed();
HXLINE( 257)			 ::options::NotesColorSubState _hx_tmp5 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 257)			_hx_tmp5->hexTypeVisibleTimer = (_hx_tmp5->hexTypeVisibleTimer + elapsed);
HXLINE( 258)			bool changed = false;
HXLINE( 259)			 ::flixel::input::keyboard::FlxKeyList _this3 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 259)			changed = _this3->keyManager->checkStatusUnsafe(37,_this3->status);
HXDLIN( 259)			if (changed) {
HXLINE( 260)				this->hexTypeNum--;
            			}
            			else {
HXLINE( 261)				 ::flixel::input::keyboard::FlxKeyList _this4 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 261)				changed = _this4->keyManager->checkStatusUnsafe(39,_this4->status);
HXDLIN( 261)				if (changed) {
HXLINE( 262)					this->hexTypeNum++;
            				}
            				else {
HXLINE( 263)					if (this->allowedTypeKeys->exists(keyPressed)) {
HXLINE( 266)						::String curColor = this->alphabetHex->text;
HXLINE( 267)						::String newColor = curColor.substring(0,this->hexTypeNum);
HXDLIN( 267)						::String newColor1 = (newColor + this->allowedTypeKeys->get(keyPressed));
HXDLIN( 267)						::String newColor2 = (newColor1 + curColor.substring((this->hexTypeNum + 1),null()));
HXLINE( 269)						int colorHex = ( (int)(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromString((HX_("#",23,00,00,00) + newColor2))) );
HXLINE( 270)						this->setShaderColor(colorHex);
HXLINE( 271)						this->_storedColor = this->getShaderColor();
HXLINE( 272)						this->updateColors(null());
HXLINE( 275)						this->hexTypeNum++;
HXLINE( 276)						changed = true;
            					}
            					else {
HXLINE( 278)						 ::flixel::input::keyboard::FlxKeyList _this5 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN( 278)						if (_this5->keyManager->checkStatusUnsafe(13,_this5->status)) {
HXLINE( 279)							this->hexTypeNum = -1;
            						}
            					}
            				}
            			}
HXLINE( 281)			bool end = false;
HXLINE( 282)			if (changed) {
HXLINE( 284)				if ((this->hexTypeNum > 5)) {
HXLINE( 286)					this->hexTypeNum = -1;
HXLINE( 287)					end = true;
HXLINE( 288)					this->hexTypeLine->set_visible(false);
            				}
            				else {
HXLINE( 292)					if ((this->hexTypeNum < 0)) {
HXLINE( 292)						this->hexTypeNum = 0;
            					}
            					else {
HXLINE( 293)						if ((this->hexTypeNum > 5)) {
HXLINE( 293)							this->hexTypeNum = 5;
            						}
            					}
HXLINE( 294)					this->centerHexTypeLine();
HXLINE( 295)					this->hexTypeLine->set_visible(true);
            				}
HXLINE( 297)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp6 = ::flixel::FlxG_obj::sound;
HXDLIN( 297)				_hx_tmp6->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
            			}
HXLINE( 299)			if (!(end)) {
HXLINE( 299)				this->hexTypeLine->set_visible((::hx::Mod(::Math_obj::floor((this->hexTypeVisibleTimer * ( (Float)(2) ))),2) == 0));
            			}
            		}
            		else {
HXLINE( 303)			int add = 0;
HXLINE( 304)			bool _hx_tmp7;
HXDLIN( 304)			if ((analogX == 0)) {
HXLINE( 304)				_hx_tmp7 = !(changedToController);
            			}
            			else {
HXLINE( 304)				_hx_tmp7 = false;
            			}
HXDLIN( 304)			if (_hx_tmp7) {
HXLINE( 306)				if (::backend::Controls_obj::instance->get_UI_LEFT_P()) {
HXLINE( 306)					add = -1;
            				}
            				else {
HXLINE( 307)					if (::backend::Controls_obj::instance->get_UI_RIGHT_P()) {
HXLINE( 307)						add = 1;
            					}
            				}
            			}
HXLINE( 310)			bool _hx_tmp8;
HXDLIN( 310)			bool _hx_tmp9;
HXDLIN( 310)			if ((analogY == 0)) {
HXLINE( 310)				_hx_tmp9 = !(changedToController);
            			}
            			else {
HXLINE( 310)				_hx_tmp9 = false;
            			}
HXDLIN( 310)			if (_hx_tmp9) {
HXLINE( 310)				if (!(::backend::Controls_obj::instance->get_UI_UP_P())) {
HXLINE( 310)					_hx_tmp8 = ::backend::Controls_obj::instance->get_UI_DOWN_P();
            				}
            				else {
HXLINE( 310)					_hx_tmp8 = true;
            				}
            			}
            			else {
HXLINE( 310)				_hx_tmp8 = false;
            			}
HXDLIN( 310)			if (_hx_tmp8) {
HXLINE( 312)				this->onModeColumn = !(this->onModeColumn);
HXLINE( 313)				this->modeBG->set_visible(this->onModeColumn);
HXLINE( 314)				this->notesBG->set_visible(!(this->onModeColumn));
            			}
HXLINE( 317)			if ((add != 0)) {
HXLINE( 319)				if (this->onModeColumn) {
HXLINE( 319)					this->changeSelectionMode(add);
            				}
            				else {
HXLINE( 320)					this->changeSelectionNote(add);
            				}
            			}
HXLINE( 322)			this->hexTypeLine->set_visible(false);
            		}
HXLINE( 326)		bool generalMoved;
HXDLIN( 326)		 ::flixel::input::mouse::FlxMouse _this6 = ::flixel::FlxG_obj::mouse;
HXDLIN( 326)		bool generalMoved1;
HXDLIN( 326)		if ((_this6->_prevX == _this6->x)) {
HXLINE( 326)			generalMoved1 = (_this6->_prevY != _this6->y);
            		}
            		else {
HXLINE( 326)			generalMoved1 = true;
            		}
HXDLIN( 326)		if (!(generalMoved1)) {
HXLINE( 326)			generalMoved = analogMoved;
            		}
            		else {
HXLINE( 326)			generalMoved = true;
            		}
HXLINE( 327)		bool generalPressed;
HXDLIN( 327)		if ((::flixel::FlxG_obj::mouse->_leftButton->current != 2)) {
HXLINE( 327)			generalPressed = controllerPressed;
            		}
            		else {
HXLINE( 327)			generalPressed = true;
            		}
HXLINE( 328)		if (generalMoved) {
HXLINE( 330)			this->copyButton->set_alpha(((Float)0.6));
HXLINE( 331)			this->pasteButton->set_alpha(((Float)0.6));
            		}
HXLINE( 334)		if (this->pointerOverlaps(this->copyButton)) {
HXLINE( 336)			this->copyButton->set_alpha(( (Float)(1) ));
HXLINE( 337)			if (generalPressed) {
HXLINE( 339)				int this1 = this->getShaderColor();
HXDLIN( 339)				::String _hx_tmp10 = (HX_("",00,00,00,00) + ::StringTools_obj::hex(((this1 >> 16) & 255),2));
HXDLIN( 339)				::String _hx_tmp11 = (_hx_tmp10 + ::StringTools_obj::hex(((this1 >> 8) & 255),2));
HXDLIN( 339)				::lime::_hx_system::Clipboard_obj::set_text((_hx_tmp11 + ::StringTools_obj::hex((this1 & 255),2)));
HXLINE( 340)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp12 = ::flixel::FlxG_obj::sound;
HXDLIN( 340)				_hx_tmp12->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 341)				 ::Dynamic _hx_tmp13 = ::haxe::Log_obj::trace;
HXDLIN( 341)				::String _hx_tmp14 = (HX_("copied: ",ea,92,6a,a6) + ::lime::_hx_system::Clipboard_obj::get_text());
HXDLIN( 341)				_hx_tmp13(_hx_tmp14,::hx::SourceInfo(HX_("source/options/NotesColorSubState.hx",66,ca,6d,0b),341,HX_("options.NotesColorSubState",23,9b,d9,87),HX_("update",09,86,05,87)));
            			}
HXLINE( 343)			this->hexTypeNum = -1;
            		}
            		else {
HXLINE( 345)			if (this->pointerOverlaps(this->pasteButton)) {
HXLINE( 347)				this->pasteButton->set_alpha(( (Float)(1) ));
HXLINE( 348)				if (generalPressed) {
HXLINE( 350)					::String formattedText = ::StringTools_obj::replace(::StringTools_obj::replace(::StringTools_obj::trim(::lime::_hx_system::Clipboard_obj::get_text()).toUpperCase(),HX_("#",23,00,00,00),HX_("",00,00,00,00)),HX_("0x",48,2a,00,00),HX_("",00,00,00,00));
HXLINE( 351)					 ::Dynamic newColor3 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::fromString((HX_("#",23,00,00,00) + formattedText));
HXLINE( 353)					bool _hx_tmp15;
HXDLIN( 353)					if (::hx::IsNotNull( newColor3 )) {
HXLINE( 353)						_hx_tmp15 = (formattedText.length == 6);
            					}
            					else {
HXLINE( 353)						_hx_tmp15 = false;
            					}
HXDLIN( 353)					if (_hx_tmp15) {
HXLINE( 355)						this->setShaderColor(( (int)(newColor3) ));
HXLINE( 356)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp16 = ::flixel::FlxG_obj::sound;
HXDLIN( 356)						_hx_tmp16->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 357)						this->_storedColor = this->getShaderColor();
HXLINE( 358)						this->updateColors(null());
            					}
            					else {
HXLINE( 361)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp17 = ::flixel::FlxG_obj::sound;
HXDLIN( 361)						_hx_tmp17->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("cancelMenu",39,a4,43,b7)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
            					}
            				}
HXLINE( 363)				this->hexTypeNum = -1;
            			}
            		}
HXLINE( 367)		if (generalPressed) {
HXLINE( 369)			this->hexTypeNum = -1;
HXLINE( 370)			if (this->pointerOverlaps(this->modeNotes)) {
            				HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::options::NotesColorSubState,_gthis) HXARGC(1)
            				void _hx_run( ::flixel::FlxSprite note){
            					HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_373_update)
HXLINE( 373)					bool _hx_tmp;
HXDLIN( 373)					if ((_gthis->curSelectedMode != note->ID)) {
HXLINE( 373)						_hx_tmp = _gthis->pointerOverlaps(note);
            					}
            					else {
HXLINE( 373)						_hx_tmp = false;
            					}
HXDLIN( 373)					if (_hx_tmp) {
HXLINE( 375)						 ::flixel::FlxSprite _gthis1 = _gthis->modeBG;
HXDLIN( 375)						_gthis1->set_visible(_gthis->notesBG->set_visible(false));
HXLINE( 376)						_gthis->curSelectedMode = note->ID;
HXLINE( 377)						_gthis->onModeColumn = true;
HXLINE( 378)						_gthis->updateNotes(null());
HXLINE( 379)						 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 379)						_hx_tmp1->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
            					}
            				}
            				HX_END_LOCAL_FUNC1((void))

HXLINE( 372)				this->modeNotes->forEachAlive( ::Dynamic(new _hx_Closure_0(_gthis)),null());
            			}
            			else {
HXLINE( 383)				if (this->pointerOverlaps(this->myNotes)) {
            					HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_1, ::options::NotesColorSubState,_gthis) HXARGC(1)
            					void _hx_run( ::objects::StrumNote note){
            						HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_386_update)
HXLINE( 386)						bool _hx_tmp;
HXDLIN( 386)						if ((_gthis->curSelectedNote != note->ID)) {
HXLINE( 386)							_hx_tmp = _gthis->pointerOverlaps(note);
            						}
            						else {
HXLINE( 386)							_hx_tmp = false;
            						}
HXDLIN( 386)						if (_hx_tmp) {
HXLINE( 388)							 ::flixel::FlxSprite _gthis1 = _gthis->modeBG;
HXDLIN( 388)							_gthis1->set_visible(_gthis->notesBG->set_visible(false));
HXLINE( 389)							_gthis->curSelectedNote = note->ID;
HXLINE( 390)							_gthis->onModeColumn = false;
HXLINE( 391)							_gthis->bigNote->rgbShader->parent = ::objects::Note_obj::globalRgbShaders->__get(note->ID).StaticCast<  ::shaders::RGBPalette >();
HXLINE( 392)							_gthis->bigNote->shader = ::objects::Note_obj::globalRgbShaders->__get(note->ID).StaticCast<  ::shaders::RGBPalette >()->shader;
HXLINE( 393)							_gthis->updateNotes(null());
HXLINE( 394)							 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 394)							_hx_tmp1->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
            						}
            					}
            					HX_END_LOCAL_FUNC1((void))

HXLINE( 385)					this->myNotes->forEachAlive( ::Dynamic(new _hx_Closure_1(_gthis)),null());
            				}
            				else {
HXLINE( 398)					if (this->pointerOverlaps(this->colorWheel)) {
HXLINE( 399)						this->_storedColor = this->getShaderColor();
HXLINE( 400)						this->holdingOnObj = this->colorWheel;
            					}
            					else {
HXLINE( 402)						if (this->pointerOverlaps(this->colorGradient)) {
HXLINE( 403)							this->_storedColor = this->getShaderColor();
HXLINE( 404)							this->holdingOnObj = this->colorGradient;
            						}
            						else {
HXLINE( 406)							if (this->pointerOverlaps(this->colorPalette)) {
HXLINE( 407)								 ::openfl::display::BitmapData _hx_tmp18 = this->colorPalette->get_pixels();
HXLINE( 408)								Float _hx_tmp19 = this->pointerX();
HXDLIN( 408)								int _hx_tmp20 = ::Std_obj::_hx_int(((_hx_tmp19 - this->colorPalette->x) / this->colorPalette->scale->x));
HXLINE( 409)								Float _hx_tmp21 = this->pointerY();
HXLINE( 407)								this->setShaderColor(_hx_tmp18->getPixel32(_hx_tmp20,::Std_obj::_hx_int(((_hx_tmp21 - this->colorPalette->y) / this->colorPalette->scale->y))));
HXLINE( 410)								 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp22 = ::flixel::FlxG_obj::sound;
HXDLIN( 410)								_hx_tmp22->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 411)								this->updateColors(null());
            							}
            							else {
HXLINE( 413)								if (this->pointerOverlaps(this->skinNote)) {
HXLINE( 415)									this->onPixel = !(this->onPixel);
HXLINE( 416)									this->spawnNotes();
HXLINE( 417)									this->updateNotes(true);
HXLINE( 418)									 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp23 = ::flixel::FlxG_obj::sound;
HXDLIN( 418)									_hx_tmp23->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
            								}
            								else {
HXLINE( 420)									bool _hx_tmp24;
HXDLIN( 420)									bool _hx_tmp25;
HXDLIN( 420)									Float _hx_tmp26 = this->pointerY();
HXDLIN( 420)									if ((_hx_tmp26 >= this->hexTypeLine->y)) {
HXLINE( 420)										Float _hx_tmp27 = this->pointerY();
HXDLIN( 420)										Float _hx_tmp28 = this->hexTypeLine->y;
HXDLIN( 420)										_hx_tmp25 = (_hx_tmp27 < (_hx_tmp28 + this->hexTypeLine->get_height()));
            									}
            									else {
HXLINE( 420)										_hx_tmp25 = false;
            									}
HXDLIN( 420)									if (_hx_tmp25) {
HXLINE( 420)										_hx_tmp24 = (::Math_obj::abs((this->pointerX() - ( (Float)(1000) ))) <= 84);
            									}
            									else {
HXLINE( 420)										_hx_tmp24 = false;
            									}
HXDLIN( 420)									if (_hx_tmp24) {
HXLINE( 423)										this->hexTypeNum = 0;
HXLINE( 424)										{
HXLINE( 424)											int _g2 = 0;
HXDLIN( 424)											::Array< ::Dynamic> _g3 = this->alphabetHex->letters;
HXDLIN( 424)											while((_g2 < _g3->length)){
HXLINE( 424)												 ::objects::AlphaCharacter letter = _g3->__get(_g2).StaticCast<  ::objects::AlphaCharacter >();
HXDLIN( 424)												_g2 = (_g2 + 1);
HXLINE( 426)												Float _hx_tmp29 = (letter->x - letter->offset->x);
HXDLIN( 426)												Float _hx_tmp30 = (_hx_tmp29 + letter->get_width());
HXDLIN( 426)												if ((_hx_tmp30 <= this->pointerX())) {
HXLINE( 426)													this->hexTypeNum++;
            												}
            												else {
HXLINE( 427)													goto _hx_goto_8;
            												}
            											}
            											_hx_goto_8:;
            										}
HXLINE( 429)										if ((this->hexTypeNum > 5)) {
HXLINE( 429)											this->hexTypeNum = 5;
            										}
HXLINE( 430)										this->hexTypeLine->set_visible(true);
HXLINE( 431)										this->centerHexTypeLine();
            									}
            									else {
HXLINE( 433)										this->holdingOnObj = null();
            									}
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 436)		if (::hx::IsNotNull( this->holdingOnObj )) {
HXLINE( 438)			bool _hx_tmp31;
HXDLIN( 438)			if ((::flixel::FlxG_obj::mouse->_leftButton->current != -1)) {
HXLINE( 438)				if (::backend::Controls_obj::instance->controllerMode) {
HXLINE( 438)					_hx_tmp31 = ::backend::Controls_obj::instance->justReleased(HX_("accept",08,93,06,0b));
            				}
            				else {
HXLINE( 438)					_hx_tmp31 = false;
            				}
            			}
            			else {
HXLINE( 438)				_hx_tmp31 = true;
            			}
HXDLIN( 438)			if (_hx_tmp31) {
HXLINE( 440)				this->holdingOnObj = null();
HXLINE( 441)				this->_storedColor = this->getShaderColor();
HXLINE( 442)				this->updateColors(null());
HXLINE( 443)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp32 = ::flixel::FlxG_obj::sound;
HXDLIN( 443)				_hx_tmp32->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
            			}
            			else {
HXLINE( 445)				bool _hx_tmp33;
HXDLIN( 445)				if (!(generalMoved)) {
HXLINE( 445)					_hx_tmp33 = generalPressed;
            				}
            				else {
HXLINE( 445)					_hx_tmp33 = true;
            				}
HXDLIN( 445)				if (_hx_tmp33) {
HXLINE( 447)					if (::hx::IsInstanceEq( this->holdingOnObj,this->colorGradient )) {
HXLINE( 449)						Float Value = this->pointerY();
HXDLIN( 449)						Float Value1 = (Value - this->colorGradient->y);
HXDLIN( 449)						Float Value2 = (Value1 / this->colorGradient->get_height());
HXDLIN( 449)						Float lowerBound;
HXDLIN( 449)						if ((Value2 < 0)) {
HXLINE( 449)							lowerBound = ( (Float)(0) );
            						}
            						else {
HXLINE( 449)							lowerBound = Value2;
            						}
HXDLIN( 449)						Float newBrightness;
HXDLIN( 449)						if ((lowerBound > 1)) {
HXLINE( 449)							newBrightness = ( (Float)(1) );
            						}
            						else {
HXLINE( 449)							newBrightness = lowerBound;
            						}
HXDLIN( 449)						Float newBrightness1 = (( (Float)(1) ) - newBrightness);
HXLINE( 450)						{
HXLINE( 450)							 ::options::NotesColorSubState _hx_tmp34 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 450)							_hx_tmp34->_storedColor = (_hx_tmp34->_storedColor & 16777215);
HXDLIN( 450)							 ::options::NotesColorSubState _hx_tmp35 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 450)							_hx_tmp35->_storedColor = (_hx_tmp35->_storedColor | 16777216);
            						}
HXLINE( 451)						int this2 = this->_storedColor;
HXDLIN( 451)						if ((::Math_obj::max((( (Float)(((this2 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this2 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this2 & 255)) ) / ( (Float)(255) )))) == 0)) {
HXLINE( 452)							Float Alpha = ( (Float)(1) );
HXDLIN( 452)							int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 452)							{
HXLINE( 452)								int Value3 = ::Math_obj::round((newBrightness1 * ( (Float)(255) )));
HXDLIN( 452)								color = (color & -16711681);
HXDLIN( 452)								int color1;
HXDLIN( 452)								if ((Value3 > 255)) {
HXLINE( 452)									color1 = 255;
            								}
            								else {
HXLINE( 452)									if ((Value3 < 0)) {
HXLINE( 452)										color1 = 0;
            									}
            									else {
HXLINE( 452)										color1 = Value3;
            									}
            								}
HXDLIN( 452)								color = (color | (color1 << 16));
            							}
HXDLIN( 452)							{
HXLINE( 452)								int Value4 = ::Math_obj::round((newBrightness1 * ( (Float)(255) )));
HXDLIN( 452)								color = (color & -65281);
HXDLIN( 452)								int color2;
HXDLIN( 452)								if ((Value4 > 255)) {
HXLINE( 452)									color2 = 255;
            								}
            								else {
HXLINE( 452)									if ((Value4 < 0)) {
HXLINE( 452)										color2 = 0;
            									}
            									else {
HXLINE( 452)										color2 = Value4;
            									}
            								}
HXDLIN( 452)								color = (color | (color2 << 8));
            							}
HXDLIN( 452)							{
HXLINE( 452)								int Value5 = ::Math_obj::round((newBrightness1 * ( (Float)(255) )));
HXDLIN( 452)								color = (color & -256);
HXDLIN( 452)								int color3;
HXDLIN( 452)								if ((Value5 > 255)) {
HXLINE( 452)									color3 = 255;
            								}
            								else {
HXLINE( 452)									if ((Value5 < 0)) {
HXLINE( 452)										color3 = 0;
            									}
            									else {
HXLINE( 452)										color3 = Value5;
            									}
            								}
HXDLIN( 452)								color = (color | color3);
            							}
HXDLIN( 452)							{
HXLINE( 452)								int Value6 = ::Math_obj::round((Alpha * ( (Float)(255) )));
HXDLIN( 452)								color = (color & 16777215);
HXDLIN( 452)								int color4;
HXDLIN( 452)								if ((Value6 > 255)) {
HXLINE( 452)									color4 = 255;
            								}
            								else {
HXLINE( 452)									if ((Value6 < 0)) {
HXLINE( 452)										color4 = 0;
            									}
            									else {
HXLINE( 452)										color4 = Value6;
            									}
            								}
HXDLIN( 452)								color = (color | (color4 << 24));
            							}
HXDLIN( 452)							this->setShaderColor(color);
            						}
            						else {
HXLINE( 454)							Float _hx_tmp36 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::get_hue(this->_storedColor);
HXDLIN( 454)							int this3 = this->_storedColor;
HXDLIN( 454)							this->setShaderColor(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromHSB(_hx_tmp36,((::Math_obj::max((( (Float)(((this3 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this3 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this3 & 255)) ) / ( (Float)(255) )))) - ::Math_obj::min((( (Float)(((this3 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::min((( (Float)(((this3 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this3 & 255)) ) / ( (Float)(255) ))))) / ::Math_obj::max((( (Float)(((this3 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this3 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this3 & 255)) ) / ( (Float)(255) ))))),newBrightness1,null()));
            						}
HXLINE( 455)						this->updateColors(this->_storedColor);
            					}
            					else {
HXLINE( 457)						if (::hx::IsInstanceEq( this->holdingOnObj,this->colorWheel )) {
HXLINE( 459)							Float x = this->colorWheel->x;
HXDLIN( 459)							Float x1 = (x + (this->colorWheel->get_width() / ( (Float)(2) )));
HXDLIN( 459)							Float y = this->colorWheel->y;
HXDLIN( 459)							 ::flixel::math::FlxBasePoint center =  ::flixel::math::FlxBasePoint_obj::__alloc( HX_CTX ,x1,(y + (this->colorWheel->get_height() / ( (Float)(2) ))));
HXLINE( 460)							 ::flixel::math::FlxBasePoint mouse = this->pointerFlxPoint();
HXLINE( 461)							Float x2 = (center->x - mouse->x);
HXDLIN( 461)							Float y1 = (center->y - mouse->y);
HXDLIN( 461)							Float hue = ( (Float)(::flixel::math::FlxMath_obj::wrap((::flixel::math::FlxMath_obj::wrap(::Std_obj::_hx_int((::Math_obj::atan2(y1,x2) * (( (Float)(180) ) / ::Math_obj::PI))),0,360) - 90),0,360)) );
HXLINE( 462)							Float dx = (center->x - mouse->x);
HXDLIN( 462)							Float dy = (center->y - mouse->y);
HXDLIN( 462)							{
HXLINE( 462)								 ::flixel::math::FlxBasePoint _this7 = center;
HXDLIN( 462)								if (_this7->_weak) {
HXLINE( 462)									_this7->put();
            								}
            							}
HXDLIN( 462)							Float Value7 = ::Math_obj::sqrt(((dx * dx) + (dy * dy)));
HXDLIN( 462)							Float Value8 = ((Value7 / this->colorWheel->get_width()) * ( (Float)(2) ));
HXDLIN( 462)							Float lowerBound1;
HXDLIN( 462)							if ((Value8 < 0)) {
HXLINE( 462)								lowerBound1 = ( (Float)(0) );
            							}
            							else {
HXLINE( 462)								lowerBound1 = Value8;
            							}
HXDLIN( 462)							Float sat;
HXDLIN( 462)							if ((lowerBound1 > 1)) {
HXLINE( 462)								sat = ( (Float)(1) );
            							}
            							else {
HXLINE( 462)								sat = lowerBound1;
            							}
HXLINE( 464)							if ((sat != 0)) {
HXLINE( 464)								int this4 = this->_storedColor;
HXDLIN( 464)								this->setShaderColor(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromHSB(hue,sat,::Math_obj::max((( (Float)(((this4 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this4 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this4 & 255)) ) / ( (Float)(255) )))),null()));
            							}
            							else {
HXLINE( 465)								int this5 = this->_storedColor;
HXDLIN( 465)								Float Red = ::Math_obj::max((( (Float)(((this5 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this5 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this5 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 465)								int this6 = this->_storedColor;
HXDLIN( 465)								Float Green = ::Math_obj::max((( (Float)(((this6 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this6 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this6 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 465)								int this7 = this->_storedColor;
HXDLIN( 465)								Float Blue = ::Math_obj::max((( (Float)(((this7 >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((this7 >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((this7 & 255)) ) / ( (Float)(255) ))));
HXDLIN( 465)								Float Alpha1 = ( (Float)(1) );
HXDLIN( 465)								int color5 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 465)								{
HXLINE( 465)									int Value9 = ::Math_obj::round((Red * ( (Float)(255) )));
HXDLIN( 465)									color5 = (color5 & -16711681);
HXDLIN( 465)									int color6;
HXDLIN( 465)									if ((Value9 > 255)) {
HXLINE( 465)										color6 = 255;
            									}
            									else {
HXLINE( 465)										if ((Value9 < 0)) {
HXLINE( 465)											color6 = 0;
            										}
            										else {
HXLINE( 465)											color6 = Value9;
            										}
            									}
HXDLIN( 465)									color5 = (color5 | (color6 << 16));
            								}
HXDLIN( 465)								{
HXLINE( 465)									int Value10 = ::Math_obj::round((Green * ( (Float)(255) )));
HXDLIN( 465)									color5 = (color5 & -65281);
HXDLIN( 465)									int color7;
HXDLIN( 465)									if ((Value10 > 255)) {
HXLINE( 465)										color7 = 255;
            									}
            									else {
HXLINE( 465)										if ((Value10 < 0)) {
HXLINE( 465)											color7 = 0;
            										}
            										else {
HXLINE( 465)											color7 = Value10;
            										}
            									}
HXDLIN( 465)									color5 = (color5 | (color7 << 8));
            								}
HXDLIN( 465)								{
HXLINE( 465)									int Value11 = ::Math_obj::round((Blue * ( (Float)(255) )));
HXDLIN( 465)									color5 = (color5 & -256);
HXDLIN( 465)									int color8;
HXDLIN( 465)									if ((Value11 > 255)) {
HXLINE( 465)										color8 = 255;
            									}
            									else {
HXLINE( 465)										if ((Value11 < 0)) {
HXLINE( 465)											color8 = 0;
            										}
            										else {
HXLINE( 465)											color8 = Value11;
            										}
            									}
HXDLIN( 465)									color5 = (color5 | color8);
            								}
HXDLIN( 465)								{
HXLINE( 465)									int Value12 = ::Math_obj::round((Alpha1 * ( (Float)(255) )));
HXDLIN( 465)									color5 = (color5 & 16777215);
HXDLIN( 465)									int color9;
HXDLIN( 465)									if ((Value12 > 255)) {
HXLINE( 465)										color9 = 255;
            									}
            									else {
HXLINE( 465)										if ((Value12 < 0)) {
HXLINE( 465)											color9 = 0;
            										}
            										else {
HXLINE( 465)											color9 = Value12;
            										}
            									}
HXDLIN( 465)									color5 = (color5 | (color9 << 24));
            								}
HXDLIN( 465)								this->setShaderColor(color5);
            							}
HXLINE( 466)							this->updateColors(null());
            						}
            					}
            				}
            			}
            		}
            		else {
HXLINE( 470)			bool _hx_tmp37;
HXDLIN( 470)			if (::backend::Controls_obj::instance->get_RESET()) {
HXLINE( 470)				_hx_tmp37 = (this->hexTypeNum < 0);
            			}
            			else {
HXLINE( 470)				_hx_tmp37 = false;
            			}
HXDLIN( 470)			if (_hx_tmp37) {
HXLINE( 472)				bool _hx_tmp38;
HXDLIN( 472)				 ::flixel::input::keyboard::FlxKeyList _this8 = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->pressed) );
HXDLIN( 472)				if (!(_this8->keyManager->checkStatusUnsafe(16,_this8->status))) {
HXLINE( 472)					_hx_tmp38 = ::flixel::FlxG_obj::gamepads->anyHasState(4,1);
            				}
            				else {
HXLINE( 472)					_hx_tmp38 = true;
            				}
HXDLIN( 472)				if (_hx_tmp38) {
HXLINE( 475)					{
HXLINE( 476)						 ::shaders::RGBShaderReference strumRGB = Dynamic( this->myNotes->members->__get(this->curSelectedNote)).StaticCast<  ::objects::StrumNote >()->rgbShader;
HXLINE( 477)						int color10;
HXDLIN( 477)						if (!(this->onPixel)) {
HXLINE( 477)							color10 = ::backend::ClientPrefs_obj::defaultData->arrowRGB->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(0);
            						}
            						else {
HXLINE( 477)							color10 = ::backend::ClientPrefs_obj::defaultData->arrowRGBPixel->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(0);
            						}
HXLINE( 482)						 ::shaders::RGBPalette _hx_tmp39 = this->getShader();
HXDLIN( 482)						_hx_tmp39->set_r(strumRGB->set_r(color10));
HXLINE( 488)						this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()[0] = color10;
            					}
HXLINE( 475)					{
HXLINE( 476)						 ::shaders::RGBShaderReference strumRGB1 = Dynamic( this->myNotes->members->__get(this->curSelectedNote)).StaticCast<  ::objects::StrumNote >()->rgbShader;
HXLINE( 477)						int color11;
HXDLIN( 477)						if (!(this->onPixel)) {
HXLINE( 477)							color11 = ::backend::ClientPrefs_obj::defaultData->arrowRGB->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(1);
            						}
            						else {
HXLINE( 477)							color11 = ::backend::ClientPrefs_obj::defaultData->arrowRGBPixel->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(1);
            						}
HXLINE( 484)						 ::shaders::RGBPalette _hx_tmp40 = this->getShader();
HXDLIN( 484)						_hx_tmp40->set_g(strumRGB1->set_g(color11));
HXLINE( 488)						this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()[1] = color11;
            					}
HXLINE( 475)					{
HXLINE( 476)						 ::shaders::RGBShaderReference strumRGB2 = Dynamic( this->myNotes->members->__get(this->curSelectedNote)).StaticCast<  ::objects::StrumNote >()->rgbShader;
HXLINE( 477)						int color12;
HXDLIN( 477)						if (!(this->onPixel)) {
HXLINE( 477)							color12 = ::backend::ClientPrefs_obj::defaultData->arrowRGB->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(2);
            						}
            						else {
HXLINE( 477)							color12 = ::backend::ClientPrefs_obj::defaultData->arrowRGBPixel->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(2);
            						}
HXLINE( 486)						 ::shaders::RGBPalette _hx_tmp41 = this->getShader();
HXDLIN( 486)						_hx_tmp41->set_b(strumRGB2->set_b(color12));
HXLINE( 488)						this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()[2] = color12;
            					}
            				}
HXLINE( 491)				int _hx_tmp42;
HXDLIN( 491)				if (!(this->onPixel)) {
HXLINE( 491)					_hx_tmp42 = ::backend::ClientPrefs_obj::defaultData->arrowRGB->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(this->curSelectedMode);
            				}
            				else {
HXLINE( 491)					_hx_tmp42 = ::backend::ClientPrefs_obj::defaultData->arrowRGBPixel->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(this->curSelectedMode);
            				}
HXDLIN( 491)				this->setShaderColor(_hx_tmp42);
HXLINE( 492)				 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp43 = ::flixel::FlxG_obj::sound;
HXDLIN( 492)				_hx_tmp43->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("cancelMenu",39,a4,43,b7)),null(),true,null()),((Float)0.6),null(),null(),null(),null());
HXLINE( 493)				this->updateColors(null());
            			}
            		}
            	}


bool NotesColorSubState_obj::pointerOverlaps( ::Dynamic obj){
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_498_pointerOverlaps)
HXLINE( 499)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 499)			return ::flixel::FlxG_obj::mouse->overlaps(( ( ::flixel::FlxBasic)(obj) ),null());
            		}
HXLINE( 500)		return ::flixel::FlxG_obj::overlap(this->controllerPointer,( ( ::flixel::FlxBasic)(obj) ),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesColorSubState_obj,pointerOverlaps,return )

Float NotesColorSubState_obj::pointerX(){
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_504_pointerX)
HXLINE( 505)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 505)			return ( (Float)(::flixel::FlxG_obj::mouse->x) );
            		}
HXLINE( 506)		return this->controllerPointer->x;
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesColorSubState_obj,pointerX,return )

Float NotesColorSubState_obj::pointerY(){
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_509_pointerY)
HXLINE( 510)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 510)			return ( (Float)(::flixel::FlxG_obj::mouse->y) );
            		}
HXLINE( 511)		return this->controllerPointer->y;
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesColorSubState_obj,pointerY,return )

 ::flixel::math::FlxBasePoint NotesColorSubState_obj::pointerFlxPoint(){
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_514_pointerFlxPoint)
HXLINE( 515)		if (!(::backend::Controls_obj::instance->controllerMode)) {
HXLINE( 515)			return ::flixel::FlxG_obj::mouse->getScreenPosition(null(),null());
            		}
HXLINE( 516)		return this->controllerPointer->getScreenPosition(null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesColorSubState_obj,pointerFlxPoint,return )

void NotesColorSubState_obj::centerHexTypeLine(){
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_520_centerHexTypeLine)
HXLINE( 522)		if ((this->hexTypeNum > 0)) {
HXLINE( 524)			 ::objects::AlphaCharacter letter = this->alphabetHex->letters->__get((this->hexTypeNum - 1)).StaticCast<  ::objects::AlphaCharacter >();
HXLINE( 525)			 ::flixel::FlxSprite _hx_tmp = this->hexTypeLine;
HXDLIN( 525)			Float _hx_tmp1 = (letter->x - letter->offset->x);
HXDLIN( 525)			_hx_tmp->set_x((_hx_tmp1 + letter->get_width()));
            		}
            		else {
HXLINE( 529)			 ::objects::AlphaCharacter letter1 = this->alphabetHex->letters->__get(0).StaticCast<  ::objects::AlphaCharacter >();
HXLINE( 530)			this->hexTypeLine->set_x((letter1->x - letter1->offset->x));
            		}
HXLINE( 532)		 ::flixel::FlxSprite fh = this->hexTypeLine;
HXDLIN( 532)		Float fh1 = fh->x;
HXDLIN( 532)		fh->set_x((fh1 + this->hexTypeLine->get_width()));
HXLINE( 533)		this->hexTypeVisibleTimer = ( (Float)(0) );
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesColorSubState_obj,centerHexTypeLine,(void))

void NotesColorSubState_obj::changeSelectionMode(::hx::Null< int >  __o_change){
            		int change = __o_change.Default(0);
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_536_changeSelectionMode)
HXLINE( 537)		 ::options::NotesColorSubState _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 537)		_hx_tmp->curSelectedMode = (_hx_tmp->curSelectedMode + change);
HXLINE( 538)		if ((this->curSelectedMode < 0)) {
HXLINE( 539)			this->curSelectedMode = 2;
            		}
HXLINE( 540)		if ((this->curSelectedMode >= 3)) {
HXLINE( 541)			this->curSelectedMode = 0;
            		}
HXLINE( 543)		this->modeBG->set_visible(true);
HXLINE( 544)		this->notesBG->set_visible(false);
HXLINE( 545)		this->updateNotes(null());
HXLINE( 546)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 546)		_hx_tmp1->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),null(),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesColorSubState_obj,changeSelectionMode,(void))

void NotesColorSubState_obj::changeSelectionNote(::hx::Null< int >  __o_change){
            		int change = __o_change.Default(0);
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_548_changeSelectionNote)
HXLINE( 549)		 ::options::NotesColorSubState _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 549)		_hx_tmp->curSelectedNote = (_hx_tmp->curSelectedNote + change);
HXLINE( 550)		if ((this->curSelectedNote < 0)) {
HXLINE( 551)			this->curSelectedNote = (this->dataArray->length - 1);
            		}
HXLINE( 552)		if ((this->curSelectedNote >= this->dataArray->length)) {
HXLINE( 553)			this->curSelectedNote = 0;
            		}
HXLINE( 555)		this->modeBG->set_visible(false);
HXLINE( 556)		this->notesBG->set_visible(true);
HXLINE( 557)		this->bigNote->rgbShader->parent = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >();
HXLINE( 558)		this->bigNote->shader = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >()->shader;
HXLINE( 559)		this->updateNotes(null());
HXLINE( 560)		 ::flixel::_hx_system::frontEnds::SoundFrontEnd _hx_tmp1 = ::flixel::FlxG_obj::sound;
HXDLIN( 560)		_hx_tmp1->play(::backend::Paths_obj::returnSound((HX_("sounds/",eb,02,a5,b6) + HX_("scrollMenu",4c,d4,18,06)),null(),true,null()),null(),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesColorSubState_obj,changeSelectionNote,(void))

 ::objects::Alphabet NotesColorSubState_obj::makeColorAlphabet(::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y){
            		Float x = __o_x.Default(0);
            		Float y = __o_y.Default(0);
            	HX_GC_STACKFRAME(&_hx_pos_1dccb24f48fccdae_565_makeColorAlphabet)
HXLINE( 566)		 ::objects::Alphabet text =  ::objects::Alphabet_obj::__alloc( HX_CTX ,x,y,HX_("",00,00,00,00),true);
HXLINE( 567)		text->set_alignment(::objects::Alignment_obj::CENTERED_dyn());
HXLINE( 568)		text->setScale(((Float)0.6),null());
HXLINE( 569)		this->add(text);
HXLINE( 570)		return text;
            	}


HX_DEFINE_DYNAMIC_FUNC2(NotesColorSubState_obj,makeColorAlphabet,return )

void NotesColorSubState_obj::spawnNotes(){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		void _hx_run( ::flixel::FlxSprite note){
            			HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_584_spawnNotes)
HXLINE( 585)			note->kill();
HXLINE( 586)			note->destroy();
            		}
            		HX_END_LOCAL_FUNC1((void))

            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_1) HXARGC(1)
            		void _hx_run( ::objects::StrumNote note){
            			HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_588_spawnNotes)
HXLINE( 589)			note->kill();
HXLINE( 590)			note->destroy();
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_GC_STACKFRAME(&_hx_pos_1dccb24f48fccdae_579_spawnNotes)
HXLINE( 580)		::Array< ::Dynamic> _hx_tmp;
HXDLIN( 580)		if (!(this->onPixel)) {
HXLINE( 580)			_hx_tmp = ::backend::ClientPrefs_obj::data->arrowRGB;
            		}
            		else {
HXLINE( 580)			_hx_tmp = ::backend::ClientPrefs_obj::data->arrowRGBPixel;
            		}
HXDLIN( 580)		this->dataArray = _hx_tmp;
HXLINE( 581)		if (this->onPixel) {
HXLINE( 581)			::states::PlayState_obj::set_stageUI(HX_("pixel",86,c6,a3,c2));
            		}
HXLINE( 584)		this->modeNotes->forEachAlive( ::Dynamic(new _hx_Closure_0()),null());
HXLINE( 588)		this->myNotes->forEachAlive( ::Dynamic(new _hx_Closure_1()),null());
HXLINE( 592)		this->modeNotes->clear();
HXLINE( 593)		this->myNotes->clear();
HXLINE( 595)		if (::hx::IsNotNull( this->skinNote )) {
HXLINE( 597)			this->remove(this->skinNote,null());
HXLINE( 598)			this->skinNote->destroy();
            		}
HXLINE( 600)		if (::hx::IsNotNull( this->bigNote )) {
HXLINE( 602)			this->remove(this->bigNote,null());
HXLINE( 603)			this->bigNote->destroy();
            		}
HXLINE( 607)		int res;
HXDLIN( 607)		if (this->onPixel) {
HXLINE( 607)			res = 160;
            		}
            		else {
HXLINE( 607)			res = 17;
            		}
HXLINE( 608)		 ::flixel::FlxSprite _hx_tmp1 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,48,24,null());
HXDLIN( 608)		::String _hx_tmp2;
HXDLIN( 608)		if (this->onPixel) {
HXLINE( 608)			_hx_tmp2 = HX_("note",f2,17,0a,49);
            		}
            		else {
HXLINE( 608)			_hx_tmp2 = HX_("notePixel",34,11,31,00);
            		}
HXDLIN( 608)		this->skinNote = _hx_tmp1->loadGraphic(::backend::Paths_obj::image((HX_("noteColorMenu/",df,fb,4e,a8) + _hx_tmp2),null(),null()),true,res,res,null(),null());
HXLINE( 609)		this->skinNote->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 610)		this->skinNote->setGraphicSize(68,null());
HXLINE( 611)		this->skinNote->updateHitbox();
HXLINE( 612)		this->skinNote->animation->add(HX_("anim",11,86,71,40),::Array_obj< int >::fromData( _hx_array_data_87d99b23_25,1),24,true,null(),null());
HXLINE( 613)		this->skinNote->animation->play(HX_("anim",11,86,71,40),true,null(),null());
HXLINE( 614)		if (!(this->onPixel)) {
HXLINE( 614)			this->skinNote->set_antialiasing(false);
            		}
HXLINE( 615)		this->add(this->skinNote);
HXLINE( 617)		int res1;
HXDLIN( 617)		if (!(this->onPixel)) {
HXLINE( 617)			res1 = 160;
            		}
            		else {
HXLINE( 617)			res1 = 17;
            		}
HXLINE( 618)		{
HXLINE( 619)			{
HXLINE( 620)				 ::flixel::FlxSprite newNote =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,230,100,null());
HXDLIN( 620)				::String newNote1;
HXDLIN( 620)				if (!(this->onPixel)) {
HXLINE( 620)					newNote1 = HX_("note",f2,17,0a,49);
            				}
            				else {
HXLINE( 620)					newNote1 = HX_("notePixel",34,11,31,00);
            				}
HXDLIN( 620)				 ::flixel::FlxSprite newNote2 = newNote->loadGraphic(::backend::Paths_obj::image((HX_("noteColorMenu/",df,fb,4e,a8) + newNote1),null(),null()),true,res1,res1,null(),null());
HXLINE( 621)				newNote2->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 622)				newNote2->setGraphicSize(85,null());
HXLINE( 623)				newNote2->updateHitbox();
HXLINE( 624)				newNote2->animation->add(HX_("anim",11,86,71,40),::Array_obj< int >::fromData( _hx_array_data_87d99b23_26,1),24,true,null(),null());
HXLINE( 625)				newNote2->animation->play(HX_("anim",11,86,71,40),true,null(),null());
HXLINE( 626)				newNote2->ID = 0;
HXLINE( 627)				if (this->onPixel) {
HXLINE( 627)					newNote2->set_antialiasing(false);
            				}
HXLINE( 628)				this->modeNotes->add(newNote2).StaticCast<  ::flixel::FlxSprite >();
            			}
HXLINE( 619)			{
HXLINE( 620)				 ::flixel::FlxSprite newNote3 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,330,100,null());
HXDLIN( 620)				::String newNote4;
HXDLIN( 620)				if (!(this->onPixel)) {
HXLINE( 620)					newNote4 = HX_("note",f2,17,0a,49);
            				}
            				else {
HXLINE( 620)					newNote4 = HX_("notePixel",34,11,31,00);
            				}
HXDLIN( 620)				 ::flixel::FlxSprite newNote5 = newNote3->loadGraphic(::backend::Paths_obj::image((HX_("noteColorMenu/",df,fb,4e,a8) + newNote4),null(),null()),true,res1,res1,null(),null());
HXLINE( 621)				newNote5->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 622)				newNote5->setGraphicSize(85,null());
HXLINE( 623)				newNote5->updateHitbox();
HXLINE( 624)				newNote5->animation->add(HX_("anim",11,86,71,40),::Array_obj< int >::fromData( _hx_array_data_87d99b23_27,1),24,true,null(),null());
HXLINE( 625)				newNote5->animation->play(HX_("anim",11,86,71,40),true,null(),null());
HXLINE( 626)				newNote5->ID = 1;
HXLINE( 627)				if (this->onPixel) {
HXLINE( 627)					newNote5->set_antialiasing(false);
            				}
HXLINE( 628)				this->modeNotes->add(newNote5).StaticCast<  ::flixel::FlxSprite >();
            			}
HXLINE( 619)			{
HXLINE( 620)				 ::flixel::FlxSprite newNote6 =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,430,100,null());
HXDLIN( 620)				::String newNote7;
HXDLIN( 620)				if (!(this->onPixel)) {
HXLINE( 620)					newNote7 = HX_("note",f2,17,0a,49);
            				}
            				else {
HXLINE( 620)					newNote7 = HX_("notePixel",34,11,31,00);
            				}
HXDLIN( 620)				 ::flixel::FlxSprite newNote8 = newNote6->loadGraphic(::backend::Paths_obj::image((HX_("noteColorMenu/",df,fb,4e,a8) + newNote7),null(),null()),true,res1,res1,null(),null());
HXLINE( 621)				newNote8->set_antialiasing(::backend::ClientPrefs_obj::data->antialiasing);
HXLINE( 622)				newNote8->setGraphicSize(85,null());
HXLINE( 623)				newNote8->updateHitbox();
HXLINE( 624)				newNote8->animation->add(HX_("anim",11,86,71,40),::Array_obj< int >::fromData( _hx_array_data_87d99b23_28,1),24,true,null(),null());
HXLINE( 625)				newNote8->animation->play(HX_("anim",11,86,71,40),true,null(),null());
HXLINE( 626)				newNote8->ID = 2;
HXLINE( 627)				if (this->onPixel) {
HXLINE( 627)					newNote8->set_antialiasing(false);
            				}
HXLINE( 628)				this->modeNotes->add(newNote8).StaticCast<  ::flixel::FlxSprite >();
            			}
            		}
HXLINE( 631)		::objects::Note_obj::globalRgbShaders = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 632)		{
HXLINE( 632)			int _g = 0;
HXDLIN( 632)			int _g1 = this->dataArray->length;
HXDLIN( 632)			while((_g < _g1)){
HXLINE( 632)				_g = (_g + 1);
HXDLIN( 632)				int i = (_g - 1);
HXLINE( 634)				::objects::Note_obj::initializeGlobalRGBShader(i);
HXLINE( 635)				 ::objects::StrumNote newNote9 =  ::objects::StrumNote_obj::__alloc( HX_CTX ,(150 + ((( (Float)(480) ) / ( (Float)(this->dataArray->length) )) * ( (Float)(i) ))),( (Float)(200) ),i,0);
HXLINE( 636)				newNote9->useRGBShader = true;
HXLINE( 637)				newNote9->setGraphicSize(102,null());
HXLINE( 638)				newNote9->updateHitbox();
HXLINE( 639)				newNote9->ID = i;
HXLINE( 640)				this->myNotes->add(newNote9).StaticCast<  ::objects::StrumNote >();
            			}
            		}
HXLINE( 643)		this->bigNote =  ::objects::Note_obj::__alloc( HX_CTX ,( (Float)(0) ),0,null(),false,true,null());
HXLINE( 644)		this->bigNote->setPosition(250,325);
HXLINE( 645)		this->bigNote->setGraphicSize(250,null());
HXLINE( 646)		this->bigNote->updateHitbox();
HXLINE( 647)		this->bigNote->rgbShader->parent = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >();
HXLINE( 648)		this->bigNote->shader = ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >()->shader;
HXLINE( 649)		{
HXLINE( 649)			int _g2 = 0;
HXDLIN( 649)			int _g3 = ::objects::Note_obj::colArray->length;
HXDLIN( 649)			while((_g2 < _g3)){
HXLINE( 649)				_g2 = (_g2 + 1);
HXDLIN( 649)				int i1 = (_g2 - 1);
HXLINE( 651)				if (!(this->onPixel)) {
HXLINE( 651)					this->bigNote->animation->addByPrefix((HX_("note",f2,17,0a,49) + i1),(::objects::Note_obj::colArray->__get(i1) + HX_("0",30,00,00,00)),24,true,null(),null());
            				}
            				else {
HXLINE( 652)					this->bigNote->animation->add((HX_("note",f2,17,0a,49) + i1),::Array_obj< int >::__new(1)->init(0,(i1 + 4)),24,true,null(),null());
            				}
            			}
            		}
HXLINE( 654)		int _hx_tmp3 = (this->members->indexOf(this->myNotes,null()) + 1);
HXDLIN( 654)		this->insert(_hx_tmp3,this->bigNote);
HXLINE( 655)		this->_storedColor = this->getShaderColor();
HXLINE( 656)		::states::PlayState_obj::set_stageUI(HX_("normal",27,72,69,30));
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesColorSubState_obj,spawnNotes,(void))

void NotesColorSubState_obj::updateNotes( ::Dynamic __o_instant){
            		 ::Dynamic instant = __o_instant;
            		if (::hx::IsNull(__o_instant)) instant = false;
            	HX_GC_STACKFRAME(&_hx_pos_1dccb24f48fccdae_660_updateNotes)
HXLINE( 661)		{
HXLINE( 661)			 ::Dynamic filter = null();
HXDLIN( 661)			 ::flixel::group::FlxTypedGroupIterator note =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->modeNotes->members,filter);
HXDLIN( 661)			while(note->hasNext()){
HXLINE( 661)				 ::flixel::FlxSprite note1 = note->next().StaticCast<  ::flixel::FlxSprite >();
HXLINE( 662)				Float _hx_tmp;
HXDLIN( 662)				if ((this->curSelectedMode == note1->ID)) {
HXLINE( 662)					_hx_tmp = ( (Float)(1) );
            				}
            				else {
HXLINE( 662)					_hx_tmp = ((Float)0.6);
            				}
HXDLIN( 662)				note1->set_alpha(_hx_tmp);
            			}
            		}
HXLINE( 664)		{
HXLINE( 664)			 ::Dynamic filter1 = null();
HXDLIN( 664)			 ::flixel::group::FlxTypedGroupIterator note2 =  ::flixel::group::FlxTypedGroupIterator_obj::__alloc( HX_CTX ,this->myNotes->members,filter1);
HXDLIN( 664)			while(note2->hasNext()){
HXLINE( 664)				 ::objects::StrumNote note3 = note2->next().StaticCast<  ::objects::StrumNote >();
HXLINE( 666)				::String newAnim;
HXDLIN( 666)				if ((this->curSelectedNote == note3->ID)) {
HXLINE( 666)					newAnim = HX_("confirm",00,9d,39,10);
            				}
            				else {
HXLINE( 666)					newAnim = HX_("pressed",a2,d2,e6,39);
            				}
HXLINE( 667)				Float _hx_tmp1;
HXDLIN( 667)				if ((this->curSelectedNote == note3->ID)) {
HXLINE( 667)					_hx_tmp1 = ( (Float)(1) );
            				}
            				else {
HXLINE( 667)					_hx_tmp1 = ((Float)0.6);
            				}
HXDLIN( 667)				note3->set_alpha(_hx_tmp1);
HXLINE( 668)				bool _hx_tmp2;
HXDLIN( 668)				if (::hx::IsNotNull( note3->animation->_curAnim )) {
HXLINE( 668)					_hx_tmp2 = (note3->animation->_curAnim->name != newAnim);
            				}
            				else {
HXLINE( 668)					_hx_tmp2 = true;
            				}
HXDLIN( 668)				if (_hx_tmp2) {
HXLINE( 668)					note3->playAnim(newAnim,true);
            				}
HXLINE( 669)				if (( (bool)(instant) )) {
HXLINE( 669)					note3->animation->_curAnim->finish();
            				}
            			}
            		}
HXLINE( 671)		this->bigNote->animation->play((HX_("note",f2,17,0a,49) + this->curSelectedNote),true,null(),null());
HXLINE( 672)		this->updateColors(null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesColorSubState_obj,updateNotes,(void))

void NotesColorSubState_obj::updateColors( ::Dynamic specific){
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_676_updateColors)
HXLINE( 677)		int color = this->getShaderColor();
HXLINE( 678)		int wheelColor;
HXDLIN( 678)		if (::hx::IsNull( specific )) {
HXLINE( 678)			wheelColor = this->getShaderColor();
            		}
            		else {
HXLINE( 678)			wheelColor = ( (int)(specific) );
            		}
HXLINE( 679)		 ::objects::Alphabet _hx_tmp = this->alphabetR;
HXDLIN( 679)		_hx_tmp->set_text(::Std_obj::string(((color >> 16) & 255)));
HXLINE( 680)		 ::objects::Alphabet _hx_tmp1 = this->alphabetG;
HXDLIN( 680)		_hx_tmp1->set_text(::Std_obj::string(((color >> 8) & 255)));
HXLINE( 681)		 ::objects::Alphabet _hx_tmp2 = this->alphabetB;
HXDLIN( 681)		_hx_tmp2->set_text(::Std_obj::string((color & 255)));
HXLINE( 682)		 ::objects::Alphabet _hx_tmp3 = this->alphabetHex;
HXDLIN( 682)		::String _hx_tmp4 = (HX_("",00,00,00,00) + ::StringTools_obj::hex(((color >> 16) & 255),2));
HXDLIN( 682)		::String _hx_tmp5 = (_hx_tmp4 + ::StringTools_obj::hex(((color >> 8) & 255),2));
HXDLIN( 682)		_hx_tmp3->set_text((_hx_tmp5 + ::StringTools_obj::hex((color & 255),2)));
HXLINE( 683)		{
HXLINE( 683)			int _g = 0;
HXDLIN( 683)			::Array< ::Dynamic> _g1 = this->alphabetHex->letters;
HXDLIN( 683)			while((_g < _g1->length)){
HXLINE( 683)				 ::objects::AlphaCharacter letter = _g1->__get(_g).StaticCast<  ::objects::AlphaCharacter >();
HXDLIN( 683)				_g = (_g + 1);
HXDLIN( 683)				letter->set_color(color);
            			}
            		}
HXLINE( 685)		 ::flixel::FlxSprite _hx_tmp6 = this->colorWheel;
HXDLIN( 685)		_hx_tmp6->set_color(::flixel::util::_FlxColor::FlxColor_Impl__obj::fromHSB(( (Float)(0) ),( (Float)(0) ),::Math_obj::max((( (Float)(((color >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((color >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((color & 255)) ) / ( (Float)(255) )))),null()));
HXLINE( 686)		 ::flixel::FlxSprite _hx_tmp7 = this->colorWheelSelector;
HXDLIN( 686)		Float _hx_tmp8 = this->colorWheel->x;
HXDLIN( 686)		Float _hx_tmp9 = (_hx_tmp8 + (this->colorWheel->get_width() / ( (Float)(2) )));
HXDLIN( 686)		Float _hx_tmp10 = this->colorWheel->y;
HXDLIN( 686)		_hx_tmp7->setPosition(_hx_tmp9,(_hx_tmp10 + (this->colorWheel->get_height() / ( (Float)(2) ))));
HXLINE( 687)		if ((::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) )))) != 0)) {
HXLINE( 689)			Float hueWrap = ::flixel::util::_FlxColor::FlxColor_Impl__obj::get_hue(wheelColor);
HXDLIN( 689)			Float hueWrap1 = ((hueWrap * ::Math_obj::PI) / ( (Float)(180) ));
HXLINE( 690)			 ::flixel::FlxSprite fh = this->colorWheelSelector;
HXDLIN( 690)			Float fh1 = fh->x;
HXDLIN( 690)			Float _hx_tmp11 = ::Math_obj::sin(hueWrap1);
HXDLIN( 690)			Float _hx_tmp12 = ((_hx_tmp11 * this->colorWheel->get_width()) / ( (Float)(2) ));
HXDLIN( 690)			fh->set_x((fh1 + (_hx_tmp12 * ((::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) )))) - ::Math_obj::min((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::min((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))) / ::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))))));
HXLINE( 691)			 ::flixel::FlxSprite fh2 = this->colorWheelSelector;
HXDLIN( 691)			Float fh3 = fh2->y;
HXDLIN( 691)			Float _hx_tmp13 = ::Math_obj::cos(hueWrap1);
HXDLIN( 691)			Float _hx_tmp14 = ((_hx_tmp13 * this->colorWheel->get_height()) / ( (Float)(2) ));
HXDLIN( 691)			fh2->set_y((fh3 - (_hx_tmp14 * ((::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) )))) - ::Math_obj::min((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::min((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))) / ::Math_obj::max((( (Float)(((wheelColor >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((wheelColor >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((wheelColor & 255)) ) / ( (Float)(255) ))))))));
            		}
HXLINE( 693)		 ::flixel::FlxSprite _hx_tmp15 = this->colorGradientSelector;
HXDLIN( 693)		Float _hx_tmp16 = this->colorGradient->y;
HXDLIN( 693)		Float _hx_tmp17 = this->colorGradient->get_height();
HXDLIN( 693)		_hx_tmp15->set_y((_hx_tmp16 + (_hx_tmp17 * (( (Float)(1) ) - ::Math_obj::max((( (Float)(((color >> 16) & 255)) ) / ( (Float)(255) )),::Math_obj::max((( (Float)(((color >> 8) & 255)) ) / ( (Float)(255) )),(( (Float)((color & 255)) ) / ( (Float)(255) ))))))));
HXLINE( 695)		 ::shaders::RGBShaderReference strumRGB = Dynamic( this->myNotes->members->__get(this->curSelectedNote)).StaticCast<  ::objects::StrumNote >()->rgbShader;
HXLINE( 696)		switch((int)(this->curSelectedMode)){
            			case (int)0: {
HXLINE( 699)				 ::shaders::RGBPalette _hx_tmp18 = this->getShader();
HXDLIN( 699)				_hx_tmp18->set_r(strumRGB->set_r(color));
            			}
            			break;
            			case (int)1: {
HXLINE( 701)				 ::shaders::RGBPalette _hx_tmp19 = this->getShader();
HXDLIN( 701)				_hx_tmp19->set_g(strumRGB->set_g(color));
            			}
            			break;
            			case (int)2: {
HXLINE( 703)				 ::shaders::RGBPalette _hx_tmp20 = this->getShader();
HXDLIN( 703)				_hx_tmp20->set_b(strumRGB->set_b(color));
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesColorSubState_obj,updateColors,(void))

void NotesColorSubState_obj::setShaderColor(int value){
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_707_setShaderColor)
HXDLIN( 707)		this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()[this->curSelectedMode] = value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(NotesColorSubState_obj,setShaderColor,(void))

int NotesColorSubState_obj::getShaderColor(){
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_708_getShaderColor)
HXDLIN( 708)		return this->dataArray->__get(this->curSelectedNote).StaticCast< ::Array< int > >()->__get(this->curSelectedMode);
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesColorSubState_obj,getShaderColor,return )

 ::shaders::RGBPalette NotesColorSubState_obj::getShader(){
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_709_getShader)
HXDLIN( 709)		return ::objects::Note_obj::globalRgbShaders->__get(this->curSelectedNote).StaticCast<  ::shaders::RGBPalette >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(NotesColorSubState_obj,getShader,return )

void NotesColorSubState_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_1dccb24f48fccdae_712_destroy)
HXLINE( 713)		::objects::Note_obj::globalRgbShaders = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 714)		this->super::destroy();
            	}



::hx::ObjectPtr< NotesColorSubState_obj > NotesColorSubState_obj::__new() {
	::hx::ObjectPtr< NotesColorSubState_obj > __this = new NotesColorSubState_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< NotesColorSubState_obj > NotesColorSubState_obj::__alloc(::hx::Ctx *_hx_ctx) {
	NotesColorSubState_obj *__this = (NotesColorSubState_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(NotesColorSubState_obj), true, "options.NotesColorSubState"));
	*(void **)__this = NotesColorSubState_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

NotesColorSubState_obj::NotesColorSubState_obj()
{
}

void NotesColorSubState_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(NotesColorSubState);
	HX_MARK_MEMBER_NAME(onModeColumn,"onModeColumn");
	HX_MARK_MEMBER_NAME(curSelectedMode,"curSelectedMode");
	HX_MARK_MEMBER_NAME(curSelectedNote,"curSelectedNote");
	HX_MARK_MEMBER_NAME(onPixel,"onPixel");
	HX_MARK_MEMBER_NAME(dataArray,"dataArray");
	HX_MARK_MEMBER_NAME(hexTypeLine,"hexTypeLine");
	HX_MARK_MEMBER_NAME(hexTypeNum,"hexTypeNum");
	HX_MARK_MEMBER_NAME(hexTypeVisibleTimer,"hexTypeVisibleTimer");
	HX_MARK_MEMBER_NAME(copyButton,"copyButton");
	HX_MARK_MEMBER_NAME(pasteButton,"pasteButton");
	HX_MARK_MEMBER_NAME(colorGradient,"colorGradient");
	HX_MARK_MEMBER_NAME(colorGradientSelector,"colorGradientSelector");
	HX_MARK_MEMBER_NAME(colorPalette,"colorPalette");
	HX_MARK_MEMBER_NAME(colorWheel,"colorWheel");
	HX_MARK_MEMBER_NAME(colorWheelSelector,"colorWheelSelector");
	HX_MARK_MEMBER_NAME(alphabetR,"alphabetR");
	HX_MARK_MEMBER_NAME(alphabetG,"alphabetG");
	HX_MARK_MEMBER_NAME(alphabetB,"alphabetB");
	HX_MARK_MEMBER_NAME(alphabetHex,"alphabetHex");
	HX_MARK_MEMBER_NAME(modeBG,"modeBG");
	HX_MARK_MEMBER_NAME(notesBG,"notesBG");
	HX_MARK_MEMBER_NAME(controllerPointer,"controllerPointer");
	HX_MARK_MEMBER_NAME(_lastControllerMode,"_lastControllerMode");
	HX_MARK_MEMBER_NAME(tipTxt,"tipTxt");
	HX_MARK_MEMBER_NAME(_storedColor,"_storedColor");
	HX_MARK_MEMBER_NAME(changingNote,"changingNote");
	HX_MARK_MEMBER_NAME(holdingOnObj,"holdingOnObj");
	HX_MARK_MEMBER_NAME(allowedTypeKeys,"allowedTypeKeys");
	HX_MARK_MEMBER_NAME(skinNote,"skinNote");
	HX_MARK_MEMBER_NAME(modeNotes,"modeNotes");
	HX_MARK_MEMBER_NAME(myNotes,"myNotes");
	HX_MARK_MEMBER_NAME(bigNote,"bigNote");
	 ::flixel::FlxSubState_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void NotesColorSubState_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(onModeColumn,"onModeColumn");
	HX_VISIT_MEMBER_NAME(curSelectedMode,"curSelectedMode");
	HX_VISIT_MEMBER_NAME(curSelectedNote,"curSelectedNote");
	HX_VISIT_MEMBER_NAME(onPixel,"onPixel");
	HX_VISIT_MEMBER_NAME(dataArray,"dataArray");
	HX_VISIT_MEMBER_NAME(hexTypeLine,"hexTypeLine");
	HX_VISIT_MEMBER_NAME(hexTypeNum,"hexTypeNum");
	HX_VISIT_MEMBER_NAME(hexTypeVisibleTimer,"hexTypeVisibleTimer");
	HX_VISIT_MEMBER_NAME(copyButton,"copyButton");
	HX_VISIT_MEMBER_NAME(pasteButton,"pasteButton");
	HX_VISIT_MEMBER_NAME(colorGradient,"colorGradient");
	HX_VISIT_MEMBER_NAME(colorGradientSelector,"colorGradientSelector");
	HX_VISIT_MEMBER_NAME(colorPalette,"colorPalette");
	HX_VISIT_MEMBER_NAME(colorWheel,"colorWheel");
	HX_VISIT_MEMBER_NAME(colorWheelSelector,"colorWheelSelector");
	HX_VISIT_MEMBER_NAME(alphabetR,"alphabetR");
	HX_VISIT_MEMBER_NAME(alphabetG,"alphabetG");
	HX_VISIT_MEMBER_NAME(alphabetB,"alphabetB");
	HX_VISIT_MEMBER_NAME(alphabetHex,"alphabetHex");
	HX_VISIT_MEMBER_NAME(modeBG,"modeBG");
	HX_VISIT_MEMBER_NAME(notesBG,"notesBG");
	HX_VISIT_MEMBER_NAME(controllerPointer,"controllerPointer");
	HX_VISIT_MEMBER_NAME(_lastControllerMode,"_lastControllerMode");
	HX_VISIT_MEMBER_NAME(tipTxt,"tipTxt");
	HX_VISIT_MEMBER_NAME(_storedColor,"_storedColor");
	HX_VISIT_MEMBER_NAME(changingNote,"changingNote");
	HX_VISIT_MEMBER_NAME(holdingOnObj,"holdingOnObj");
	HX_VISIT_MEMBER_NAME(allowedTypeKeys,"allowedTypeKeys");
	HX_VISIT_MEMBER_NAME(skinNote,"skinNote");
	HX_VISIT_MEMBER_NAME(modeNotes,"modeNotes");
	HX_VISIT_MEMBER_NAME(myNotes,"myNotes");
	HX_VISIT_MEMBER_NAME(bigNote,"bigNote");
	 ::flixel::FlxSubState_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val NotesColorSubState_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"modeBG") ) { return ::hx::Val( modeBG ); }
		if (HX_FIELD_EQ(inName,"tipTxt") ) { return ::hx::Val( tipTxt ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"onPixel") ) { return ::hx::Val( onPixel ); }
		if (HX_FIELD_EQ(inName,"notesBG") ) { return ::hx::Val( notesBG ); }
		if (HX_FIELD_EQ(inName,"myNotes") ) { return ::hx::Val( myNotes ); }
		if (HX_FIELD_EQ(inName,"bigNote") ) { return ::hx::Val( bigNote ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"pointerX") ) { return ::hx::Val( pointerX_dyn() ); }
		if (HX_FIELD_EQ(inName,"pointerY") ) { return ::hx::Val( pointerY_dyn() ); }
		if (HX_FIELD_EQ(inName,"skinNote") ) { return ::hx::Val( skinNote ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"dataArray") ) { return ::hx::Val( dataArray ); }
		if (HX_FIELD_EQ(inName,"alphabetR") ) { return ::hx::Val( alphabetR ); }
		if (HX_FIELD_EQ(inName,"alphabetG") ) { return ::hx::Val( alphabetG ); }
		if (HX_FIELD_EQ(inName,"alphabetB") ) { return ::hx::Val( alphabetB ); }
		if (HX_FIELD_EQ(inName,"updateTip") ) { return ::hx::Val( updateTip_dyn() ); }
		if (HX_FIELD_EQ(inName,"modeNotes") ) { return ::hx::Val( modeNotes ); }
		if (HX_FIELD_EQ(inName,"getShader") ) { return ::hx::Val( getShader_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"hexTypeNum") ) { return ::hx::Val( hexTypeNum ); }
		if (HX_FIELD_EQ(inName,"copyButton") ) { return ::hx::Val( copyButton ); }
		if (HX_FIELD_EQ(inName,"colorWheel") ) { return ::hx::Val( colorWheel ); }
		if (HX_FIELD_EQ(inName,"spawnNotes") ) { return ::hx::Val( spawnNotes_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"hexTypeLine") ) { return ::hx::Val( hexTypeLine ); }
		if (HX_FIELD_EQ(inName,"pasteButton") ) { return ::hx::Val( pasteButton ); }
		if (HX_FIELD_EQ(inName,"alphabetHex") ) { return ::hx::Val( alphabetHex ); }
		if (HX_FIELD_EQ(inName,"updateNotes") ) { return ::hx::Val( updateNotes_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"onModeColumn") ) { return ::hx::Val( onModeColumn ); }
		if (HX_FIELD_EQ(inName,"colorPalette") ) { return ::hx::Val( colorPalette ); }
		if (HX_FIELD_EQ(inName,"_storedColor") ) { return ::hx::Val( _storedColor ); }
		if (HX_FIELD_EQ(inName,"changingNote") ) { return ::hx::Val( changingNote ); }
		if (HX_FIELD_EQ(inName,"holdingOnObj") ) { return ::hx::Val( holdingOnObj ); }
		if (HX_FIELD_EQ(inName,"updateColors") ) { return ::hx::Val( updateColors_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"colorGradient") ) { return ::hx::Val( colorGradient ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"setShaderColor") ) { return ::hx::Val( setShaderColor_dyn() ); }
		if (HX_FIELD_EQ(inName,"getShaderColor") ) { return ::hx::Val( getShaderColor_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"curSelectedMode") ) { return ::hx::Val( curSelectedMode ); }
		if (HX_FIELD_EQ(inName,"curSelectedNote") ) { return ::hx::Val( curSelectedNote ); }
		if (HX_FIELD_EQ(inName,"allowedTypeKeys") ) { return ::hx::Val( allowedTypeKeys ); }
		if (HX_FIELD_EQ(inName,"pointerOverlaps") ) { return ::hx::Val( pointerOverlaps_dyn() ); }
		if (HX_FIELD_EQ(inName,"pointerFlxPoint") ) { return ::hx::Val( pointerFlxPoint_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"controllerPointer") ) { return ::hx::Val( controllerPointer ); }
		if (HX_FIELD_EQ(inName,"centerHexTypeLine") ) { return ::hx::Val( centerHexTypeLine_dyn() ); }
		if (HX_FIELD_EQ(inName,"makeColorAlphabet") ) { return ::hx::Val( makeColorAlphabet_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"colorWheelSelector") ) { return ::hx::Val( colorWheelSelector ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"hexTypeVisibleTimer") ) { return ::hx::Val( hexTypeVisibleTimer ); }
		if (HX_FIELD_EQ(inName,"_lastControllerMode") ) { return ::hx::Val( _lastControllerMode ); }
		if (HX_FIELD_EQ(inName,"changeSelectionMode") ) { return ::hx::Val( changeSelectionMode_dyn() ); }
		if (HX_FIELD_EQ(inName,"changeSelectionNote") ) { return ::hx::Val( changeSelectionNote_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"colorGradientSelector") ) { return ::hx::Val( colorGradientSelector ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val NotesColorSubState_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"modeBG") ) { modeBG=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tipTxt") ) { tipTxt=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"onPixel") ) { onPixel=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"notesBG") ) { notesBG=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"myNotes") ) { myNotes=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bigNote") ) { bigNote=inValue.Cast<  ::objects::Note >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"skinNote") ) { skinNote=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"dataArray") ) { dataArray=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetR") ) { alphabetR=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetG") ) { alphabetG=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetB") ) { alphabetB=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		if (HX_FIELD_EQ(inName,"modeNotes") ) { modeNotes=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"hexTypeNum") ) { hexTypeNum=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"copyButton") ) { copyButton=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorWheel") ) { colorWheel=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"hexTypeLine") ) { hexTypeLine=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pasteButton") ) { pasteButton=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alphabetHex") ) { alphabetHex=inValue.Cast<  ::objects::Alphabet >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"onModeColumn") ) { onModeColumn=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorPalette") ) { colorPalette=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_storedColor") ) { _storedColor=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"changingNote") ) { changingNote=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"holdingOnObj") ) { holdingOnObj=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"colorGradient") ) { colorGradient=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"curSelectedMode") ) { curSelectedMode=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"curSelectedNote") ) { curSelectedNote=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"allowedTypeKeys") ) { allowedTypeKeys=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"controllerPointer") ) { controllerPointer=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"colorWheelSelector") ) { colorWheelSelector=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"hexTypeVisibleTimer") ) { hexTypeVisibleTimer=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_lastControllerMode") ) { _lastControllerMode=inValue.Cast< bool >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"colorGradientSelector") ) { colorGradientSelector=inValue.Cast<  ::flixel::FlxSprite >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void NotesColorSubState_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("onModeColumn",98,64,71,e9));
	outFields->push(HX_("curSelectedMode",fe,04,4b,47));
	outFields->push(HX_("curSelectedNote",8d,49,f4,47));
	outFields->push(HX_("onPixel",e7,64,e1,58));
	outFields->push(HX_("dataArray",0f,ef,7e,6b));
	outFields->push(HX_("hexTypeLine",c9,ed,15,a7));
	outFields->push(HX_("hexTypeNum",11,5a,3d,ed));
	outFields->push(HX_("hexTypeVisibleTimer",c8,0c,57,76));
	outFields->push(HX_("copyButton",87,c7,a4,8f));
	outFields->push(HX_("pasteButton",a5,e9,40,61));
	outFields->push(HX_("colorGradient",73,02,02,2d));
	outFields->push(HX_("colorGradientSelector",b2,1c,65,2f));
	outFields->push(HX_("colorPalette",58,8b,ba,95));
	outFields->push(HX_("colorWheel",38,4c,26,ee));
	outFields->push(HX_("colorWheelSelector",77,33,40,df));
	outFields->push(HX_("alphabetR",3f,a0,34,f0));
	outFields->push(HX_("alphabetG",34,a0,34,f0));
	outFields->push(HX_("alphabetB",2f,a0,34,f0));
	outFields->push(HX_("alphabetHex",e8,2f,c5,de));
	outFields->push(HX_("modeBG",e8,eb,c6,c0));
	outFields->push(HX_("notesBG",46,68,6b,4d));
	outFields->push(HX_("controllerPointer",81,db,f4,1b));
	outFields->push(HX_("_lastControllerMode",34,63,09,11));
	outFields->push(HX_("tipTxt",d5,cf,c0,20));
	outFields->push(HX_("_storedColor",01,57,07,9c));
	outFields->push(HX_("changingNote",3f,d5,59,d6));
	outFields->push(HX_("holdingOnObj",15,34,32,64));
	outFields->push(HX_("allowedTypeKeys",16,fb,41,3c));
	outFields->push(HX_("skinNote",0f,dd,91,98));
	outFields->push(HX_("modeNotes",de,51,0f,71));
	outFields->push(HX_("myNotes",35,85,ca,48));
	outFields->push(HX_("bigNote",d2,5c,d9,68));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo NotesColorSubState_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(NotesColorSubState_obj,onModeColumn),HX_("onModeColumn",98,64,71,e9)},
	{::hx::fsInt,(int)offsetof(NotesColorSubState_obj,curSelectedMode),HX_("curSelectedMode",fe,04,4b,47)},
	{::hx::fsInt,(int)offsetof(NotesColorSubState_obj,curSelectedNote),HX_("curSelectedNote",8d,49,f4,47)},
	{::hx::fsBool,(int)offsetof(NotesColorSubState_obj,onPixel),HX_("onPixel",e7,64,e1,58)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(NotesColorSubState_obj,dataArray),HX_("dataArray",0f,ef,7e,6b)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,hexTypeLine),HX_("hexTypeLine",c9,ed,15,a7)},
	{::hx::fsInt,(int)offsetof(NotesColorSubState_obj,hexTypeNum),HX_("hexTypeNum",11,5a,3d,ed)},
	{::hx::fsFloat,(int)offsetof(NotesColorSubState_obj,hexTypeVisibleTimer),HX_("hexTypeVisibleTimer",c8,0c,57,76)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,copyButton),HX_("copyButton",87,c7,a4,8f)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,pasteButton),HX_("pasteButton",a5,e9,40,61)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,colorGradient),HX_("colorGradient",73,02,02,2d)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,colorGradientSelector),HX_("colorGradientSelector",b2,1c,65,2f)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,colorPalette),HX_("colorPalette",58,8b,ba,95)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,colorWheel),HX_("colorWheel",38,4c,26,ee)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,colorWheelSelector),HX_("colorWheelSelector",77,33,40,df)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesColorSubState_obj,alphabetR),HX_("alphabetR",3f,a0,34,f0)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesColorSubState_obj,alphabetG),HX_("alphabetG",34,a0,34,f0)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesColorSubState_obj,alphabetB),HX_("alphabetB",2f,a0,34,f0)},
	{::hx::fsObject /*  ::objects::Alphabet */ ,(int)offsetof(NotesColorSubState_obj,alphabetHex),HX_("alphabetHex",e8,2f,c5,de)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,modeBG),HX_("modeBG",e8,eb,c6,c0)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,notesBG),HX_("notesBG",46,68,6b,4d)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,controllerPointer),HX_("controllerPointer",81,db,f4,1b)},
	{::hx::fsBool,(int)offsetof(NotesColorSubState_obj,_lastControllerMode),HX_("_lastControllerMode",34,63,09,11)},
	{::hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(NotesColorSubState_obj,tipTxt),HX_("tipTxt",d5,cf,c0,20)},
	{::hx::fsInt,(int)offsetof(NotesColorSubState_obj,_storedColor),HX_("_storedColor",01,57,07,9c)},
	{::hx::fsBool,(int)offsetof(NotesColorSubState_obj,changingNote),HX_("changingNote",3f,d5,59,d6)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,holdingOnObj),HX_("holdingOnObj",15,34,32,64)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(NotesColorSubState_obj,allowedTypeKeys),HX_("allowedTypeKeys",16,fb,41,3c)},
	{::hx::fsObject /*  ::flixel::FlxSprite */ ,(int)offsetof(NotesColorSubState_obj,skinNote),HX_("skinNote",0f,dd,91,98)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(NotesColorSubState_obj,modeNotes),HX_("modeNotes",de,51,0f,71)},
	{::hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(NotesColorSubState_obj,myNotes),HX_("myNotes",35,85,ca,48)},
	{::hx::fsObject /*  ::objects::Note */ ,(int)offsetof(NotesColorSubState_obj,bigNote),HX_("bigNote",d2,5c,d9,68)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *NotesColorSubState_obj_sStaticStorageInfo = 0;
#endif

static ::String NotesColorSubState_obj_sMemberFields[] = {
	HX_("onModeColumn",98,64,71,e9),
	HX_("curSelectedMode",fe,04,4b,47),
	HX_("curSelectedNote",8d,49,f4,47),
	HX_("onPixel",e7,64,e1,58),
	HX_("dataArray",0f,ef,7e,6b),
	HX_("hexTypeLine",c9,ed,15,a7),
	HX_("hexTypeNum",11,5a,3d,ed),
	HX_("hexTypeVisibleTimer",c8,0c,57,76),
	HX_("copyButton",87,c7,a4,8f),
	HX_("pasteButton",a5,e9,40,61),
	HX_("colorGradient",73,02,02,2d),
	HX_("colorGradientSelector",b2,1c,65,2f),
	HX_("colorPalette",58,8b,ba,95),
	HX_("colorWheel",38,4c,26,ee),
	HX_("colorWheelSelector",77,33,40,df),
	HX_("alphabetR",3f,a0,34,f0),
	HX_("alphabetG",34,a0,34,f0),
	HX_("alphabetB",2f,a0,34,f0),
	HX_("alphabetHex",e8,2f,c5,de),
	HX_("modeBG",e8,eb,c6,c0),
	HX_("notesBG",46,68,6b,4d),
	HX_("controllerPointer",81,db,f4,1b),
	HX_("_lastControllerMode",34,63,09,11),
	HX_("tipTxt",d5,cf,c0,20),
	HX_("updateTip",d2,3e,e5,82),
	HX_("_storedColor",01,57,07,9c),
	HX_("changingNote",3f,d5,59,d6),
	HX_("holdingOnObj",15,34,32,64),
	HX_("allowedTypeKeys",16,fb,41,3c),
	HX_("update",09,86,05,87),
	HX_("pointerOverlaps",e9,d4,f8,c3),
	HX_("pointerX",fb,e4,66,ac),
	HX_("pointerY",fc,e4,66,ac),
	HX_("pointerFlxPoint",5b,04,86,28),
	HX_("centerHexTypeLine",f4,b5,6b,cc),
	HX_("changeSelectionMode",3f,a6,f0,a1),
	HX_("changeSelectionNote",ce,ea,99,a2),
	HX_("makeColorAlphabet",68,3e,89,ba),
	HX_("skinNote",0f,dd,91,98),
	HX_("modeNotes",de,51,0f,71),
	HX_("myNotes",35,85,ca,48),
	HX_("bigNote",d2,5c,d9,68),
	HX_("spawnNotes",06,38,e3,d9),
	HX_("updateNotes",78,45,63,85),
	HX_("updateColors",99,6c,4a,c6),
	HX_("setShaderColor",7c,57,47,c9),
	HX_("getShaderColor",08,6f,27,a9),
	HX_("getShader",5b,48,77,99),
	HX_("destroy",fa,2c,86,24),
	::String(null()) };

::hx::Class NotesColorSubState_obj::__mClass;

void NotesColorSubState_obj::__register()
{
	NotesColorSubState_obj _hx_dummy;
	NotesColorSubState_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("options.NotesColorSubState",23,9b,d9,87);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(NotesColorSubState_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< NotesColorSubState_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = NotesColorSubState_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = NotesColorSubState_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace options
